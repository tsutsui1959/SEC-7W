<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<rules>
   <builtin>
      <category description="コーディング規約" name="CODSTA">
         <rule header="配列要素には、配列演算子 [ ] によってアクセスするべきである" id="01" impl="CODSTA-01" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-01.rule"/>
         </rule>
         <rule header="メンバ変数をビット フィールドとして宣言してはいけない" id="02" impl="CODSTA-02" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-02.rule"/>
         </rule>
         <rule header="#define を使用して定数を定義しない" id="03" impl="CODSTA-03" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-03.rule"/>
         </rule>
         <rule header="static を使ってローカル変数を宣言してはいけない" id="04" impl="CODSTA-04" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-04.rule"/>
         </rule>
         <rule header="ポインタへのポインタは可能な限り避けるべきである" id="05" impl="CODSTA-05" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-05.rule"/>
         </rule>
         <rule header="?: 演算子を使ってはいけない" id="06" impl="CODSTA-06" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-06.rule"/>
         </rule>
         <rule header="関数にパラメータがない場合、(void) ではなく () を使用する" id="07" impl="CODSTA-07" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-07.rule"/>
         </rule>
         <rule header="for ループ中で break を使ってはいけない" id="08" impl="CODSTA-08" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-08.rule"/>
         </rule>
         <rule header="関数へのポインタを基本型へのポインタにキャストしてはいけない" id="09" impl="CODSTA-09" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-09.rule"/>
         </rule>
         <rule header="ストレージタイプ修飾子は、変数や関数ではなく、型に関連付けなければならない" id="10" impl="CODSTA-10" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-10.rule"/>
         </rule>
         <rule header="算術演算で符号ありの値と符号なしの値を混在させてはならない" id="100" impl="CODSTA-100" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-100.rule"/>
         </rule>
         <rule header="条件演算子の 2 番目のオペランドと 3 番目のオペランドに符号ありの値と符号なしの値を混在させてはならない" id="101" impl="CODSTA-101" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-101.rule"/>
         </rule>
         <rule header="副作用がある単一の演算子は適切なコンテキストでだけ使用する" id="102" impl="CODSTA-102" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-102.rule"/>
         </rule>
         <rule header="副作用がある関数の呼び出しは適切なコンテキストでだけ使用する" id="103" impl="CODSTA-103" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-103.rule"/>
         </rule>
         <rule header="論理演算子 &amp;&amp; または || のオペランドに二項演算子が含まれる場合、オペランドを括弧で囲む必要がある" id="104" impl="CODSTA-104" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-104.rule"/>
         </rule>
         <rule header="3 項演算子 '?:' の 2 番目または 3 番目のオペランドに副作用があってはならない" id="105" impl="CODSTA-105" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-105.rule"/>
         </rule>
         <rule header="&lt;stdlib.h&gt; のライブラリ関数 bsearch および qsort を使用してはいけない" id="107" impl="CODSTA-107" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-107.rule"/>
         </rule>
         <rule header="&lt;tgmath.h&gt; ヘッダーをインクルードしない" id="108" impl="CODSTA-108" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-108.rule"/>
         </rule>
         <rule header="&lt;fenv.h&gt; の例外処理を使用してはいけない" id="109" impl="CODSTA-109" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-109.rule"/>
         </rule>
         <rule header="Assert を多く使用して内部的な仮定条件や不変条件を文書化する" id="11" impl="CODSTA-11" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-11.rule"/>
         </rule>
         <rule header="標準ライブラリの入出力関数を使用してはいけない" id="110" impl="CODSTA-110" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-110.rule"/>
         </rule>
         <rule header="union キーワードを使用してはいけない" id="111" impl="CODSTA-111" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-111.rule"/>
         </rule>
         <rule header="可変長配列を使用してはいけない" id="112" impl="CODSTA-112" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-112.rule"/>
         </rule>
         <rule header="フレキシブル配列メンバーを宣言してはいけない" id="113" impl="CODSTA-113" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-113.rule"/>
         </rule>
         <rule header="アセンブリ言語はカプセル化して C/C++ 関数で分離しなければならない" id="114" impl="CODSTA-114" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-114.rule"/>
         </rule>
         <rule header="構造体または共用体を指すポインターが翻訳単位内で 1 回も間接参照されない場合、オブジェクトの実装を隠すべきである" id="115" impl="CODSTA-115" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-115.rule"/>
         </rule>
         <rule header="'default' ラベルがある場合、 'default' ラベルは switch 文の最初または最後の switch ラベルとして出現しなければならない" id="116" impl="CODSTA-116" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-116.rule"/>
         </rule>
         <rule header="8 進または 16 進のエスケープ シーケンスは終了させなければならない" id="117" impl="CODSTA-117" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-117.rule"/>
         </rule>
         <rule header="外部リンケージを持つオブジェクトまたは関数を定義する場合、宣言が参照できなければならない" id="118" impl="CODSTA-118" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-118.rule"/>
         </rule>
         <rule header="default ラベルの終了の break の前に 文またはコメントがなければならない" id="119" impl="CODSTA-119" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-119.rule"/>
         </rule>
         <rule header="算術演算の代わりにシフト演算を使用するのは避ける" id="12" impl="CODSTA-12" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-12.rule"/>
         </rule>
         <rule header="インライン関数は static 記憶域クラスを使って宣言しなければならない" id="120" impl="CODSTA-120" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-120.rule"/>
         </rule>
         <rule header="restrict 型修飾子を使用してはいけない" id="121" impl="CODSTA-121" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-121.rule"/>
         </rule>
         <rule header="戻り型が void ではない関数によって返却される値を使用しなければならない" id="122_a" impl="CODSTA-122_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_a.rule"/>
         </rule>
         <rule header="戻り型が void ではない関数によって返却される値を使用しなければならない" id="122_b" impl="CODSTA-122_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_b.rule"/>
         </rule>
         <rule header="インクリメント (++) またはデクリメント (--) 演算子がある完全な式は、他の副作用の可能性があってはならない" id="123" impl="CODSTA-123" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-123.rule"/>
         </rule>
         <rule header="関数へのポインターとそれ以外の型との間で変換を行ってはならない" id="124_a" impl="CODSTA-124_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_a.rule"/>
         </rule>
         <rule header="互換性のない関数型へのポインターの間で変換を行ってはならない" id="124_b" impl="CODSTA-124_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_b.rule"/>
         </rule>
         <rule header="不完全型へのポインターと他の型との間で変換を行ってはならない" id="125" impl="CODSTA-125" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-125.rule"/>
         </rule>
         <rule header="オブジェクト型へのポインターと別のオブジェクト型へのポインターとの間で変換を行ってはならない" id="126" impl="CODSTA-126" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-126.rule"/>
         </rule>
         <rule header="オブジェクトへのポインターと整数型との間で変換を行ってはならない" id="127" impl="CODSTA-127" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127.rule"/>
         </rule>
         <rule header="オブジェクト型へのポインターと 'uintptr_t' または 'intptr_t' 以外の整数型の間で変換を行うべきではない" id="127_b" impl="CODSTA-127_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127_b.rule"/>
         </rule>
         <rule header="void へのポインターをオブジェクトへのポインターに変換してはならない" id="128" impl="CODSTA-128" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-128.rule"/>
         </rule>
         <rule header="void へのポインターと数値型との間でキャストしてはならない" id="129_a" impl="CODSTA-129_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_a.rule"/>
         </rule>
         <rule header="void へのポインターと数値型との間で暗黙の変換を行ってはならない" id="129_b" impl="CODSTA-129_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_b.rule"/>
         </rule>
         <rule header="同じ配列を指している場合を除き、ポインター型に &gt;、&gt;=、&lt;、&lt;= を適用してはならない" id="13" impl="CODSTA-13" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13.rule"/>
         </rule>
         <rule header="オブジェクトへのポインターと非整数数値型との間でキャストしてはならない" id="130" impl="CODSTA-130" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-130.rule"/>
         </rule>
         <rule header="null ポインター定数としてリテラルのゼロ (0) ではなく NULL を使用する" id="131" impl="CODSTA-131" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-131.rule"/>
         </rule>
         <rule header="関数のパラメーターを変更するべきではない" id="132" impl="CODSTA-132" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-132.rule"/>
         </rule>
         <rule header="C90 のキーワードと同じ名前を持つマクロを定義してはならない" id="133_a" impl="CODSTA-133_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_a.rule"/>
         </rule>
         <rule header="C99 のキーワードと同じ名前を持つマクロを定義してはならない" id="133_b" impl="CODSTA-133_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_b.rule"/>
         </rule>
         <rule header="配列型として宣言されたパラメーターに対応する関数引数には、適切な数の要素がなければならない" id="134" impl="CODSTA-134" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-134.rule"/>
         </rule>
         <rule header="他の型からポインター型へのキャスト、またはポインター型からのキャストを使用してはならない" id="135" impl="CODSTA-135" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-135.rule"/>
         </rule>
         <rule header="識別子 va_list、va_arg、va_start、va_end、va_copy を使用するべきではない" id="136_a" impl="CODSTA-136_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_a.rule"/>
         </rule>
         <rule header="識別子 va_list、va_arg、va_start、va_end を使用するべきではない" id="136_b" impl="CODSTA-136_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_b.rule"/>
         </rule>
         <rule header="関数の呼び出しを sizeof 演算子のオペランドとして使用してはならない" id="137" impl="CODSTA-137" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-137.rule"/>
         </rule>
         <rule header="組み込みの代入演算子の結果を使用するべきではない" id="138" impl="CODSTA-138" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-138.rule"/>
         </rule>
         <rule header="ポインターの減算は、同じ配列の要素を指すポインターにだけ適用する" id="13_b" impl="CODSTA-13_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13_b.rule"/>
         </rule>
         <rule header="絶対に const を non-const に変換してはいけない" id="14" impl="CODSTA-14" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-14.rule"/>
         </rule>
         <rule header="初期化リストに永続的な副作用が含まれていてはならない" id="141_a" impl="CODSTA-141_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-141_a.rule"/>
         </rule>
         <rule header="グローバル関数は配列型のパラメーターを宣言してはならない" id="142" impl="CODSTA-142" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-142.rule"/>
         </rule>
         <rule header="配列引数を使用して呼び出される関数はポインター型のパラメーターを宣言してはならない" id="142_b" impl="CODSTA-142_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-142_b.rule"/>
         </rule>
         <rule header="コピー元バッファーのサイズをチェックしていない、疑わしい strcpy の使用" id="143" impl="CODSTA-143" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-143.rule"/>
         </rule>
         <rule header="read および readlink 関数から返される値を使用する" id="144" impl="CODSTA-144" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-144.rule"/>
         </rule>
         <rule header="null 終端された文字列を期待する関数での null 終端されていない可能性がある文字列の使用" id="145" impl="CODSTA-145" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-145.rule"/>
         </rule>
         <rule header="stdio 文字 I/O 関数の戻り値を int より小さい型に暗黙的に変換してはならない" id="146" impl="CODSTA-146" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-146.rule"/>
         </rule>
         <rule header="関係演算子 &lt;、&gt;、&gt;=、&lt;= を使用してポインターと NULL を比較してはならない" id="147" impl="CODSTA-147" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-147.rule"/>
         </rule>
         <rule header="等価演算子または関係演算子のオペランドとして文字列リテラルを使用しない" id="148" impl="CODSTA-148" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-148.rule"/>
         </rule>
         <rule header="switch 文の case の間に break 文がない" id="149" impl="CODSTA-149" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-149.rule"/>
         </rule>
         <rule header="関数のパラメータとして渡される配列の大きさを宣言してはいけない" id="15" impl="CODSTA-15" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-15.rule"/>
         </rule>
         <rule header="アサーションに代入、インクリメント、またはデクリメント演算子を含めてはならない" id="150" impl="CODSTA-150" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150.rule"/>
         </rule>
         <rule header="アサーションに関数の呼び出しや関数マクロの呼び出しを含めてはならない" id="150_b" impl="CODSTA-150_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-150_b.rule"/>
         </rule>
         <rule header="安全ではないマクロの引数での副作用を避ける" id="150_c" impl="CODSTA-150_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150_c.rule"/>
         </rule>
         <rule header="ブール条件で列挙型を使用しない" id="151" impl="CODSTA-151" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-151.rule"/>
         </rule>
         <rule header="複合式の値を別の実質的な型カテゴリまたはより大きい実質的な型にキャストしてはならない" id="152" impl="CODSTA-152" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-152.rule"/>
         </rule>
         <rule header="翻訳単位の中で、外部オブジェクトまたは外部関数に 2 つ以上の非定義宣言があってはならない" id="154" impl="CODSTA-154" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-154.rule"/>
         </rule>
         <rule header="C99 規格のコードでは、独自の typedef を宣言する代わりに stdint.h の typedef を使用する" id="155" impl="CODSTA-155" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-155.rule"/>
         </rule>
         <rule header="通常の数値変換が行われる演算子のオペランドの 1 つとして複合式が使用される場合、他方のオペランドはより大きい実質的な型を持つ型であってはならない" id="156_a" impl="CODSTA-156_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_a.rule"/>
         </rule>
         <rule header="条件演算子の (2 つ目または 3 つ目の) オペランドとして複合式が使用される場合、他のオペランドはより大きい実質的な型を持つ型であってはならない" id="156_b" impl="CODSTA-156_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_b.rule"/>
         </rule>
         <rule header="複合式の値をより大きい実質的な型を持つオブジェクトに代入してはならない" id="157" impl="CODSTA-157" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-157.rule"/>
         </rule>
         <rule header="関数型には名前付きのパラメーターがなければならない" id="158" impl="CODSTA-158" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-158.rule"/>
         </rule>
         <rule header="関数型はプロトタイプ形式でなければならない" id="159" impl="CODSTA-159" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-159.rule"/>
         </rule>
         <rule header="配列を初期化する場合、配列の大きさを宣言してはいけない" id="16" impl="CODSTA-16" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-16.rule"/>
         </rule>
         <rule header="配列パラメーターの宣言の [ ] の中に static キーワードが含まれていてはならない" id="160" impl="CODSTA-160" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-160.rule"/>
         </rule>
         <rule header="オペランドがブール値として解釈される場合、常に実質的なブール型の式を使用するべきである" id="161_a" impl="CODSTA-161_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_a.rule"/>
         </rule>
         <rule header="オペランドが数値として解釈される場合、実質的なブール型のオペランドを使用するべきではない" id="161_b" impl="CODSTA-161_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_b.rule"/>
         </rule>
         <rule header="オペランドが数値として解釈される場合、実質的な文字型のオペランドを使用するべきではない" id="161_c" impl="CODSTA-161_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_c.rule"/>
         </rule>
         <rule header="算術演算では実質的な列挙型のオペランドを使用するべきではない" id="161_d" impl="CODSTA-161_d" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_d.rule"/>
         </rule>
         <rule header="実質的な signed 型または列挙型のオペランドに対してシフトおよびビット演算を行うべきではない" id="161_e" impl="CODSTA-161_e" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_e.rule"/>
         </rule>
         <rule header="ビット シフト演算の右辺のオペランドとして実質的な signed 型または列挙型のオペランドを使用するべきではない" id="161_f" impl="CODSTA-161_f" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_f.rule"/>
         </rule>
         <rule header="単項マイナス演算子のオペランドとして実質的な unsigned 型のオペランドを使用するべきではない" id="161_g" impl="CODSTA-161_g" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_g.rule"/>
         </rule>
         <rule header="実質的な文字型の式を加算または減算演算で不適切に使用するべきではない" id="162" impl="CODSTA-162" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-162.rule"/>
         </rule>
         <rule header="式の値をより小さい実質的な型を持つオブジェクトに代入してはならない" id="163_a" impl="CODSTA-163_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_a.rule"/>
         </rule>
         <rule header="式の値を実質的な型カテゴリが異なるオブジェクトに代入してはならない" id="163_b" impl="CODSTA-163_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_b.rule"/>
         </rule>
         <rule header="通常の算術変換が行われる演算子の 2 つのオペランドは、同じ実質的な型カテゴリでなければならない" id="164_a" impl="CODSTA-164_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_a.rule"/>
         </rule>
         <rule header="3 項演算子の 2 番目および 3 番目のオペランドは同じ実質的な型カテゴリでなければならない" id="164_b" impl="CODSTA-164_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_b.rule"/>
         </rule>
         <rule header="実質的な列挙型へのキャスト演算は許されない" id="165_a" impl="CODSTA-165_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_a.rule"/>
         </rule>
         <rule header="実質的なブール型から、また実質的なブール型にキャストしてはならない" id="165_b" impl="CODSTA-165_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-165_b.rule"/>
         </rule>
         <rule header="実質的な文字型と実質的な浮動小数点型の間でキャストしてはならない" id="165_c" impl="CODSTA-165_c" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_c.rule"/>
         </rule>
         <rule header="FILE オブジェクトへのポインターを間接参照してはいけない" id="166_a" impl="CODSTA-166_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_a.rule"/>
         </rule>
         <rule header="FILE オブジェクトへのポインターをライブラリ関数から間接参照してはいけない" id="166_b" impl="CODSTA-166_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_b.rule"/>
         </rule>
         <rule header="for ループのカウンターは、実質的な浮動小数点型であってはならない" id="167_a" impl="CODSTA-167_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_a.rule"/>
         </rule>
         <rule header="while および do-while ループのカウンターは、実質的な浮動小数点型であってはならない" id="167_b" impl="CODSTA-167_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_b.rule"/>
         </rule>
         <rule header="for ループにはループ カウンターが 1 つだけあること、またループ カウンターが for ループ本文で変更されてはならない" id="168" impl="CODSTA-168" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-168.rule"/>
         </rule>
         <rule header="for ループの最初の句は整形式でなければならない" id="169_a" impl="CODSTA-169_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_a.rule"/>
         </rule>
         <rule header="for ループの 2 番目の句は整形式でなければならない" id="169_b" impl="CODSTA-169_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_b.rule"/>
         </rule>
         <rule header="for ループの 3 番目の句は整形式でなければならない" id="169_c" impl="CODSTA-169_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_c.rule"/>
         </rule>
         <rule header="NULL 識別子を使用してはならない。代わりに 0 を使用する" id="17" impl="CODSTA-17" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-17.rule"/>
         </rule>
         <rule header="プリプロセスの前に存在するマクロの名前は、プリプロセス後に存在する識別子と違っているべきである (c90)" id="170_c90" impl="CODSTA-170_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c90.rule"/>
         </rule>
         <rule header="プリプロセスの前に存在するマクロの名前は、プリプロセス後に存在する識別子と違っているべきである (c99)" id="170_c99" impl="CODSTA-170_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c99.rule"/>
         </rule>
         <rule header="マクロの名前はマクロのパラメーターと違っているべきである(c90)" id="171_c90" impl="CODSTA-171_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c90.rule"/>
         </rule>
         <rule header="マクロの名前はマクロのパラメーターと違っているべきである (c99)" id="171_c99" impl="CODSTA-171_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c99.rule"/>
         </rule>
         <rule header="マクロの名前は現在定義されている他のマクロの名前と違っているべきである(c90)" id="172_c90" impl="CODSTA-172_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c90.rule"/>
         </rule>
         <rule header="マクロの名前は現在定義されている他のマクロの名前と違っているべきである(c99)" id="172_c99" impl="CODSTA-172_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c99.rule"/>
         </rule>
         <rule header="プログラムは規格によって定められた翻訳限界を超えてはならない (c90)" id="174_a_c90" impl="CODSTA-174_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c90.rule"/>
         </rule>
         <rule header="プログラムは規格によって定められた翻訳限界を超えてはならない (c99)" id="174_a_c99" impl="CODSTA-174_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c99.rule"/>
         </rule>
         <rule header="プログラムは規格によって定められた翻訳限界を超えてはならない (c90)" id="174_b_c90" impl="CODSTA-174_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c90.rule"/>
         </rule>
         <rule header="プログラムは規格によって定められた翻訳限界を超えてはならない (c99)" id="174_b_c99" impl="CODSTA-174_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c99.rule"/>
         </rule>
         <rule header="関数は未使用の型宣言を持つべきではない" id="175_a" impl="CODSTA-175_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_a.rule"/>
         </rule>
         <rule header="ソース ファイルは未使用の型宣言を持つべきではない" id="175_b" impl="CODSTA-175_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_b.rule"/>
         </rule>
         <rule header="関数は未使用のローカル タグ宣言を持つべきではない" id="176_a" impl="CODSTA-176_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_a.rule"/>
         </rule>
         <rule header="ソース ファイルは未使用のタグ宣言を持つべきではない" id="176_b" impl="CODSTA-176_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_b.rule"/>
         </rule>
         <rule header="ソース ファイルは未使用のマクロ宣言を持つべきではない" id="177" impl="CODSTA-177" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-177.rule"/>
         </rule>
         <rule header="外部識別子は区別できなければならない" id="178" impl="CODSTA-178" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-178.rule"/>
         </rule>
         <rule header="ファイル スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c90)" id="179_a_c90" impl="CODSTA-179_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c90.rule"/>
         </rule>
         <rule header="ファイル スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c99)" id="179_a_c99" impl="CODSTA-179_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c99.rule"/>
         </rule>
         <rule header="同じブロック スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c90)" id="179_b_c90" impl="CODSTA-179_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c90.rule"/>
         </rule>
         <rule header="同じブロック スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c99)" id="179_b_c99" impl="CODSTA-179_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c99.rule"/>
         </rule>
         <rule header="do 文よりも while 文を使用する" id="18" impl="CODSTA-18" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-18.rule"/>
         </rule>
         <rule header="外部リンケージを持つオブジェクトや関数を定義する識別子はユニークでなければならない" id="180" impl="CODSTA-180" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-180.rule"/>
         </rule>
         <rule header="+、-、+= および -= 演算子をポインター型の式に適用するべきではない" id="181" impl="CODSTA-181" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-181.rule"/>
         </rule>
         <rule header="sizeof 演算子のオペランドは「配列型」として宣言された関数のパラメーターであってはならない" id="182" impl="CODSTA-182" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-182.rule"/>
         </rule>
         <rule header="標準ライブラリ関数 memcmp、memmove および memcmp へのポインター引数は、互換性のある型の修飾付きおよび修飾なし版へのポインターでなければならない" id="183" impl="CODSTA-183" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-183.rule"/>
         </rule>
         <rule header="標準ライブラリ関数 memcmp へのポインター引数は、ポインター型、実質的な signed 型、実質的な unsigned 型、実質的なブール型、または実質的な列挙型を指していなければならない" id="184" impl="CODSTA-184" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-184.rule"/>
         </rule>
         <rule header="標準ライブラリ関数 localeconv、getenv、setlocale または strerror から返されたポインターは、const 修飾された型へのポインターとしてだけ使用する" id="185_a" impl="CODSTA-185_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-185_a.rule"/>
         </rule>
         <rule header="lconv 構造体のメンバーによって指し示される文字列を変更してはならない" id="185_b" impl="CODSTA-185_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-185_b.rule"/>
         </rule>
         <rule header="指定された初期化子が配列オブジェクトの初期化に使用されている場合、配列のサイズを明示的に指定する必要がある" id="186" impl="CODSTA-186" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-186.rule"/>
         </rule>
         <rule header="より大きな整数サイズに代入する前に文字を unsigned char にキャストする" id="187_a" impl="CODSTA-187_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_a.rule"/>
         </rule>
         <rule header="'signed char' 型の式を配列インデックスとして使用するべきではない" id="187_b" impl="CODSTA-187_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_b.rule"/>
         </rule>
         <rule header="より大きな整数サイズに変換する前に文字を unsigned char にキャストする" id="187_c" impl="CODSTA-187_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_c.rule"/>
         </rule>
         <rule header="ナロー文字列とワイド文字列を混同しない" id="188" impl="CODSTA-188" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-188.rule"/>
         </rule>
         <rule header="ポインターに対して、スケールされた整数値の加算または減算を行わない" id="189" impl="CODSTA-189" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-189.rule"/>
         </rule>
         <rule header="文字テストには ctype.h を使用する" id="19" impl="CODSTA-19" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-19.rule"/>
         </rule>
         <rule header="浮動小数点値の比較にオブジェクト表現を使用しない" id="190" impl="CODSTA-190" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-190.rule"/>
         </rule>
         <rule header="不正に再開される可能性がある関数をループに入れる" id="191" impl="CODSTA-191" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-191.rule"/>
         </rule>
         <rule header="サイズ 0 または 1 の配列を構造体の最後のメンバーにするべきではない" id="192" impl="CODSTA-192" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-192.rule"/>
         </rule>
         <rule header="可変長配列メンバーを含む構造体は動的に割り当てる" id="193" impl="CODSTA-193" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-193.rule"/>
         </rule>
         <rule header="誤って失敗する可能性がある関数をループに入れる" id="194" impl="CODSTA-194" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-194.rule"/>
         </rule>
         <rule header="1 つの式の中で 2 回アトミックな変数を参照しない" id="195" impl="CODSTA-195" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-195.rule"/>
         </rule>
         <rule header="関数呼び出しの結果内の配列にアクセスしない" id="196" impl="CODSTA-196" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-196.rule"/>
         </rule>
         <rule header="文字列リテラルで初期化される文字配列の上限を指定しない" id="197" impl="CODSTA-197" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-197.rule"/>
         </rule>
         <rule header="浮動小数点型の複合式の値は、より狭い浮動小数点型にだけキャストできる" id="198" impl="CODSTA-198" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198.rule"/>
         </rule>
         <rule header="アサーションを使用しない" id="199" impl="CODSTA-199" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-199.rule"/>
         </rule>
         <rule header="文字列を終了させるには、NULL ではなく EOS を 使うべきである" id="20" impl="CODSTA-20" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-20.rule"/>
         </rule>
         <rule header="初期化子内の配列宣言に明示的に配列の上限を指定する" id="200" impl="CODSTA-200" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-200.rule"/>
         </rule>
         <rule header="構造化テキストデータをネイティブに処理しない" id="201" impl="CODSTA-201" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-201.rule"/>
         </rule>
         <rule header="外部リンケージを持つ関数のインライン定義には、静的オブジェクトの定義や使用が含まれていてはならない" id="202" impl="CODSTA-202" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-202.rule"/>
         </rule>
         <rule header="文字列リテラルをハード コードしない" id="203" impl="CODSTA-203" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-203.rule"/>
         </rule>
         <rule header="'noreturn' として宣言された関数の戻り値の型は 'void' でなければならない" id="204" impl="CODSTA-204" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-204.rule"/>
         </rule>
         <rule header="配列のサイズよりも大きな構造体を指すポインターに配列をキャストしてはならない" id="205" impl="CODSTA-205" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-205.rule"/>
         </rule>
         <rule header="'_Noreturn' 関数指定子を使用するべきではない" id="206" impl="CODSTA-206" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-206.rule"/>
         </rule>
         <rule header="&lt;stdnoreturn.h&gt; ヘッダー ファイルを使用するべきではない" id="207" impl="CODSTA-207" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-207.rule"/>
         </rule>
         <rule header="&lt;stdalign.h&gt; ヘッダー ファイルを使用してはならない" id="208" impl="CODSTA-208" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-208.rule"/>
         </rule>
         <rule header="&lt;stdatomic.h&gt; によって提供される機能を使用するべきではない" id="209" impl="CODSTA-209" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-209.rule"/>
         </rule>
         <rule header="enum を使う場合、各メンバの値は明示的に宣言するべきである" id="21" impl="CODSTA-21" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-21.rule"/>
         </rule>
         <rule header="'_Thread_local' 記憶域クラス指定子を使用するべきではない" id="210" impl="CODSTA-210" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-210.rule"/>
         </rule>
         <rule header="&lt;threads.h&gt; によって提供される機能を使用するべきではない" id="211" impl="CODSTA-211" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-211.rule"/>
         </rule>
         <rule header="'rsize_t' 型を使用するべきではない" id="212" impl="CODSTA-212" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-212.rule"/>
         </rule>
         <rule header="'_Alignas' アライメント指定子および '_Alignof' 演算子を使用するべきではない" id="213" impl="CODSTA-213" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-213.rule"/>
         </rule>
         <rule header="'_Atomic' 型指定子および '_Atomic' 型修飾子を使用するべきではない" id="214" impl="CODSTA-214" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-214.rule"/>
         </rule>
         <rule header="'__STDC_WANT_LIB_EXT1__' マクロを '0' 以外の値に定義するべきではない" id="215" impl="CODSTA-215" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-215.rule"/>
         </rule>
         <rule header="'_Generic' 演算子を使用するべきではない" id="216" impl="CODSTA-216" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-216.rule"/>
         </rule>
         <rule header="'errno_t' 型を使用するべきではない" id="217" impl="CODSTA-217" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-217.rule"/>
         </rule>
         <rule header="次のマクロを使用しない: RSIZE_MAX、L_tmpnam_s、TMP_MAX_S" id="218" impl="CODSTA-218" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-218.rule"/>
         </rule>
         <rule header="Annex K of ISO/IEC 9899:2011 規格で定義された関数を使用してはならない" id="219" impl="CODSTA-219" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-219.rule"/>
         </rule>
         <rule header="ローカル変数またはパラメータの名前と、クラスのメンバ変数または親クラス/構造体のメンバ変数の名前は、2 文字以上違いがなければならない" id="22" impl="CODSTA-22" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-22.rule"/>
         </rule>
         <rule header="if ステートメントには必ず else 句を入れるべきである" id="23" impl="CODSTA-23" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-23.rule"/>
         </rule>
         <rule header="FALSE は 0 (ゼロ) として定義しなければならない" id="24" impl="CODSTA-24" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-24.rule"/>
         </rule>
         <rule header="FALSE は明示的に値 0 で初期化しなければならない" id="25" impl="CODSTA-25" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-25.rule"/>
         </rule>
         <rule header="マジック ナンバーを使用しない" id="26" impl="CODSTA-26" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-26.rule"/>
         </rule>
         <rule header="関数でグローバル変数を変更することは避ける" id="27" impl="CODSTA-27" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-27.rule"/>
         </rule>
         <rule header="共用体宣言に対してフィールドを定義する" id="28" impl="CODSTA-28" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-28.rule"/>
         </rule>
         <rule header="可能な限り、ハード コーディングされた値ではなく &quot;#define&quot; または enum 定数を使用するべきである" id="29" impl="CODSTA-29" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-29.rule"/>
         </rule>
         <rule header="関数パラメータのハンドルを返さない" id="30" impl="CODSTA-30" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-30.rule"/>
         </rule>
         <rule header="明示的型変換 (キャスト) を使用してはならない" id="31" impl="CODSTA-31" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-31.rule"/>
         </rule>
         <rule header="test がポインタの場合、if(test) または if(!test) タイプの論理式を作成しない" id="32" impl="CODSTA-32" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-32.rule"/>
         </rule>
         <rule header="if、while、switch の条件部で演算子 ++ または -- を使ってはいけない" id="33" impl="CODSTA-33" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-33.rule"/>
         </rule>
         <rule header="関数ポインタを宣言する場合は、typedef を使用してプログラムの構文を簡潔にする" id="34" impl="CODSTA-34" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-34.rule"/>
         </rule>
         <rule header="必ず switch 文にデフォルト ブランチを用意する" id="35" impl="CODSTA-35" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-35.rule"/>
         </rule>
         <rule header="基本データ型は、値を使用しない限り参照を使用しない" id="36" impl="CODSTA-36" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-36.rule"/>
         </rule>
         <rule header="単純な定数の場合は #define ではなく const オブジェクトまたは列挙型を使用する" id="37" impl="CODSTA-37" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-37.rule"/>
         </rule>
         <rule header="コンパイラが型チェックできない #define を使ってはいけない" id="38" impl="CODSTA-38" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-38.rule"/>
         </rule>
         <rule header="C++ 予約語との内部または外部の名前の競合を避ける" id="39" impl="CODSTA-39" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-39.rule"/>
         </rule>
         <rule header="関数の引数または戻り値がない場合、void を使用する" id="40" impl="CODSTA-40" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-40.rule"/>
         </rule>
         <rule header="1 つしか case のない switch 文の使用は避ける" id="41" impl="CODSTA-41" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-41.rule"/>
         </rule>
         <rule header="TRUE は 1 として定義しなければならない" id="42" impl="CODSTA-42" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-42.rule"/>
         </rule>
         <rule header="TRUE は明示的に値 1 で初期化しなければならない" id="43" impl="CODSTA-43" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-43.rule"/>
         </rule>
         <rule header="ローカル変数はメンバー変数と同じ名前を使用してはならない" id="44" impl="CODSTA-44" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-44.rule"/>
         </rule>
         <rule header="パラメーターはメンバー変数と同じ名前を使用してはならない" id="45" impl="CODSTA-45" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-45.rule"/>
         </rule>
         <rule header="実用的な場合は常に、負論理よりも正論理を使用する" id="46" impl="CODSTA-46" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-46.rule"/>
         </rule>
         <rule header="すべての構造体が typedef 宣言されなければならない" id="47" impl="CODSTA-47" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-47.rule"/>
         </rule>
         <rule header="次の 2 文字表記を使用しない &lt;%、%&gt;、&lt;:、:&gt;、%:、%:%:" id="48" impl="CODSTA-48" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-48.rule"/>
         </rule>
         <rule header="初期化式またはインクリメント式のない for ループ文を使用しない。代わりに while ループを使用する" id="49" impl="CODSTA-49" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-49.rule"/>
         </rule>
         <rule header="16 進定数はすべて大文字で表記する" id="50" impl="CODSTA-50" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-50.rule"/>
         </rule>
         <rule header="リテラル接尾辞は小文字ではなく大文字を使用する" id="51" impl="CODSTA-51" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-51.rule"/>
         </rule>
         <rule header="for ループの初期化式は、1 つのループ パラメータの値を初期化する以外の処理を行ってはならない" id="52" impl="CODSTA-52" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-52.rule"/>
         </rule>
         <rule header="for ループのインクリメント式は、1 つのループ パラメータを次の値に変更する以外の処理を行ってはならない" id="53" impl="CODSTA-53" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-53.rule"/>
         </rule>
         <rule header="switch 文には 2 つ以上の case と 1 つの default がなければならない" id="54" impl="CODSTA-54" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-54.rule"/>
         </rule>
         <rule header="整数型や定数ではなく列挙型をケース ラベルとして使用する" id="55" impl="CODSTA-55" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-55.rule"/>
         </rule>
         <rule header="switch 文のすべての case および default ラベルには、明示的な break または return 文、あるいは &quot;フォールスルー&quot; コメントがなければならない" id="56" impl="CODSTA-56" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-56.rule"/>
         </rule>
         <rule header="疑わしいセミコロンの使用" id="57" impl="CODSTA-57" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-57.rule"/>
         </rule>
         <rule header="void にキャストしてはならない" id="58" impl="CODSTA-58" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-58.rule"/>
         </rule>
         <rule header="ハードコーディングされた配列宣言および malloc の呼び出しを使用してはならない" id="59" impl="CODSTA-59" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-59.rule"/>
         </rule>
         <rule header="等価演算子 (==、!=) を使用してマクロ/列挙定数 TRUE と値を比較してはならない" id="60" impl="CODSTA-60" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-60.rule"/>
         </rule>
         <rule header="列挙型のすべての値をテストするのでない限り、switch 文の最後の節は default 節でなければならない" id="61" impl="CODSTA-61" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-61.rule"/>
         </rule>
         <rule header="関数へのポインタを他のポインタ型にキャストで変換してはならない" id="62" impl="CODSTA-62" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-62.rule"/>
         </rule>
         <rule header="ビット演算子は潜在型が符号なしのオペランドにだけ適用する" id="63" impl="CODSTA-63" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-63.rule"/>
         </rule>
         <rule header="空でない switch 節は無条件の throw 文または break 文で終了しなければならない" id="64" impl="CODSTA-64" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-64.rule"/>
         </rule>
         <rule header="整数型のオブジェクトまたは void 型へのポインタをポインタ型のオブジェクトに変換してはならない" id="65" impl="CODSTA-65" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-65.rule"/>
         </rule>
         <rule header="2 項ビット演算子の定数ではないオペランドは同じ潜在型でなければならない" id="66" impl="CODSTA-66" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-66.rule"/>
         </rule>
         <rule header="オブジェクト、関数の戻り値、関数のパラメータとして使用される型は、すべての宣言および再宣言ですべてのトークンが同じでなければならない" id="67" impl="CODSTA-67" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-67.rule"/>
         </rule>
         <rule header="すべての符号なし型の 8 進数および 16 進数整数リテラルには、接尾辞 U を適用する" id="68" impl="CODSTA-68" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-68.rule"/>
         </rule>
         <rule header="単純な char 型および wchar_t 型の式は、=、==、!=、および単項演算子 &amp; 以外の組み込み演算子のオペランドとして使用してはならない" id="69" impl="CODSTA-69" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-69.rule"/>
         </rule>
         <rule header="列挙型の式は、[ ]、=、==、!=、&lt;、&lt;=、&gt;、&gt;= および単項演算子 &amp; 以外の組み込み演算子のオペランドとして使用してはならない" id="70" impl="CODSTA-70" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-70.rule"/>
         </rule>
         <rule header="signed integer 型の名前付きのビットフィールドは 2 ビット以上の長さでなければならない" id="71" impl="CODSTA-71" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-71.rule"/>
         </rule>
         <rule header="アセンブラ命令は asm 宣言を使用して導入しなければならない" id="73" impl="CODSTA-73" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-73.rule"/>
         </rule>
         <rule header="ビットフィールドは列挙型であってはならない" id="74" impl="CODSTA-74" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-74.rule"/>
         </rule>
         <rule header="ビットフィールドはブール型、あるいは明示的な signed または unsigned の汎整数型でなければならない" id="75" impl="CODSTA-75" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-75.rule"/>
         </rule>
         <rule header="識別子 main をグローバルな main 関数以外の関数に使用してはならない" id="76" impl="CODSTA-76" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-76.rule"/>
         </rule>
         <rule header="goto 文は同じ関数ボディ内の後の部分に宣言されたラベルにジャンプしなければならない" id="77" impl="CODSTA-77" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-77.rule"/>
         </rule>
         <rule header="goto 文によって参照されるラベルは、同じブロックまたは goto 文を含む外側のブロックで宣言されなければならない" id="78" impl="CODSTA-78" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-78.rule"/>
         </rule>
         <rule header="反復文では、ループを終了するために複数の break 文または goto 文を使用してはならない" id="79" impl="CODSTA-79" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-79.rule"/>
         </rule>
         <rule header="continue 文は整形式の for ループ内でだけ使用する" id="80" impl="CODSTA-80" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-80.rule"/>
         </rule>
         <rule header="関数が内部リンケージを持つ場合、すべての再宣言に static 記憶域クラス指定子がなければならない" id="81" impl="CODSTA-81" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-81.rule"/>
         </rule>
         <rule header="無限ループを避ける" id="82" impl="CODSTA-82" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82.rule"/>
         </rule>
         <rule header="空の無限ループを使用しない" id="82_b" impl="CODSTA-82_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82_b.rule"/>
         </rule>
         <rule header="すべてのループには固定された上限または下限がなければならない" id="83" impl="CODSTA-83" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-83.rule"/>
         </rule>
         <rule header="無限ループ内の終了ポイントを避ける" id="85" impl="CODSTA-85" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-85.rule"/>
         </rule>
         <rule header="各関数内でパラメーターの妥当性を検証しなければならない" id="86" impl="CODSTA-86" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-86.rule"/>
         </rule>
         <rule header="2 階層以上の間接参照を使用してはならない" id="87" impl="CODSTA-87" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-87.rule"/>
         </rule>
         <rule header="関数ポインターを使用してはならない" id="88" impl="CODSTA-88" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-88.rule"/>
         </rule>
         <rule header="2 階層以上のポインター間接参照を宣言に含めてはならない" id="89" impl="CODSTA-89" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-89.rule"/>
         </rule>
         <rule header="論理演算子 '&amp;&amp;' または '||' の各オペランドは後置式でなければならない" id="90" impl="CODSTA-90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-90.rule"/>
         </rule>
         <rule header="関数の出口は最大でも 1 つでなくてはならない" id="91" impl="CODSTA-91" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-91.rule"/>
         </rule>
         <rule header="標準ライブラリのマクロ、オブジェクトの名前を再利用してはならない" id="92" impl="CODSTA-92" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92.rule"/>
         </rule>
         <rule header="予約済み識別子及び標準ライブラリのマクロや関数は、定義または再定義または定義の解消をしてはならない (C90 コード)" id="92_a" impl="CODSTA-92_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_a.rule"/>
         </rule>
         <rule header="予約済み識別子及び標準ライブラリのマクロや関数は、定義または再定義または定義の解消をしてはならない (C99 コード)" id="92_b" impl="CODSTA-92_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_b.rule"/>
         </rule>
         <rule header="標準ライブラリの関数の名前をオーバーライドしてはならない" id="93" impl="CODSTA-93" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-93.rule"/>
         </rule>
         <rule header="ポインターまたは配列型を宣言してはならない" id="94" impl="CODSTA-94" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-94.rule"/>
         </rule>
         <rule header="ポインター型を宣言してはならない" id="95" impl="CODSTA-95" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-95.rule"/>
         </rule>
         <rule header="ビット フィールドは明示的な unsigned 汎整数型または列挙型でなければならない" id="96" impl="CODSTA-96" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-96.rule"/>
         </rule>
         <rule header="算術演算より優先順位の低い演算子が使用されている場合、括弧を使用して式の順序を明確にする" id="97" impl="CODSTA-97" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-97.rule"/>
         </rule>
         <rule header="すべての if...else 構文は、最後に else 句または最後の else 句が必要ではない理由を表すコメントを必要とする" id="98" impl="CODSTA-98" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-98.rule"/>
         </rule>
         <rule header="比較演算で符号ありの値と符号なしの値を混在させてはならない" id="99" impl="CODSTA-99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-99.rule"/>
         </rule>
         <category description="C++ コーディング規約" name="CPP">
            <rule header="stdio.h よりも iostream.h を使用する" id="01" impl="CODSTA-CPP-01" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-01.rule"/>
            </rule>
            <rule header="代入演算子に *this への参照を返させる。また代入演算子の戻り値の型を自身のクラス型への非 const 参照にする" id="02" impl="CODSTA-CPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-02.rule"/>
            </rule>
            <rule header="ビット演算子、比較演算子、論理演算子、カンマ演算子は const でなければならない" id="03" impl="CODSTA-CPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-03.rule"/>
            </rule>
            <rule header="変換を可能にするコンストラクタは  explicit にする" id="04" impl="CODSTA-CPP-04" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-04.rule"/>
            </rule>
            <rule header="ユーザ定義の変換関数を使用しない" id="05" impl="CODSTA-CPP-05" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-05.rule"/>
            </rule>
            <rule header="メンバー関数からクラス データへのハンドルを返却してはいけない" id="06" impl="CODSTA-CPP-06" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-06.rule"/>
            </rule>
            <rule header="インクリメントとデクリメントの後置形式は、前置形式を使用して実装しなければならない" id="07" impl="CODSTA-CPP-07" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-07.rule"/>
            </rule>
            <rule header="論理演算子 AND、OR (&amp;&amp;、||) をオーバーロードしてはいけない" id="08" impl="CODSTA-CPP-08" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
            </rule>
            <rule header="reinterpret_cast を使用しない" id="09" impl="CODSTA-CPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-09.rule"/>
            </rule>
            <rule header="メンバ関数を持った構造体を定義してはいけない" id="10" impl="CODSTA-CPP-10" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-10.rule"/>
            </rule>
            <rule header="パディング ビットを含む可能性があるクラスのオブジェクトを C の標準ライブラリ関数で比較してはならない" id="100" impl="CODSTA-CPP-100" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-100.rule"/>
            </rule>
            <rule header="関係演算子はブール値を返す必要がある" id="101" impl="CODSTA-CPP-101" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-101.rule"/>
            </rule>
            <rule header="2 項算術演算子およびビット演算子は 'prvalue' を返す必要がある" id="102" impl="CODSTA-CPP-102" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-102.rule"/>
            </rule>
            <rule header="出力パラメーターを使用してはならない" id="103" impl="CODSTA-CPP-103" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-103.rule"/>
            </rule>
            <rule header="typeid 演算子のオペランドに副作用を持つ式が含まれていてはならない" id="104" impl="CODSTA-CPP-104" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104.rule"/>
            </rule>
            <rule header="typeid 演算子のオペランドに副作用を発生させる関数の呼び出しが含まれていてはならない" id="104_b" impl="CODSTA-CPP-104_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104_b.rule"/>
            </rule>
            <rule header="特別なメンバーの動作がコンパイラの動作と同じである場合は、=default と定義する" id="105" impl="CODSTA-CPP-105" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-105.rule"/>
            </rule>
            <rule header="C++ スタイルのキャストを使用する" id="11" impl="CODSTA-CPP-11" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-11.rule"/>
            </rule>
            <rule header="基底クラスまたはメンバ変数として使用するクラスは別個のインクルードファイルに置く" id="12" impl="CODSTA-CPP-12" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-12.rule"/>
            </rule>
            <rule header="関数の戻り値の型として使用するクラスは別個のインクルードファイルに置く" id="13" impl="CODSTA-CPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-13.rule"/>
            </rule>
            <rule header="関数プロトタイプの引数の型として使用されるクラスは別個のインクルードファイルに置く" id="14" impl="CODSTA-CPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-14.rule"/>
            </rule>
            <rule header="インラインメンバ関数で使用される関数は別個のインクルードファイルに置く" id="15" impl="CODSTA-CPP-15" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-15.rule"/>
            </rule>
            <rule header="== と != など 2  つの演算子が反対の意味を持つ場合、両方を定義するのが適切である" id="16" impl="CODSTA-CPP-16" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-16.rule"/>
            </rule>
            <rule header="C++ では、struct キーワードを使って変数を宣言してはいけない" id="17" impl="CODSTA-CPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-17.rule"/>
            </rule>
            <rule header="クラスでグローバルな変数、定数、列挙型、型定義をカプセル化する" id="18" impl="CODSTA-CPP-18" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-18.rule"/>
            </rule>
            <rule header="コンストラクタを少なくとも 1 つ定義し、デフォルト コンストラクタが使用されることは避ける" id="19" impl="CODSTA-CPP-19" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-19.rule"/>
            </rule>
            <rule header="混合モードの演算子をサポートする場合、演算子を非メンバ関数にする" id="20" impl="CODSTA-CPP-20" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-20.rule"/>
            </rule>
            <rule header="代入演算子は const 参照を返さなければならない" id="21" impl="CODSTA-CPP-21" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-21.rule"/>
            </rule>
            <rule header="メンバ関数より、メンバでも friend でもない関数を使う" id="22" impl="CODSTA-CPP-22" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-22.rule"/>
            </rule>
            <rule header="グローバル関数を参照する場合は常に :: 演算子を使用する" id="23" impl="CODSTA-CPP-23" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-23.rule"/>
            </rule>
            <rule header="代入演算子を仮想にしない。また代入演算子から const T&amp; を返してはならない。" id="24" impl="CODSTA-CPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-24.rule"/>
            </rule>
            <rule header="仮想関数を public にしない。また public 関数を仮想関数にしない" id="25" impl="CODSTA-CPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-25.rule"/>
            </rule>
            <rule header="特に共同の作業が意図されていない限り、型と関数は別の名前空間に置く" id="26" impl="CODSTA-CPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-26.rule"/>
            </rule>
            <rule header="型および非メンバ関数インターフェイスを同じ名前空間に保持する" id="27" impl="CODSTA-CPP-27" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-27.rule"/>
            </rule>
            <rule header="二項算術演算子 (+、-、*、/、^、%、|、&amp;) を定義する場合は、代入形式も用意する" id="28" impl="CODSTA-CPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-28.rule"/>
            </rule>
            <rule header="算術演算子と代入演算子の標準形式を使用する" id="29" impl="CODSTA-CPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-29.rule"/>
            </rule>
            <rule header="混合モードの算術をサポートするには、メンバ演算子ではなくメンバでない演算子を使う" id="30" impl="CODSTA-CPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-30.rule"/>
            </rule>
            <rule header="明示的な (explicit) コンストラクタの使用は避ける" id="31" impl="CODSTA-CPP-31" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-31.rule"/>
            </rule>
            <rule header="テンプレートではないクラス定義でメンバ関数を定義してはいけない" id="32" impl="CODSTA-CPP-32" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-32.rule"/>
            </rule>
            <rule header="テンプレート クラス定義でメンバ関数を定義してはいけない" id="33" impl="CODSTA-CPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-33.rule"/>
            </rule>
            <rule header="ポインタの static_cast を使用しない" id="34" impl="CODSTA-CPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-34.rule"/>
            </rule>
            <rule header="動的キャストを使用しない" id="35" impl="CODSTA-CPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-35.rule"/>
            </rule>
            <rule header="グローバル名前空間は main() および名前空間の宣言だけを含むことができる" id="36" impl="CODSTA-CPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
            </rule>
            <rule header="関数定義の中でクラス/構造体/共用体を定義しない" id="37" impl="CODSTA-CPP-37" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-37.rule"/>
            </rule>
            <rule header="型変換演算子、-&gt; 演算子、() 演算子、[] 演算子 は const でなければならない" id="38" impl="CODSTA-CPP-38" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-38.rule"/>
            </rule>
            <rule header="名前空間 using をヘッダー ファイルまたは #include の前に記述しない" id="39" impl="CODSTA-CPP-39" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-39.rule"/>
            </rule>
            <rule header="クラス中のオブジェクト数の制限" id="40" impl="CODSTA-CPP-40" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-40.rule"/>
            </rule>
            <rule header="C++ では、変数宣言で enum キーワードを使ってはいけない" id="41" impl="CODSTA-CPP-41" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-41.rule"/>
            </rule>
            <rule header="mutable キーワードを使ってメンバ変数を宣言してはいけない" id="42" impl="CODSTA-CPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-42.rule"/>
            </rule>
            <rule header="できる限り参照パラメータを const 参照として宣言する" id="43" impl="CODSTA-CPP-43" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
            </rule>
            <rule header="const メンバ関数を複製する代わりに、非 const 関数から const 関数を呼び出す" id="44" impl="CODSTA-CPP-44" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-44.rule"/>
            </rule>
            <rule header="private セクションでは、次の順序でエンティティを宣言する: コンス トラクタ、デストラクタ、メンバ関数、メンバ変換関数、列挙、その他" id="45" impl="CODSTA-CPP-45" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-45.rule"/>
            </rule>
            <rule header="クラスでのスコープの順序: public を最初に置く" id="46" impl="CODSTA-CPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-46.rule"/>
            </rule>
            <rule header="クラスでのスコープの順序: protected を private の前に置く" id="47" impl="CODSTA-CPP-47" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-47.rule"/>
            </rule>
            <rule header="protected セクションでは、次の順序でエンティティを宣言する: コン ストラクタ、デストラクタ、メンバ関数、メンバ変換関数、列挙、その他" id="48" impl="CODSTA-CPP-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-48.rule"/>
            </rule>
            <rule header="public セクションでは、次の順序でエンティティを宣言する: コンスト ラクタ、デストラクタ、メンバ関数、メンバ変換関数、列挙、その他" id="49" impl="CODSTA-CPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-49.rule"/>
            </rule>
            <rule header="関数およびクラスの外部で static キーワードを使用してはならない" id="50" impl="CODSTA-CPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-50.rule"/>
            </rule>
            <rule header="ソース ファイルで inline キーワードを定義してはならない" id="51" impl="CODSTA-CPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-51.rule"/>
            </rule>
            <rule header="代入バージョンの演算子と単独バージョンの演算子の自然な関係を使用することを考慮する" id="52" impl="CODSTA-CPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-52.rule"/>
            </rule>
            <rule header="可能な場合は常にパラメータまたはローカル変数を const 宣言する" id="53" impl="CODSTA-CPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
            </rule>
            <rule header="可能な場合は常にメンバ関数を const 宣言する" id="54" impl="CODSTA-CPP-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-54.rule"/>
            </rule>
            <rule header="インターフェイスで配列を使用するべきではない" id="55" impl="CODSTA-CPP-55" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55.rule"/>
            </rule>
            <rule header="private および protected メソッドは配列型のパラメーターを宣言してはならない" id="55_b" impl="CODSTA-CPP-55_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55_b.rule"/>
            </rule>
            <rule header="クラス、構造体、列挙型を、型の定義の中で宣言してはならない" id="56" impl="CODSTA-CPP-56" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-56.rule"/>
            </rule>
            <rule header="名前空間を 2 階層より深くネストしてはならない" id="57" impl="CODSTA-CPP-57" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-57.rule"/>
            </rule>
            <rule header="オーバーロードされた演算子ではない関数から返された void 以外の戻り値は必ず使用する" id="58" impl="CODSTA-CPP-58" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-58.rule"/>
            </rule>
            <rule header="C ライブラリを使用してはならない" id="59" impl="CODSTA-CPP-59" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
            </rule>
            <rule header="ISO/IEC 14882:2003 で定義されたエスケープ シーケンスだけを使用する" id="60" impl="CODSTA-CPP-60" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-60.rule"/>
            </rule>
            <rule header="NULL を整数値として使用してはならない" id="62" impl="CODSTA-CPP-62" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-62.rule"/>
            </rule>
            <rule header="リテラルのゼロ (0) を null ポインター定数として使用してはならない" id="63" impl="CODSTA-CPP-63" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
            </rule>
            <rule header="if 文または反復文の条件ではブール型を使用する" id="64" impl="CODSTA-CPP-64" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-64.rule"/>
            </rule>
            <rule header="条件演算子の第一オペランドはブール型でなければならない" id="65" impl="CODSTA-CPP-65" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-65.rule"/>
            </rule>
            <rule header="void へのキャスト以外の C スタイルのキャストおよび明示的なコンストラクタ呼び出し以外の関数スタイルのキャストを使用してはならない" id="66" impl="CODSTA-CPP-66" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-66.rule"/>
            </rule>
            <rule header="! 演算子、論理演算子 &amp;&amp; または || のオペランドはブール型でなければならない" id="67" impl="CODSTA-CPP-67" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-67.rule"/>
            </rule>
            <rule header="単項演算子 &amp; をオーバーロードしてはならない" id="68" impl="CODSTA-CPP-68" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
            </rule>
            <rule header="for ループには 1 つの浮動小数点型ではないループ カウンタがなければならない" id="69" impl="CODSTA-CPP-69" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-69.rule"/>
            </rule>
            <rule header="ループ カウンタが -- または ++ で変更されていない場合、条件ではループ カウンタを &lt;=、&lt;、&gt; または &gt;= 演算子のオペランドとして使用する" id="70" impl="CODSTA-CPP-70" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-70.rule"/>
            </rule>
            <rule header="ループ カウンタは --、++、-=n、+=n のいずれかの方法で変更しなければならない。n はループの持続期間中は一定であるものとする" id="71" impl="CODSTA-CPP-71" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-71.rule"/>
            </rule>
            <rule header="ループ カウンタ以外のループ制御変数を条件式または更新式で変更してはならない" id="72" impl="CODSTA-CPP-72" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-72.rule"/>
            </rule>
            <rule header="文で変更されるループ カウンタ以外のループ制御変数はブール型でなければならない" id="73" impl="CODSTA-CPP-73" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-73.rule"/>
            </rule>
            <rule header="ヘッダー ファイルに無名の名前空間があってはならない" id="74" impl="CODSTA-CPP-74" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
            </rule>
            <rule header="using 指令を使用してはならない" id="75" impl="CODSTA-CPP-75" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-75.rule"/>
            </rule>
            <rule header="同じ名前空間にある 1 つの識別子の複数の宣言は using 宣言をまたいではならない" id="76" impl="CODSTA-CPP-76" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-76.rule"/>
            </rule>
            <rule header="const メンバー関数は const ではないクラス データへのポインターまたは参照を返してはならない" id="77" impl="CODSTA-CPP-77" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-77.rule"/>
            </rule>
            <rule header="メンバー関数を static にできる場合はそうする。その他の場合で const にできるときはそうする。" id="78" impl="CODSTA-CPP-78" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-78.rule"/>
            </rule>
            <rule header="等価演算子 (== または !=) のオペランドは、仮想メンバー関数へのポインターであってはならない" id="79" impl="CODSTA-CPP-79" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-79.rule"/>
            </rule>
            <rule header="カンマ演算子 &quot;,&quot; をオーバーロードしてはいけない" id="80" impl="CODSTA-CPP-80" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
            </rule>
            <rule header="ゲッター/セッター (アクセサー/ミューテーター) だけしかないクラスを作成してはならない" id="81" impl="CODSTA-CPP-81" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-81.rule"/>
            </rule>
            <rule header="カプセル化されていないグローバル変数 (名前空間で宣言された変数や public static メンバーを含む) を避ける" id="82" impl="CODSTA-CPP-82" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-82.rule"/>
            </rule>
            <rule header="ローカル スコープで宣言された識別子は、クラス スコープで宣言された識別子を隠ぺいしてはならない" id="83" impl="CODSTA-CPP-83" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-83.rule"/>
            </rule>
            <rule header="クラス スコープで宣言された識別子は、グローバルまたは名前空間のスコープで宣言された識別子を隠ぺいしてはならない" id="84" impl="CODSTA-CPP-84" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-84.rule"/>
            </rule>
            <rule header="内部クラスのスコープで宣言された識別子は、外側のクラスのスコープで宣言された識別子を隠ぺいしてはならない" id="85" impl="CODSTA-CPP-85" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-85.rule"/>
            </rule>
            <rule header="1 つのクラスに 2 つの正反対の等価演算子 ('==', '!=') を定義する場合、一方の観点から他方を定義する" id="86" impl="CODSTA-CPP-86" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-86.rule"/>
            </rule>
            <rule header="型を参照する識別子は、同じスコープにあるオブジェクトまたは関数を参照してはならない" id="87_a" impl="CODSTA-CPP-87_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_a.rule"/>
            </rule>
            <rule header="型を参照する識別子は、同じスコープにあるオブジェクトまたは関数を参照してはならない" id="87_b" impl="CODSTA-CPP-87_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_b.rule"/>
            </rule>
            <rule header="型を参照する識別子は、同じスコープにあるオブジェクトまたは関数を参照してはならない" id="87_c" impl="CODSTA-CPP-87_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_c.rule"/>
            </rule>
            <rule header="typedef の名前は、その基本型の名前と同じにするべきではない" id="88" impl="CODSTA-CPP-88" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-88.rule"/>
            </rule>
            <rule header="列挙型を bool 型に代入してはならない" id="89" impl="CODSTA-CPP-89" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-89.rule"/>
            </rule>
            <rule header="ヘッダー ファイルで using ディレクティブおよび using 宣言 (クラス スコープまたは関数スコープの using 宣言を除く) を使用してはならない" id="90" impl="CODSTA-CPP-90" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-90.rule"/>
            </rule>
            <rule header="オーバーロードされた二項演算子は対応する複合代入演算子を使って実装するべきである" id="91" impl="CODSTA-CPP-91" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-91.rule"/>
            </rule>
            <rule header="多重継承階層内のすべてのアクセス可能な名前は一意でなければならない" id="92" impl="CODSTA-CPP-92" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-92.rule"/>
            </rule>
            <rule header="C の標準ライブラリ関数を使用してノントリビアル クラス型のオブジェクトを初期化してはならない" id="93" impl="CODSTA-CPP-93" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-93.rule"/>
            </rule>
            <rule header="C の標準ライブラリ関数を使用して非標準レイアウト クラス型のオブジェクトを比較してはならない" id="94" impl="CODSTA-CPP-94" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-94.rule"/>
            </rule>
            <rule header="標準の名前空間 std および posix を変更してはならない" id="95" impl="CODSTA-CPP-95" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-95.rule"/>
            </rule>
            <rule header="別の言語リンケージで関数を呼び出さない" id="96" impl="CODSTA-CPP-96" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-96.rule"/>
            </rule>
            <rule header="参照型を const または volatile で修飾してはならない" id="97" impl="CODSTA-CPP-97" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-97.rule"/>
            </rule>
            <rule header="コピー演算はソース オブジェクトを変更してはならない" id="98" impl="CODSTA-CPP-98" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-98.rule"/>
            </rule>
            <rule header="offsetof() は有効な型およびメンバーに対して使用する" id="99" impl="CODSTA-CPP-99" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-99.rule"/>
            </rule>
         </category>
         <category description="Modern C++ コーディング規約" name="MCPP">
            <rule header="ユーザー定義の変換を行うキャスト演算子は explicit にするべきである" id="01" impl="CODSTA-MCPP-01" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-01.rule"/>
            </rule>
            <rule header="typedef ではなくエイリアス宣言を使用する" id="02" impl="CODSTA-MCPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-02.rule"/>
            </rule>
            <rule header="スコープなしの列挙型ではなく、スコープ付きの列挙型を使用する" id="03" impl="CODSTA-MCPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-03.rule"/>
            </rule>
            <rule header="NULL または 0 (ゼロ) ではなく nullptr を使用する" id="04" impl="CODSTA-MCPP-04" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-04.rule"/>
            </rule>
            <rule header="オーバーライド関数に override を指定して宣言する" id="05" impl="CODSTA-MCPP-05" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-05.rule"/>
            </rule>
            <rule header="クラスのコピーを防ぐため、コピー コンストラクターおよびコピー代入演算子に delete を指定して宣言する" id="06_a" impl="CODSTA-MCPP-06_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_a.rule"/>
            </rule>
            <rule header="クラスのコピーを防ぐため、private メソッドを持つ基底クラスを使用するのではなく、コピー コンストラクターおよびコピー代入演算子に delete を指定して宣言する" id="06_b" impl="CODSTA-MCPP-06_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_b.rule"/>
            </rule>
            <rule header="std::bind、std::bind1st および std::bind2nd ではなくラムダを使用する" id="07" impl="CODSTA-MCPP-07" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07.rule"/>
            </rule>
            <rule header="'binder1st' および 'binder2nd' 識別子を使用するべきではない" id="07_b" impl="CODSTA-MCPP-07_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07_b.rule"/>
            </rule>
            <rule header="変数の宣言では、明示的な型名ではなく auto を使用する" id="08_a" impl="CODSTA-MCPP-08_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_a.rule"/>
            </rule>
            <rule header="関数の戻り値の型では、明示的な型名ではなく auto を使用する" id="08_b" impl="CODSTA-MCPP-08_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_b.rule"/>
            </rule>
            <rule header="例外を発生させない関数は noexcept 宣言する" id="09" impl="CODSTA-MCPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-09.rule"/>
            </rule>
            <rule header="iterator ではなく const iterator を使用する" id="10_a" impl="CODSTA-MCPP-10_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_a.rule"/>
            </rule>
            <rule header="cbegin()、crbegin()、cend()、crend() 関数を優先的に使用する" id="10_b" impl="CODSTA-MCPP-10_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_b.rule"/>
            </rule>
            <rule header="できるだけ constexpr を使用して定数変数を宣言する" id="11_a_cpp11" impl="CODSTA-MCPP-11_a_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_a_cpp11.rule"/>
            </rule>
            <rule header="できるだけ constexpr を使用して関数を宣言する" id="11_b_cpp11" impl="CODSTA-MCPP-11_b_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_b_cpp11.rule"/>
            </rule>
            <rule header="右辺値参照には std::move() を使用し、ユニバーサル参照には std::forward() を使用する" id="13" impl="CODSTA-MCPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13.rule"/>
            </rule>
            <rule header="ユニバーサル参照を転送する場合、std::forward 関数を使用する" id="13_b" impl="CODSTA-MCPP-13_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13_b.rule"/>
            </rule>
            <rule header="前方参照でのオーバーロードを避ける" id="14" impl="CODSTA-MCPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-14.rule"/>
            </rule>
            <rule header="デフォルトのキャプチャ モードを避ける" id="15_a" impl="CODSTA-MCPP-15_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_a.rule"/>
            </rule>
            <rule header="デフォルトの by-reference キャプチャを使用するラムダでは、明示的に 'this' ポインターを使用する" id="15_b" impl="CODSTA-MCPP-15_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_b.rule"/>
            </rule>
            <rule header="なるべく raw ポインター メンバーではなくスマート ポインター メンバーを使用する" id="16_a" impl="CODSTA-MCPP-16_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_a.rule"/>
            </rule>
            <rule header="配列または STL コンテナーでは、なるべく raw ポインター メンバーではなくスマート ポインター メンバーを使用する" id="16_b" impl="CODSTA-MCPP-16_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_b.rule"/>
            </rule>
            <rule header="new を直接使用するのではなく、できるだけ 'std::make_shared' を使用する" id="16_c" impl="CODSTA-MCPP-16_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_c.rule"/>
            </rule>
            <rule header="std::auto_ptr ではなく、できるだけ std::unique_ptr を使用する" id="16_d" impl="CODSTA-MCPP-16_d" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_d.rule"/>
            </rule>
            <rule header="'std::unique_ptr' によって所有されるオブジェクトの構築には 'std::make_unique' を使用する" id="16_e" impl="CODSTA-MCPP-16_e" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_e.rule"/>
            </rule>
            <rule header="ローカル オブジェクトを参照でキャプチャするラムダを返してはならない" id="17" impl="CODSTA-MCPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17.rule"/>
            </rule>
            <rule header="外側のラムダから参照によってローカル オブジェクトをキャプチャしてはならない" id="17_b" impl="CODSTA-MCPP-17_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_b.rule"/>
            </rule>
            <rule header="ローカル オブジェクトを参照によってキャプチャするラムダは、より長い存続期間を持つ変数に代入するべきではない" id="17_c" impl="CODSTA-MCPP-17_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_c.rule"/>
            </rule>
            <rule header="ラムダ式では不要なデフォルト キャプチャ モードを避ける" id="18_a" impl="CODSTA-MCPP-18_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_a.rule"/>
            </rule>
            <rule header="不要なラムダ キャプチャを避ける" id="18_b" impl="CODSTA-MCPP-18_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_b.rule"/>
            </rule>
            <rule header="参照修飾子 &amp; を付けて代入演算子を宣言する" id="19" impl="CODSTA-MCPP-19" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-19.rule"/>
            </rule>
            <rule header="できるだけ raw ローカル ポインターではなくスマート ポインターを使用する" id="20" impl="CODSTA-MCPP-20" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-20.rule"/>
            </rule>
            <rule header="mutex に対して直接 lock() を呼び出さない" id="21" impl="CODSTA-MCPP-21" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-21.rule"/>
            </rule>
            <rule header="範囲ベースの for ループでは auto 宣言に対して明示的な参照修飾子を使用する" id="22" impl="CODSTA-MCPP-22" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-22.rule"/>
            </rule>
            <rule header="クラスの public なデストラクターが非 virtual である場合、クラスを final 宣言するべきである" id="23" impl="CODSTA-MCPP-23" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-23.rule"/>
            </rule>
            <rule header="メンバー関数の宣言では virtual、override、final のいずれか 1 つだけを指定するべきである" id="24" impl="CODSTA-MCPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-24.rule"/>
            </rule>
            <rule header="桁区切り ' は一貫性をもって使用する" id="25" impl="CODSTA-MCPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-25.rule"/>
            </rule>
            <rule header="メンバー仮想関数を指すポインターは、null ポインター定数と等価かどうかだけをテストするべきである" id="26" impl="CODSTA-MCPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-26.rule"/>
            </rule>
            <rule header="ユーザー定義型のすべての std::hash 特殊化は、noexcept 関数呼び出し演算子を持つ必要がある" id="27" impl="CODSTA-MCPP-27" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-27.rule"/>
            </rule>
            <rule header="ラムダを typeid のオペランドにしてはならない" id="28" impl="CODSTA-MCPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-28.rule"/>
            </rule>
            <rule header="スレッドにオブジェクトへのポインターを渡す場合はスマート ポインターを使用する" id="29" impl="CODSTA-MCPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-29.rule"/>
            </rule>
            <rule header="ローカル オブジェクトに対して 'std::shared_ptr' ではなく 'std::unique_ptr' を使用することを検討する" id="30" impl="CODSTA-MCPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-30.rule"/>
            </rule>
            <rule header="サイズ指定付きとサイズ指定なしの両方のバージョンの delete 演算子を定義する" id="31" impl="CODSTA-MCPP-31" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-31.rule"/>
            </rule>
            <rule header="静的およびスレッドローカルなオブジェクトは定数初期化される必要がある" id="32" impl="CODSTA-MCPP-32" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-32.rule"/>
            </rule>
            <rule header="ユーザー定義のリテラル演算子は、渡されたパラメーターの変換だけを行う必要がある" id="33" impl="CODSTA-MCPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-33.rule"/>
            </rule>
            <rule header="生存期間を表現する場合にだけパラメーター型としてスマートポインターを使用する" id="34" impl="CODSTA-MCPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-34.rule"/>
            </rule>
            <rule header="パラメーターは、管理対象オブジェクトを関数が置き換える場合にだけ  'std::shared_ptr' または 'std::unique_ptr' への非 const lvalue 参照として宣言するべきである" id="35" impl="CODSTA-MCPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-35.rule"/>
            </rule>
            <rule header="パラメーターの型を 'std::shared_ptr' または 'std::unique_ptr' への rvalue 参照として宣言しない" id="36" impl="CODSTA-MCPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-36.rule"/>
            </rule>
            <rule header="追加の明示的な初期化を必要とせず、基底クラスのすべてのコンストラクターを必要とする派生クラスは、継承コンストラクターを使用する必要がある" id="37" impl="CODSTA-MCPP-37" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-37.rule"/>
            </rule>
            <rule header="変数の初期化には、等号なしの {} 括弧による初期化を使用する必要がある" id="38" impl="CODSTA-MCPP-38" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-38.rule"/>
            </rule>
            <rule header="auto 型の変数は、 {} または ={} を使用した括弧による初期化で初期化してはならない" id="39" impl="CODSTA-MCPP-39" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-39.rule"/>
            </rule>
            <rule header="'auto' 指定子を過度に使用しない" id="40" impl="CODSTA-MCPP-40" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-40.rule"/>
            </rule>
            <rule header="'random_shuffle' 識別子を使用するべきではない" id="41" impl="CODSTA-MCPP-41" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-41.rule"/>
            </rule>
            <rule header="bool 型のオペランドにインクリメント演算子 (++) を使用しない" id="42" impl="CODSTA-MCPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-42.rule"/>
            </rule>
            <rule header="'set_unexpected' 識別子を使用するべきではない" id="43" impl="CODSTA-MCPP-43" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-43.rule"/>
            </rule>
            <rule header="ラムダ式の中に別のラムダ式を定義するべきではない" id="44" impl="CODSTA-MCPP-44" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-44.rule"/>
            </rule>
            <rule header="void 型以外のラムダ式の戻り値型は明示的に指定するべきである" id="45" impl="CODSTA-MCPP-45" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-45.rule"/>
            </rule>
            <rule header="すべてのラムダ式にパラメーター リストを含める" id="46" impl="CODSTA-MCPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-46.rule"/>
            </rule>
            <rule header="std::initializer_list でコンストラクターをオーバーロードしない" id="47" impl="CODSTA-MCPP-47" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-47.rule"/>
            </rule>
            <rule header="関数の複数の出力値は構造体またはタプルとして返すべきである" id="48" impl="CODSTA-MCPP-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-48.rule"/>
            </rule>
            <rule header="ユーザー定義のコピー代入演算子およびムーブ代入演算子は、ユーザー定義の例外をスローしないスワップ関数を使用するべきである" id="49" impl="CODSTA-MCPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-49.rule"/>
            </rule>
            <rule header="コンテナーのすべての要素をループし、ループ カウンターを使用していない for ループを使用してはならない" id="50" impl="CODSTA-MCPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-50.rule"/>
            </rule>
            <rule header="結果がただちに const iterator に変換される場合、const コンテナーの呼び出しを使用する" id="51" impl="CODSTA-MCPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-51.rule"/>
            </rule>
            <rule header="final クラスに仮想関数を導入しない" id="52" impl="CODSTA-MCPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-52.rule"/>
            </rule>
         </category>
      </category>
      <category description="コメント" name="COMMENT">
         <rule header="C++ スタイルのコメントを使用する" id="01" impl="COMMENT-01" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-01.rule"/>
         </rule>
         <rule header="著作権情報を提供する" id="02" impl="COMMENT-02" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-02.rule"/>
         </rule>
         <rule header="すべてのソース ファイルは、ファイルの先頭にファイル情報を記載して文書化する" id="03" impl="COMMENT-03" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-03.rule"/>
         </rule>
         <rule header="関数定義の前のコメントで関数を文書化する" id="04" impl="COMMENT-04" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-04.rule"/>
         </rule>
         <rule header="関数宣言の前のコメントで関数を文書化する" id="04_b" impl="COMMENT-04_b" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-04_b.rule"/>
         </rule>
         <rule header="変数宣言にコメントを付ける" id="05" impl="COMMENT-05" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-05.rule"/>
         </rule>
         <rule header="typedef にコメントを付ける" id="06" impl="COMMENT-06" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-06.rule"/>
         </rule>
         <rule header="列挙値にコメントを付ける" id="07" impl="COMMENT-07" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-07.rule"/>
         </rule>
         <rule header="構造体メンバ変数にコメントを付ける" id="08" impl="COMMENT-08" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-08.rule"/>
         </rule>
         <rule header="アセンブラの使用をすべて文書化する" id="09" impl="COMMENT-09" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-09.rule"/>
         </rule>
         <rule header="浮動小数点型の算術を文書化する" id="10" impl="COMMENT-10" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-10.rule"/>
         </rule>
         <rule header="文字シーケンス  // を C スタイル コメントの中で使用してはいけない" id="11" impl="COMMENT-11" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-11.rule"/>
         </rule>
         <rule header="文字シーケンス  /* を C++ スタイル コメントの中で使用してはいけない" id="12" impl="COMMENT-12" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-12.rule"/>
         </rule>
         <rule header="// コメントで行の結合を使用してはならない" id="13" impl="COMMENT-13" quickfix="false" scope="line" severity="2">
            <file path="COMMENT\COMMENT-13.rule"/>
         </rule>
         <rule header="すべての型、データ メンバー、関数の宣言の前に '@brief' タグでアノテートされたコメントを付けるべきである" id="14" impl="COMMENT-14" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-14.rule"/>
         </rule>
         <rule header="関数宣言の前のコメントで関数のパラメーターおよび戻り値の型を文書化するべきである" id="14_b" impl="COMMENT-14_b" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-14_b.rule"/>
         </rule>
      </category>
      <category description="例外" name="EXCEPT">
         <rule header="デストラクタ、割り当て解除、スワップから例外をスローしてはならない" id="01" impl="EXCEPT-01" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-01.rule"/>
         </rule>
         <rule header="値でスローし、参照でキャッチする" id="02" impl="EXCEPT-02" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-02.rule"/>
         </rule>
         <rule header="デストラクタの中から throw を行ってはいけない" id="03" impl="EXCEPT-03" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-03.rule"/>
         </rule>
         <rule header="すべての例外は、再スローされるか標準ロガーでログに記録されるべきである" id="04" impl="EXCEPT-04" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-04.rule"/>
         </rule>
         <rule header="C++ の例外 (throw、catch、try) を使用してはならない" id="05" impl="EXCEPT-05" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-05.rule"/>
         </rule>
         <rule header="他では処理されていないすべての例外をキャッチする例外ハンドラを少なくとも 1 つ用意するべきである" id="06" impl="EXCEPT-06" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-06.rule"/>
         </rule>
         <rule header="空のスロー (throw;) は catch ハンドラの複合文でだけ使用する" id="07" impl="EXCEPT-07" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-07.rule"/>
         </rule>
         <rule header="プログラムの起動フェーズの後、終了フェーズの前にだけ例外をスローする" id="08" impl="EXCEPT-08" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-08.rule"/>
         </rule>
         <rule header="例外オブジェクトはポインタ型にするべきではない" id="09" impl="EXCEPT-09" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-09.rule"/>
         </rule>
         <rule header="goto または switch 文で try または catch ブロックに制御を移してはならない" id="10" impl="EXCEPT-10" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-10.rule"/>
         </rule>
         <rule header="throw 文の代入式は例外がスローされる原因になってはならない" id="11" impl="EXCEPT-11" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-11.rule"/>
         </rule>
         <rule header="NULL を明示的にスローしてはならない" id="12" impl="EXCEPT-12" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-12.rule"/>
         </rule>
         <rule header="明示的にスローされる例外はその場所に至るすべての呼び出しパスに互換性のある型のハンドラがなければならない" id="13" impl="EXCEPT-13" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-13.rule"/>
         </rule>
         <rule header="関数の宣言に例外指定がある場合、関数は指定された型の例外だけをスローできる" id="14" impl="EXCEPT-14" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-14.rule"/>
         </rule>
         <rule header="クラス型の例外は常に参照でキャッチする" id="15" impl="EXCEPT-15" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-15.rule"/>
         </rule>
         <rule header="コンストラクタまたはデストラクタの関数監視ブロックのハンドラは、そのクラスまたは基底クラスの静的でないメンバを参照してはならない" id="16" impl="EXCEPT-16" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-16.rule"/>
         </rule>
         <rule header="1 つの try-catch 文または関数監視ブロックに派生クラスおよびそのすべてまたは一部の基底クラスのハンドラがある場合、最後に派生されたクラスから基底クラスへの順でハンドラを記述する" id="17" impl="EXCEPT-17" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-17.rule"/>
         </rule>
         <rule header="グローバルまたは名前空間のスコープで呼び出される関数は、処理されない例外をスローしてはならない" id="18" impl="EXCEPT-18" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-18.rule"/>
         </rule>
         <rule header="例外オブジェクトは例外をスローせずにコピー作成可能でなければならない" id="19" impl="EXCEPT-19" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-19.rule"/>
         </rule>
         <rule header="'std::exception' を継承するクラスに明示的に宣言されたコピー コンストラクターは、例外をスローしない仕様を持たなければならない" id="20" impl="EXCEPT-20" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-20.rule"/>
         </rule>
         <rule header="すべてのユーザー定義のムーブ コンストラクターおよびムーブ代入演算子は、例外で終了してはならない" id="21" impl="EXCEPT-21" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-21.rule"/>
         </rule>
         <rule header="関数からスローされる可能性があるチェック例外は、関数宣言の直前のコメントで指定する必要がある" id="22" impl="EXCEPT-22" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-22.rule"/>
         </rule>
         <rule header="throw 例外仕様を使用しない" id="23" impl="EXCEPT-23" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-23.rule"/>
         </rule>
         <rule header="1 つの try-catch 文または function-try-block に複数のハンドラーがある場合、省略記法  (catch-all) ハンドラーは最後に置く" id="24" impl="EXCEPT-24" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-24.rule"/>
         </rule>
         <rule header="catch ブロックを空のままにしない" id="25" impl="EXCEPT-25" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-25.rule"/>
         </rule>
         <rule header="catch-all 例外ハンドラーを使用しない" id="26" impl="EXCEPT-26" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-26.rule"/>
         </rule>
      </category>
      <category description="書式" name="FORMAT">
         <rule header="ASCII スペースを使用しないタブを使ってはいけない" id="01" impl="FORMAT-01" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-01.rule"/>
         </rule>
         <rule header="開き中括弧 { を独立した行に置く" id="02" impl="FORMAT-02" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-02.rule"/>
         </rule>
         <rule header="閉じ中括弧 } を独立した行に置く" id="03" impl="FORMAT-03" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-03.rule"/>
         </rule>
         <rule header="物理的な 1 行の文字数は 80 字未満にすべきである" id="04" impl="FORMAT-04" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-04.rule"/>
         </rule>
         <rule header="マクロの長さは 10 行を超えてはいけない" id="05" impl="FORMAT-05" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-05.rule"/>
         </rule>
         <rule header="1 つの行には 1 つの命令だけを記述するべきである" id="06" impl="FORMAT-06" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-06.rule"/>
         </rule>
         <rule header="代入演算子の前には、ASCII スペースを 1 個入れなければならない" id="07" impl="FORMAT-07" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-07.rule"/>
         </rule>
         <rule header="代入演算子の後には、ASCII スペースを 1 個入れなければならない" id="08" impl="FORMAT-08" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-08.rule"/>
         </rule>
         <rule header="ビット演算子の前には、ASCII スペースを 1 個入れなければならない" id="09" impl="FORMAT-09" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-09.rule"/>
         </rule>
         <rule header="ビット演算子の後には、ASCII スペースを 1 個入れなければならない" id="10" impl="FORMAT-10" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-10.rule"/>
         </rule>
         <rule header="ビット演算子 &amp; の前後には、ASCII 空白文字を 1 個入れなければならない" id="11" impl="FORMAT-11" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-11.rule"/>
         </rule>
         <rule header="条件文キーワードと開始括弧の間には、ASCII スペースを 1 個入れなければならない" id="12" impl="FORMAT-12" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-12.rule"/>
         </rule>
         <rule header="条件文の開始括弧の後には、最大で 1 個の ASCII スペースを入れなければならない" id="13" impl="FORMAT-13" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-13.rule"/>
         </rule>
         <rule header="三項条件演算子の前には、ASCII スペースを 1 個入れなければならない" id="14" impl="FORMAT-14" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-14.rule"/>
         </rule>
         <rule header="三項条件演算子の後には、ASCII スペースを 1 個入れなければならない" id="15" impl="FORMAT-15" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-15.rule"/>
         </rule>
         <rule header="比較演算子および等価演算子の前後には、ASCII スペースを 1 個入れなければならない" id="16" impl="FORMAT-16" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-16.rule"/>
         </rule>
         <rule header="'.' または '-&gt;' 演算子の後にスペースを入れてはいけない" id="17" impl="FORMAT-17" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-17.rule"/>
         </rule>
         <rule header="'.' または '-&gt;' 演算子の前にスペースを入れてはいけない" id="18" impl="FORMAT-18" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-18.rule"/>
         </rule>
         <rule header="カンマの後には、ASCII スペースを 1 個入れなければならない" id="19" impl="FORMAT-19" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-19.rule"/>
         </rule>
         <rule header="セミコロンの後には、ASCII スペースを 1 個入れなければならない" id="20" impl="FORMAT-20" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-20.rule"/>
         </rule>
         <rule header="前置単項演算子 &quot;!&quot; または &quot;~&quot; とそのオペランドの間にスペースを入れてはいけない" id="21" impl="FORMAT-21" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-21.rule"/>
         </rule>
         <rule header="インクリメント/デクリメント演算子 (++/--) とそのオペランドの間にスペースを入れてはいけない" id="22" impl="FORMAT-22" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-22.rule"/>
         </rule>
         <rule header="return 文または sizeof 演算子と開始括弧の間にスペースを入れては いけない" id="23" impl="FORMAT-23" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-23.rule"/>
         </rule>
         <rule header="return 文または sizeof 演算子の引数または式の前後にスペースを入れてはいけない" id="24" impl="FORMAT-24" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-24.rule"/>
         </rule>
         <rule header="sizeof 文では、() を使わなければならない" id="25" impl="FORMAT-25" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25.rule"/>
         </rule>
         <rule header="return 文では、() を使わなければならない" id="25_b" impl="FORMAT-25_b" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25_b.rule"/>
         </rule>
         <rule header="論理演算子の前後には、ASCII スペースを 1 個入れなければならない" id="26" impl="FORMAT-26" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-26.rule"/>
         </rule>
         <rule header="4 の倍数のスペースで行をインデントする" id="27" impl="FORMAT-27" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-27.rule"/>
         </rule>
         <rule header="関数の定義では、関数の戻り型を関数名のすぐ上の行にインデントを合わせて置く" id="28" impl="FORMAT-28" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-28.rule"/>
         </rule>
         <rule header="複数の変数を同じ文で宣言してはならない" id="29" impl="FORMAT-29" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-29.rule"/>
         </rule>
         <rule header="関数名と括弧の間にスペースを入れない" id="30" impl="FORMAT-30" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-30.rule"/>
         </rule>
         <rule header="条件式では論理式を分ける" id="31" impl="FORMAT-31" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-31.rule"/>
         </rule>
         <rule header="間接参照演算子 * およびアドレス演算子 &amp; は、型に直接付ける" id="32" impl="FORMAT-32" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-32.rule"/>
         </rule>
         <rule header="各変数は、別個の宣言文で宣言しなければならない" id="33" impl="FORMAT-33" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-33.rule"/>
         </rule>
         <rule header="ブロックを囲む中括弧 {} は、カラムを合わせる" id="34" impl="FORMAT-34" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-34.rule"/>
         </rule>
         <rule header="関数を宣言する際、先頭の括弧と最初の引数は関数名と同じ行に記述する" id="35" impl="FORMAT-35" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-35.rule"/>
         </rule>
         <rule header="兄弟の関係にある文の行のインデントは同じでなければならない" id="36" impl="FORMAT-36" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-36.rule"/>
         </rule>
         <rule header="制御文の本体の最初の行は、制御文のキーワードよりインデントを下げなければならない" id="37" impl="FORMAT-37" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-37.rule"/>
         </rule>
         <rule header="3 つ以上のパラメータを持つ関数を宣言する場合、先頭の括弧と最初の引数を関数名と同じ行に置き、残りの各引数を個別の行に置く" id="38" impl="FORMAT-38" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-38.rule"/>
         </rule>
         <rule header="#include ディレクティブをアルファベット順にソートする" id="39" impl="FORMAT-39" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-39.rule"/>
         </rule>
         <rule header="開き角括弧 '[' の後と閉じ角括弧 ']' の前の空白の有無は一致していなければならない" id="40" impl="FORMAT-40" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-40.rule"/>
         </rule>
         <rule header="開き角括弧 '[' と直前のトークンの間に空白があってはいけない" id="41" impl="FORMAT-41" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-41.rule"/>
         </rule>
         <rule header="ブロックを囲む括弧 (&quot;{}&quot;) の行には、コメント以外があってはならない" id="42" impl="FORMAT-42" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-42.rule"/>
         </rule>
         <rule header="ブロックを囲む括弧 (&quot;{}&quot;) は同じカラムに置かれなければならない" id="43" impl="FORMAT-43" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-43.rule"/>
         </rule>
         <rule header="ブロックを囲む括弧 (&quot;{}&quot;) は、&quot;{&quot; の後ろにも &quot;}&quot; の前にも空白行があってはならない" id="44" impl="FORMAT-44" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-44.rule"/>
         </rule>
         <rule header="単項演算子 &quot;&amp;&quot;、&quot;*&quot;、&quot;+&quot;、&quot;-&quot; とそのオペランドの間にスペースがあってはならない" id="45" impl="FORMAT-45" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-45.rule"/>
         </rule>
         <rule header="マクロ定義で、インクリメント/デクリメント演算子 (++/--) とそのオペランドの間にスペースを入れてはいけない" id="46" impl="FORMAT-46" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-46.rule"/>
         </rule>
         <rule header="CV 修飾子は、修飾される型の右側に置く" id="47_a" impl="FORMAT-47_a" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-47_a.rule"/>
         </rule>
         <rule header="CV 修飾子は、typedef または using 名である型の右側に置く" id="47_b" impl="FORMAT-47_b" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-47_b.rule"/>
         </rule>
      </category>
      <category description="High Integrity C++" name="HICPP">
         <category name="12_4_3">
            <rule header="同じ非静的なメンバーのコンストラクターで NSDMI およびメンバー初期化子の両方を指定しない" id="a" impl="HICPP-12_4_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_4_3-a.rule"/>
            </rule>
         </category>
         <category name="12_4_5">
            <rule header="コンストラクターのデリゲートを使用してコードの重複を減らす" id="a" impl="HICPP-12_4_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_4_5-a.rule"/>
            </rule>
         </category>
         <category name="12_5_1">
            <rule header="具象クラスでは、コンパイラによって暗黙的に提供される特別なメンバー関数を明示的に =default もしくは =delete で定義する" id="a" impl="HICPP-12_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_5_1-a.rule"/>
            </rule>
         </category>
         <category name="13_2_3">
            <rule header="二項算術演算子およびビット演算子を非メンバーとして宣言する" id="a" impl="HICPP-13_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_3-a.rule"/>
            </rule>
         </category>
         <category name="13_2_4">
            <rule header="添え字演算子 (operator[]) をオーバーロードする際は、const および非 const の両方のバージョンを実装する" id="a" impl="HICPP-13_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_4-a.rule"/>
            </rule>
         </category>
         <category name="15_1_1">
            <rule header="std::exception のインスタンスだけを例外として使用する" id="a" impl="HICPP-15_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-15_1_1-a.rule"/>
            </rule>
         </category>
         <category name="16_1_4">
            <rule header="システム ライブラリおよび標準ライブラリのヘッダーには &lt;&gt; 括弧を使用する。他のヘッダーには引用符を使用する" id="a" impl="HICPP-16_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-16_1_4-a.rule"/>
            </rule>
         </category>
         <category name="17_2_1">
            <rule header="C 標準ライブラリの使用をラップする" id="a" impl="HICPP-17_2_1-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-17_2_1-a.rule"/>
            </rule>
         </category>
         <category name="17_3_1">
            <rule header="const または const &amp; 型を指定して宣言されたオブジェクトに対して std::move を使用しない" id="a" impl="HICPP-17_3_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_1-a.rule"/>
            </rule>
         </category>
         <category name="17_3_4">
            <rule header="配列型のスマート ポインターを作成しない" id="a" impl="HICPP-17_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_4-a.rule"/>
            </rule>
         </category>
         <category name="17_3_5">
            <rule header="std::array の rvalue 参照を作成しない" id="a" impl="HICPP-17_3_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_5-a.rule"/>
            </rule>
            <rule header="std::array の rvalue 参照を作成しない" id="b" impl="HICPP-17_3_5-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_5-b.rule"/>
            </rule>
         </category>
         <category name="18_1_1">
            <rule header="プラットフォーム固有のマルチスレッド機能を使用しない" id="a" impl="HICPP-18_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_1_1-a.rule"/>
            </rule>
         </category>
         <category name="18_2_1">
            <rule header="std::thread の代わりに high_integrity::thread を使用する" id="a" impl="HICPP-18_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_1-a.rule"/>
            </rule>
         </category>
         <category name="18_2_3">
            <rule header="複数のスレッドで volatile データを共有しない" id="a" impl="HICPP-18_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_3-a.rule"/>
            </rule>
         </category>
         <category name="18_2_4">
            <rule header="Double-Checked Locking ではなく std::call_once を使用する" id="a" impl="HICPP-18_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_4-a.rule"/>
            </rule>
         </category>
         <category name="18_3_3">
            <rule header="std::recursive mutex を使用しない" id="a" impl="HICPP-18_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_3-a.rule"/>
            </rule>
         </category>
         <category name="18_3_4">
            <rule header="std::lock_guard が使用できない場合にだけ std::unique_lock を使用する" id="a" impl="HICPP-18_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_4-a.rule"/>
            </rule>
         </category>
         <category name="18_3_5">
            <rule header="std::mutex のメンバーを直接的に使用しない" id="a" impl="HICPP-18_3_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_5-a.rule"/>
            </rule>
         </category>
         <category name="18_3_6">
            <rule header="緩いアトミックを使用しない" id="a" impl="HICPP-18_3_6-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_6-a.rule"/>
            </rule>
         </category>
         <category name="18_4_1">
            <rule header="std::mutex で std::condition_variable_any を使用しない" id="a" impl="HICPP-18_4_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_4_1-a.rule"/>
            </rule>
         </category>
         <category name="1_3_4">
            <rule header="非推奨の STL ライブラリ機能を使用しない" id="a" impl="HICPP-1_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-1_3_4-a.rule"/>
            </rule>
         </category>
         <category name="2_3_2">
            <rule header="コメントを使用してコードの一部を削除しない" id="a" impl="HICPP-2_3_2-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-2_3_2-a.rule"/>
            </rule>
         </category>
         <category name="3_3_1">
            <rule header="静的記憶域期間を持つ変数を使用しない" id="a" impl="HICPP-3_3_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-3_3_1-a.rule"/>
            </rule>
         </category>
         <category name="4_2_1">
            <rule header="符号なしの汎整数式が要求されるコンテキストでリテラルを使用する場合、必ず接尾辞 U を適用する" id="a" impl="HICPP-4_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-4_2_1-a.rule"/>
            </rule>
         </category>
         <category name="5_1_4">
            <rule header="ラムダで変数を暗黙的にキャプチャしない" id="a" impl="HICPP-5_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_1_4-a.rule"/>
            </rule>
         </category>
         <category name="5_4_2">
            <rule header="式を列挙型にキャストしない" id="a" impl="HICPP-5_4_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_4_2-a.rule"/>
            </rule>
         </category>
         <category name="5_8_1">
            <rule header="条件演算子 (?:) を部分式として使用しない" id="a" impl="HICPP-5_8_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_8_1-a.rule"/>
            </rule>
         </category>
         <category name="7_1_10">
            <rule header="コンパイル時定数を含むアサーションには static_assert を使用する" id="a" impl="HICPP-7_1_10-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_10-a.rule"/>
            </rule>
         </category>
         <category name="7_1_3">
            <rule header="宣言では、型指定子をそれ以外の指定子の前に置かない" id="a" impl="HICPP-7_1_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_3-a.rule"/>
            </rule>
         </category>
         <category name="7_1_5">
            <rule header="大きい関数をインライン化しない" id="a" impl="HICPP-7_1_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_5-a.rule"/>
            </rule>
         </category>
         <category name="7_1_6">
            <rule header="抽象スカラ量および標準整数型にはクラス型または typedef を使用する" id="b" impl="HICPP-7_1_6-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-b.rule"/>
            </rule>
            <rule header="抽象スカラ量および標準整数型にはクラス型または typedef を使用する" id="c" impl="HICPP-7_1_6-c" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-c.rule"/>
            </rule>
         </category>
         <category name="7_1_8">
            <rule header="初期化関数の呼び出しと同じ型を持つ変数を宣言するには、auto id = expr を使用する" id="a" impl="HICPP-7_1_8-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_8-a.rule"/>
            </rule>
         </category>
         <category name="7_1_9">
            <rule header="ラムダの戻り値を明示的に指定しない" id="a" impl="HICPP-7_1_9-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_9-a.rule"/>
            </rule>
         </category>
         <category name="7_2_1">
            <rule header="明示的な列挙型のベースを使用し、それがすべての列挙子を格納するのに十分な大きさがあることを確認する" id="a" impl="HICPP-7_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_1-a.rule"/>
            </rule>
         </category>
         <category name="7_2_2">
            <rule header="列挙型の列挙子は、何も初期化しないか、最初の 1 つだけを初期化するか、すべてを初期化する" id="a" impl="HICPP-7_2_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_2-a.rule"/>
            </rule>
         </category>
         <category name="7_5_1">
            <rule header="asm 宣言を使用しない" id="a" impl="HICPP-7_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_5_1-a.rule"/>
            </rule>
         </category>
         <category name="8_2_3">
            <rule header="トリビアルなコピー コンストラクターを持つ小さいオブジェクトは値で渡す" id="a" impl="HICPP-8_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_3-a.rule"/>
            </rule>
            <rule header="トリビアルなコピー コンストラクターを持つ小さいオブジェクトは値で渡す" id="b" impl="HICPP-8_2_3-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_3-b.rule"/>
            </rule>
         </category>
         <category name="8_2_4">
            <rule header="std::unique_ptr を const 参照で渡さない" id="a" impl="HICPP-8_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_4-a.rule"/>
            </rule>
         </category>
         <category name="8_3_3">
            <rule header="デフォルト引数を使用しない" id="a" impl="HICPP-8_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_3-a.rule"/>
            </rule>
         </category>
         <category name="8_3_4">
            <rule header="const への rvalue 参照型のパラメーターを持つ関数を =delete として定義する" id="a" impl="HICPP-8_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_4-a.rule"/>
            </rule>
         </category>
      </category>
      <category description="初期化" name="INIT">
         <rule header="外部リンケージを持つオブジェクトをヘッダー ファイルで初期化するべきではない" id="01" impl="INIT-01" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-01.rule"/>
         </rule>
         <rule header="signed 定数を使って unsigned integer 変数を初期化してはいけない" id="02" impl="INIT-02" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-02.rule"/>
         </rule>
         <rule header="すべての変数を初期化する" id="03" impl="INIT-03" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-03.rule"/>
         </rule>
         <rule header="すべてのポインタ変数を初期化する" id="04" impl="INIT-04" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-04.rule"/>
         </rule>
         <rule header="アドレスが変わる可能性のあるオブジェクトを参照するように参照を初期化してはいけない" id="05" impl="INIT-05" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-05.rule"/>
         </rule>
         <rule header="すべてのメンバ変数をコンストラクタで初期化する" id="06" impl="INIT-06" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-06.rule"/>
         </rule>
         <rule header="ユーザ定義コンストラクタを提供することにより、クラス メンバの初期化を明示的にする" id="07" impl="INIT-07" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-07.rule"/>
         </rule>
         <rule header="動的に割り当てられるクラス オブジェクトを適切に初期化するため、ユーザ定義コンストラクタを提供する" id="08" impl="INIT-08" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-08.rule"/>
         </rule>
         <rule header="クラスの静的メンバを初期化する" id="09" impl="INIT-09" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-09.rule"/>
         </rule>
         <rule header="宣言された順にメンバを初期化リストに記述する" id="10" impl="INIT-10" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-10.rule"/>
         </rule>
         <rule header="代入演算子は、すべてのデータ メンバーに代入を行わなければならない" id="11" impl="INIT-11" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-11.rule"/>
         </rule>
         <rule header="ローカルでない静的オブジェクトをローカルな static オブジェクトに置き換えることで、異なる翻訳単位にあるオブジェクトの初期化の順序に関する問題を避ける" id="12" impl="INIT-12" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-12.rule"/>
         </rule>
         <rule header="コンストラクタでオブジェクトが特定の順序で初期化されると想定してはならない" id="13" impl="INIT-13" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13.rule"/>
         </rule>
         <rule header="基底クラスのコンストラクターで、初期化されていない非静的メンバー変数を使用してはならない" id="13_a" impl="INIT-13_a" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_a.rule"/>
         </rule>
         <rule header="仮想基底クラスのコンストラクターで、非仮想基底クラスの初期化されていない非静的メンバー変数を使用してはならない" id="13_b" impl="INIT-13_b" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_b.rule"/>
         </rule>
         <rule header="基底クラスのコンストラクターで、初期化されていない可能性がある基底クラスの非静的メンバー変数を使用してはならない" id="13_c" impl="INIT-13_c" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13_c.rule"/>
         </rule>
         <rule header="コンストラクタでは代入ではなく初期化を使用する" id="14" impl="INIT-14" quickfix="false" scope="line" severity="5">
            <file path="INIT\INIT-14.rule"/>
         </rule>
         <rule header="コンストラクターを追加して構造体のメンバー変数を初期化することを検討する" id="15" impl="INIT-15" quickfix="false" scope="line" severity="4">
            <file path="INIT\INIT-15.rule"/>
         </rule>
         <rule header="集成体または共用体の初期化は括弧に囲まれていなければならない" id="16" impl="INIT-16" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-16.rule"/>
         </rule>
         <rule header="すべてのユーザー定義のコンストラクターがデータ メンバーを同じ定数値で初期化している場合、NSDMI を使用して初期化すべきである" id="17" impl="INIT-17" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-17.rule"/>
         </rule>
      </category>
      <category description="メトリクス" name="METRICS">
         <rule header="関数が 50 行を超えないようにする" id="01" impl="METRICS-01" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-01.rule"/>
         </rule>
         <rule header="case の多い switch 文は避ける" id="02" impl="METRICS-02" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-02.rule"/>
         </rule>
         <rule header="1 関数中のコード ブロックの数が多い" id="03" impl="METRICS-03" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-03.rule"/>
         </rule>
         <rule header="1関数中の関数呼び出しの数が多い" id="04" impl="METRICS-04" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-04.rule"/>
         </rule>
         <rule header="クラスの継承レベルが多い" id="05" impl="METRICS-05" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-05.rule"/>
         </rule>
         <rule header="1 クラスあたりのデータ メンバの数が 15 を超えてはならない" id="06" impl="METRICS-06" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-06.rule"/>
         </rule>
         <rule header="1 クラスあたりのメソッドの数が多い" id="07" impl="METRICS-07" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-07.rule"/>
         </rule>
         <rule header="1 メソッドあたりのパラメータの数が 10 を超えてはならない" id="08" impl="METRICS-08" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-08.rule"/>
         </rule>
         <rule header="1 クラスあたりの private データ メンバの数が多い" id="09" impl="METRICS-09" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-09.rule"/>
         </rule>
         <rule header="1 クラスあたりの private メソッドの数が多い" id="10" impl="METRICS-10" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-10.rule"/>
         </rule>
         <rule header="1 クラスあたりの protected データ メンバの数が多い" id="11" impl="METRICS-11" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-11.rule"/>
         </rule>
         <rule header="1 クラスあたりの protected メソッドの数が多い" id="12" impl="METRICS-12" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-12.rule"/>
         </rule>
         <rule header="1 クラスあたりの public データ メンバの数が多い" id="13" impl="METRICS-13" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-13.rule"/>
         </rule>
         <rule header="1 クラスあたりの public メソッドの数が多い" id="14" impl="METRICS-14" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-14.rule"/>
         </rule>
         <rule header="6 個以上のパラメータを持つ関数は避ける" id="15" impl="METRICS-15" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-15.rule"/>
         </rule>
         <rule header="マクロでは 6 個以上のパラメータを使ってはいけない" id="16" impl="METRICS-16" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-16.rule"/>
         </rule>
         <rule header="構造体、共用体、およびクラスのフィールド数は、20 を超えないよう にする" id="17" impl="METRICS-17" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-17.rule"/>
         </rule>
         <rule header="Cyclomatic 複雑度の限度 10 に従う" id="18" impl="METRICS-18" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-18.rule"/>
         </rule>
         <rule header="モジュール総行数に対するコメント行の割合は、20 パーセントから 60 パーセントの間でなければならない" id="19" impl="METRICS-19" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-19.rule"/>
         </rule>
         <rule header="長すぎる関数は避ける (宣言および文の数)" id="20" impl="METRICS-20" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-20.rule"/>
         </rule>
         <rule header="長すぎる関数は避ける (ブロック数)" id="21" impl="METRICS-21" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-21.rule"/>
         </rule>
         <rule header="76 行以上の関数を避ける" id="22" impl="METRICS-22" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-22.rule"/>
         </rule>
         <rule header="ブロックのネストの深さが 5 を超えてはならない" id="23" impl="METRICS-23" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-23.rule"/>
         </rule>
         <rule header="ソース ファイルが 500 行を超えないようにする" id="24" impl="METRICS-24" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-24.rule"/>
         </rule>
         <rule header="関数またはメソッドの論理ソース行 (L-SLOCs) は 200 を超えてはならない" id="25" impl="METRICS-25" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-25.rule"/>
         </rule>
         <rule header="ソース行は 120 文字以下にする" id="26" impl="METRICS-26" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-26.rule"/>
         </rule>
         <rule header="パラメータ が 8 個以上の関数は使用しない" id="27" impl="METRICS-27" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-27.rule"/>
         </rule>
         <rule header="Cyclomatic 複雑度の限度 20 に従う" id="28" impl="METRICS-28" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-28.rule"/>
         </rule>
         <rule header="Cyclomatic 複雑度のレポート" id="29" impl="METRICS-29" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-29.rule"/>
         </rule>
         <rule header="関数は 60 行を超えてはならない" id="30" impl="METRICS-30" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-30.rule"/>
         </rule>
         <rule header="1 関数につき平均 2 つ以上のアサーションを記述する" id="31" impl="METRICS-31" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-31.rule"/>
         </rule>
         <rule header="20 行を超える関数には、少なくとも 2 つのアサーションが含まれるべきである" id="32" impl="METRICS-32" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-32.rule"/>
         </rule>
         <rule header="Essential Complexity のレポート" id="33" impl="METRICS-33" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-33.rule"/>
         </rule>
         <rule header="Essential Complexity の制限 4 を守る" id="34" impl="METRICS-34" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-34.rule"/>
         </rule>
         <rule header="Essential Complexity の制限 10 を守る" id="35" impl="METRICS-35" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-35.rule"/>
         </rule>
         <rule header="関数は 6 個以上の関数から呼び出されてはならない" id="36" impl="METRICS-36" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-36.rule"/>
         </rule>
         <rule header="関数は 8 個以上の関数を呼び出してはならない" id="37" impl="METRICS-37" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-37.rule"/>
         </rule>
         <rule header="関数内のステートメントの数は 1 から 50 の範囲でなければならない" id="38" impl="METRICS-38" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-38.rule"/>
         </rule>
         <rule header="関数の VOCF メトリクスの値は 4 以下でなければならない" id="39" impl="METRICS-39" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-39.rule"/>
         </rule>
         <rule header="関数内のステートメントを 4 レベルより深くネストしてはならない" id="40" impl="METRICS-40" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-40.rule"/>
         </rule>
         <rule header="関数内のステートメント数に対する関数内と関数の前のコメント ブロック数との割合は &gt; 0.2 でなければならない" id="41" impl="METRICS-41" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-41.rule"/>
         </rule>
         <rule header="Essential Complexity の制限 1 を守る" id="42" impl="METRICS-42" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-42.rule"/>
         </rule>
         <rule header="関数の Halstead's delivered bugs (B) メトリクスをレポート" id="43" impl="METRICS-43" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-43.rule"/>
         </rule>
      </category>
      <category description="MISRA C 1998" name="MISRA">
         <rule header="適切な実行時チェックのために条件を用意する" id="004_a" impl="MISRA-004_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_a.rule"/>
         </rule>
         <rule header="適切な実行時チェックのために条件を用意する" id="004_b" impl="MISRA-004_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_b.rule"/>
         </rule>
         <rule header="ISO の C 規格で定義されている文字だけを使用する" id="005" impl="MISRA-005" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-005.rule"/>
         </rule>
         <rule header="文字型の値は、定義・文書化された ISO 10646-1 のサブセットに制限されるべきである" id="006" impl="MISRA-006" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-006.rule"/>
         </rule>
         <rule header="拡張文字列リテラルを使用してはならない" id="008" impl="MISRA-008" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-008.rule"/>
         </rule>
         <rule header="基本型の char、int、short、long、float および double を使用しない。代わりに特定の長さの typedef を使用する" id="013" impl="MISRA-013" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-013.rule"/>
         </rule>
         <rule header="char 型は常にunsigned char または signed char として宣言しなけれ ばならない" id="014" impl="MISRA-014" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-014.rule"/>
         </rule>
         <rule header="隠蔽されている浮動小数点数のビット表現を使用してはならない" id="016" impl="MISRA-016" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-016.rule"/>
         </rule>
         <rule header="数値定数には型を示す接尾語を付ける" id="018_a" impl="MISRA-018_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_a.rule"/>
         </rule>
         <rule header="数値定数には型を示す接尾語を付ける" id="018_b" impl="MISRA-018_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_b.rule"/>
         </rule>
         <rule header="数値定数には型を示す接尾語を付ける" id="018_c" impl="MISRA-018_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_c.rule"/>
         </rule>
         <rule header="数値定数には型を示す接尾語を付ける" id="018_d" impl="MISRA-018_d" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_d.rule"/>
         </rule>
         <rule header="すべての関数は、使用する前に宣言しなければならない" id="020" impl="MISRA-020" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-020.rule"/>
         </rule>
         <rule header="オブジェクト宣言は関数のスコープにするべきである" id="022" impl="MISRA-022" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-022.rule"/>
         </rule>
         <rule header="外部リンケージを持つオブジェクトまたは関数は、ヘッダー ファイルで宣言しなければならない" id="023" impl="MISRA-023" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-023.rule"/>
         </rule>
         <rule header="識別子は同一の翻訳単位において内部リンケージと外部リンケージを同時に持ってはならない" id="024" impl="MISRA-024" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-024.rule"/>
         </rule>
         <rule header="外部オブジェクトを複数のファイルで宣言してはいけない" id="027" impl="MISRA-027" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027.rule"/>
         </rule>
         <rule header="外部オブジェクトを実装ファイルで宣言してはいけない" id="027_b" impl="MISRA-027_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027_b.rule"/>
         </rule>
         <rule header="register 記憶域クラス指定子を使用してはならない" id="028" impl="MISRA-028" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-028.rule"/>
         </rule>
         <rule header="タグの使用は宣言と一致しなければならない" id="029" impl="MISRA-029" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-029.rule"/>
         </rule>
         <rule header="すべての自動変数は使用前に値を代入しなければならない" id="030" impl="MISRA-030" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-030.rule"/>
         </rule>
         <rule header="整数の除算を文書化する" id="041" impl="MISRA-041" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-041.rule"/>
         </rule>
         <rule header="カンマ演算子は for ループの制御式でだけ使用する" id="042" impl="MISRA-042" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-042.rule"/>
         </rule>
         <rule header="情報の損失を引き起こす可能性があるより広い型からより狭い型への暗黙的な変換を使用してはならない" id="043" impl="MISRA-043" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043.rule"/>
         </rule>
         <rule header="1 つの式の中で精度の異なる算術演算を混在させない" id="043_b" impl="MISRA-043_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_b.rule"/>
         </rule>
         <rule header="情報の損失を引き起こす可能性がある汎整数型から浮動小数点型への暗黙的な変換を使用してはならない" id="043_c" impl="MISRA-043_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_c.rule"/>
         </rule>
         <rule header="情報の損失につながる可能性があるため、汎整数型定数から浮動小数点型への暗黙的な変換を使用してはならない" id="043_d" impl="MISRA-043_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_d.rule"/>
         </rule>
         <rule header="volatile キーワードを使用してはいけない" id="046_a" impl="MISRA-046_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_a.rule"/>
         </rule>
         <rule header="代入文を他の代入文にネストしてはならない" id="046_b" impl="MISRA-046_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_b.rule"/>
         </rule>
         <rule header="結果をより広い整数型にキャストしている式での整数オーバーフローの可能性を避ける" id="048_a" impl="MISRA-048_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_a.rule"/>
         </rule>
         <rule header="2 つの整数の被除数を浮動小数点型にキャストしてはならない" id="048_b" impl="MISRA-048_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_b.rule"/>
         </rule>
         <rule header="空の文は、それ自体だけを一行に置かなければならない" id="054" impl="MISRA-054" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-054.rule"/>
         </rule>
         <rule header="switch 文中以外でラベルを使用してはいけない" id="055" impl="MISRA-055" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-055.rule"/>
         </rule>
         <rule header="break 文を使用してはならない" id="058" impl="MISRA-058" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-058.rule"/>
         </rule>
         <rule header="浮動小数点変数をループ カウンタとして使用してはならない" id="065" impl="MISRA-065" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-065.rule"/>
         </rule>
         <rule header="可変個数の引数を持つ関数を使用してはならない" id="069" impl="MISRA-069" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-069.rule"/>
         </rule>
         <rule header="関数にはプロトタイプ宣言がなければならず、プロトタイプは関数定義と関数呼び出しの両方から見えなければならない" id="071_a" impl="MISRA-071_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_a.rule"/>
         </rule>
         <rule header="関数は、関数呼び出しから見えるプロトタイプを持たなければならない" id="071_b" impl="MISRA-071_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_b.rule"/>
         </rule>
         <rule header="すべてのパラメータに対して識別子を与えるか、または全く与えないか のどちらかでなければならない" id="073" impl="MISRA-073" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-073.rule"/>
         </rule>
         <rule header="非 void の戻り値を持つ関数では、各 return は式を持たなければならない" id="083" impl="MISRA-083" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-083.rule"/>
         </rule>
         <rule header="void の戻り値を持つ関数では、return 文が式を持ってはならない" id="084" impl="MISRA-084" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-084.rule"/>
         </rule>
         <rule header="#include 指令の後には &lt;filename&gt; または &quot;filename&quot; が続かなければならない" id="089" impl="MISRA-089" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-089.rule"/>
         </rule>
         <rule header="関数マクロの定義全体に括弧を付けなければならない" id="096" impl="MISRA-096" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-096.rule"/>
         </rule>
         <rule header="前処理演算子 defined には標準書式だけを使用しなければならない" id="100" impl="MISRA-100" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-100.rule"/>
         </rule>
         <rule header="ポインタ算術は使用するべきではない" id="101" impl="MISRA-101" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-101.rule"/>
         </rule>
         <rule header="関数への非定数ポインタを使用してはいけない" id="104" impl="MISRA-104" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-104.rule"/>
         </rule>
         <rule header="1 つのポインタが指しているすべての関数において、引数の数と型、および戻り値の型は等しくなければならない" id="105" impl="MISRA-105" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-105.rule"/>
         </rule>
         <rule header="NULL ポインタを間接参照してはいけない" id="107_a" impl="MISRA-107_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_a.rule"/>
         </rule>
         <rule header="NULL ポインタを間接参照してはいけない" id="107_b" impl="MISRA-107_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_b.rule"/>
         </rule>
         <rule header="構造体または共用体ではすべてのメンバを指定するべきである" id="108" impl="MISRA-108" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-108.rule"/>
         </rule>
         <rule header="より大きなデータ型の一部分にアクセスするために共用体を使用してはいけない" id="110" impl="MISRA-110" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-110.rule"/>
         </rule>
         <rule header="構造体 ( またはクラス/共用体) のすべてのメンバには名前を付けなければならない" id="113" impl="MISRA-113" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-113.rule"/>
         </rule>
         <rule header="標準ライブラリ関数名を再使用してはならない" id="115" impl="MISRA-115" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-115.rule"/>
         </rule>
         <rule header="'setlocale' 関数を使用しない" id="121_a" impl="MISRA-121_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_a.rule"/>
         </rule>
         <rule header="&lt;locale.h&gt; ヘッダーをインクルードしない" id="121_b" impl="MISRA-121_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_b.rule"/>
         </rule>
      </category>
      <category description="MISRA C 2004" name="MISRA2004">
         <rule header="符号付き整数型と符号なし整数型の間の暗黙的変換を避ける" id="10_1_a" impl="MISRA2004-10_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_a.rule"/>
         </rule>
         <rule header="整数型と浮動小数点型の間の暗黙的変換を使用してはならない" id="10_1_b" impl="MISRA2004-10_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_b.rule"/>
         </rule>
         <rule header="複合式の暗黙的変換を避ける" id="10_1_c" impl="MISRA2004-10_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_c.rule"/>
         </rule>
         <rule header="広い型から狭い型への暗黙的変換を避ける" id="10_1_d" impl="MISRA2004-10_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_d.rule"/>
         </rule>
         <rule header="関数の return 式の暗黙的変換を避ける" id="10_1_e" impl="MISRA2004-10_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_e.rule"/>
         </rule>
         <rule header="複合式の暗黙的変換を避ける" id="10_1_f" impl="MISRA2004-10_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_f.rule"/>
         </rule>
         <rule header="関数引数の暗黙的変換を避ける" id="10_1_g" impl="MISRA2004-10_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_g.rule"/>
         </rule>
         <rule header="符号付き整数型と符号なし整数型の間の暗黙的変換を避ける" id="10_1_h" impl="MISRA2004-10_1_h" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_h.rule"/>
         </rule>
         <rule header="複合式の暗黙の変換を避ける" id="10_1_i" impl="MISRA2004-10_1_i" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_i.rule"/>
         </rule>
         <rule header="浮動小数点型から整数型への暗黙的変換を使用してはならない" id="10_2_a" impl="MISRA2004-10_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
         </rule>
         <rule header="浮動小数点型のより狭い型への暗黙の変換を避ける" id="10_2_b" impl="MISRA2004-10_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
         </rule>
         <rule header="浮動小数点型のより広い型への暗黙の変換を避ける" id="10_2_c" impl="MISRA2004-10_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_c.rule"/>
         </rule>
         <rule header="浮動小数点型のより狭い型への暗黙の変換を避ける" id="10_2_d" impl="MISRA2004-10_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
         </rule>
         <rule header="整数型の複合式の値は、式の潜在型と同じ符号属性をもつ、より小さな型へのキャストだけが許される" id="10_3" impl="MISRA2004-10_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_3.rule"/>
         </rule>
         <rule header="ビット単位の演算子 ~ 及び &lt;&lt; が、潜在型の unsigned char または unsigned short であるオペランドに適用される場合、その結果は、そのオペランドの潜在型へ直ちにキャストさせる" id="10_5" impl="MISRA2004-10_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_5.rule"/>
         </rule>
         <rule header="すべての符号なし型の定数には、接尾辞 U を付けなければならない" id="10_6" impl="MISRA2004-10_6" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-10_6.rule"/>
         </rule>
         <rule header="関数ポインタは、汎整数型以外の任意の型との間で変換してはならない" id="11_1" impl="MISRA2004-11_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_1.rule"/>
         </rule>
         <rule header="オブジェクト ポインタは、汎整数型、オブジェクト型を指す他のポインタ、void ポインタを除く任意の型との間で変換してはならない" id="11_2" impl="MISRA2004-11_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2.rule"/>
         </rule>
         <rule header="オブジェクト ポインタは、汎整数型、オブジェクト型を指す他のポインタ、void ポインタを除く任意の型との間で変換してはならない" id="11_2_b" impl="MISRA2004-11_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_b.rule"/>
         </rule>
         <rule header="オブジェクト ポインタは、汎整数型、オブジェクト型を指す他のポインタ、void ポインタを除く任意の型との間で変換してはならない" id="11_2_c" impl="MISRA2004-11_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_c.rule"/>
         </rule>
         <rule header="キャストでポインター型を汎整数型に変換してはならない" id="11_3_a" impl="MISRA2004-11_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_a.rule"/>
         </rule>
         <rule header="キャストで汎整数型をポインター型に変換してはならない" id="11_3_b" impl="MISRA2004-11_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_b.rule"/>
         </rule>
         <rule header="オブジェクト型を指すポインタとオブジェクト型を指す異なるポインタの間でキャストすべきでない" id="11_4" impl="MISRA2004-11_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_4.rule"/>
         </rule>
         <rule header="キャストによってポインターまたは参照型から const または volatile 修飾子を取り除いてはならない" id="11_5" impl="MISRA2004-11_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_5.rule"/>
         </rule>
         <rule header="カンマ演算子は、用いてはならない" id="12_10" impl="MISRA2004-12_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_10.rule"/>
         </rule>
         <rule header="浮動小数点値の潜在的なビット表現は、用いてはならない" id="12_12" impl="MISRA2004-12_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_12.rule"/>
         </rule>
         <rule header="1つの式の中で、インクリメント (++) 演算子およびデクリメント (--) 演算子は、式中で他の演算子と混在させるべきではない" id="12_13" impl="MISRA2004-12_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_13.rule"/>
         </rule>
         <rule header="代入演算子の右辺のオペランドに代入式が含まれる場合、括弧を使用する" id="12_1_a" impl="MISRA2004-12_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_a.rule"/>
         </rule>
         <rule header="式中における C 言語の演算子優先順位規則への依存は、極力制限すべきである" id="12_1_b" impl="MISRA2004-12_1_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_b.rule"/>
         </rule>
         <rule header="単項演算子のオペランドには括弧は必要ない" id="12_1_c" impl="MISRA2004-12_1_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_c.rule"/>
         </rule>
         <rule header="式中における C 言語の演算子優先順位規則への依存は、極力制限すべきである" id="12_1_d" impl="MISRA2004-12_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_d.rule"/>
         </rule>
         <rule header="式中のすべての演算子の種類が同じでない限り、括弧を使用する" id="12_1_e" impl="MISRA2004-12_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
         </rule>
         <rule header="式中における C 言語の演算子優先順位規則への依存は、極力制限すべきである" id="12_1_f" impl="MISRA2004-12_1_f" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_f.rule"/>
         </rule>
         <rule header="式の値は、規格が認めるどのような順序で評価されようとも、同じでなければならない" id="12_2_a" impl="MISRA2004-12_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
         </rule>
         <rule header="関数の引数の評価順序に依存するコードを書いてはならない" id="12_2_b" impl="MISRA2004-12_2_b" quickfix="false" scope="line" severity="1">
            <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
         </rule>
         <rule header="関数呼び出しおよび関数引数の評価順序に依存するコードを記述してはならない" id="12_2_c" impl="MISRA2004-12_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
         </rule>
         <rule header="関数呼び出しを含む式の評価順序に依存するコードを書いてはならない" id="12_2_d" impl="MISRA2004-12_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
         </rule>
         <rule header="オブジェクトは、シーケンス ポイントの間で、格納された値が式の評価によって 2 回以上変更されてはならない" id="12_2_e" impl="MISRA2004-12_2_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
         </rule>
         <rule header="2 つの隣接するシーケンス ポイント間で複数の volatile を使用してはならない" id="12_2_f" impl="MISRA2004-12_2_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
         </rule>
         <rule header="関数呼び出しの評価順序に依存するコードを書いてはならない" id="12_2_g" impl="MISRA2004-12_2_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
         </rule>
         <rule header="sizeof 演算子のオペランドに副作用を持つ式が含まれていてはならない" id="12_3" impl="MISRA2004-12_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3.rule"/>
         </rule>
         <rule header="sizeof 演算子のオペランドで volatile 左辺値として指定されたオブジェクトにアクセスするべきではない" id="12_3_b" impl="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
         </rule>
         <rule header="副作用を持つ関数の呼び出しを sizeof 演算子のオペランドとして使用してはならない" id="12_3_c" impl="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
         </rule>
         <rule header="論理演算子 &amp;&amp; または || の右側のオペランドには、副作用があってはならない" id="12_4_a" impl="MISRA2004-12_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
         </rule>
         <rule header="論理演算子 &amp;&amp; または|| のオペランドは一次式でなければならない" id="12_5" impl="MISRA2004-12_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_5.rule"/>
         </rule>
         <rule header="論理演算子 (&amp;&amp;, ||, !) のオペランドは、実質的なブール型になるべきである" id="12_6_a" impl="MISRA2004-12_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_a.rule"/>
         </rule>
         <rule header="実質的なブール型である式は、(&amp;&amp;、||、!、=、==、!= および ?:) 以外の演算子のオペランドとして用いるべきではない" id="12_6_b" impl="MISRA2004-12_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_b.rule"/>
         </rule>
         <rule header="ビット単位の演算子は、潜在型が符号付きのオペランドに対して適用してはならない" id="12_7" impl="MISRA2004-12_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_7.rule"/>
         </rule>
         <rule header="シフト演算子の右側のオペランドの値は、0 以上かつ左辺のオペランドの潜在型のビット幅未満でなければならない" id="12_8" impl="MISRA2004-12_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_8.rule"/>
         </rule>
         <rule header="単項マイナス (-) 演算子を、潜在型が符号なしの式に用いてはならない" id="12_9" impl="MISRA2004-12_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_9.rule"/>
         </rule>
         <rule header="ブール値が生成される式の中で代入演算子を用いてはならない" id="13_1" impl="MISRA2004-13_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="オペランドが実質的にブール型である場合を除き、 0 との比較テストは明示的に行うべきである" id="13_2" impl="MISRA2004-13_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_2.rule"/>
         </rule>
         <rule header="浮動小数点式は、等価または非等価のテストをしてはならない" id="13_3" impl="MISRA2004-13_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_3.rule"/>
         </rule>
         <rule header="for 文の制御式は、浮動小数点型のオブジェクトを含んではならない" id="13_4" impl="MISRA2004-13_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_4.rule"/>
         </rule>
         <rule header="for 文の 3 つの式には、ループ制御に関わるものだけを記述しなければならない" id="13_5" impl="MISRA2004-13_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_5.rule"/>
         </rule>
         <rule header="for ループの中で繰り返しカウンタとして用いる数値変数は、ループの本体内で変更してはならない" id="13_6" impl="MISRA2004-13_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_6.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_a" impl="MISRA2004-13_7_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_a.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_aa" impl="MISRA2004-13_7_aa" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aa.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ab" impl="MISRA2004-13_7_ab" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ab.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ac" impl="MISRA2004-13_7_ac" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ac.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ad" impl="MISRA2004-13_7_ad" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ad.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ae" impl="MISRA2004-13_7_ae" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ae.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_af" impl="MISRA2004-13_7_af" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_af.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ag" impl="MISRA2004-13_7_ag" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ag.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ah" impl="MISRA2004-13_7_ah" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ah.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ai" impl="MISRA2004-13_7_ai" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ai.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_aj" impl="MISRA2004-13_7_aj" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aj.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_ak" impl="MISRA2004-13_7_ak" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ak.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_b" impl="MISRA2004-13_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_b.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_c" impl="MISRA2004-13_7_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_c.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_d" impl="MISRA2004-13_7_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_d.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_j" impl="MISRA2004-13_7_j" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_j.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_k" impl="MISRA2004-13_7_k" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_k.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_l" impl="MISRA2004-13_7_l" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_l.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_m" impl="MISRA2004-13_7_m" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_m.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_n" impl="MISRA2004-13_7_n" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_n.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_s" impl="MISRA2004-13_7_s" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_s.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_t" impl="MISRA2004-13_7_t" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_t.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_u" impl="MISRA2004-13_7_u" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_u.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_v" impl="MISRA2004-13_7_v" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_v.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_w" impl="MISRA2004-13_7_w" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_w.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_x" impl="MISRA2004-13_7_x" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_x.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_y" impl="MISRA2004-13_7_y" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_y.rule"/>
         </rule>
         <rule header="結果が不変になるブール演算は許されない" id="13_7_z" impl="MISRA2004-13_7_z" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_z.rule"/>
         </rule>
         <rule header="すべてのif...else if 構文は、else 節で終了しなければならない" id="14_10" impl="MISRA2004-14_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_10.rule"/>
         </rule>
         <rule header="else ブロックに到達しないコードがあってはならない" id="14_1_a" impl="MISRA2004-14_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
         </rule>
         <rule header="return、break、continue および goto 文の後に到達しないコードがあってはならない" id="14_1_b" impl="MISRA2004-14_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
         </rule>
         <rule header="if、do while、while、for ブロックに到達しないコードがあってはならない" id="14_1_c" impl="MISRA2004-14_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
         </rule>
         <rule header="switch 文に到達しないコードがあってはならない" id="14_1_d" impl="MISRA2004-14_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
         </rule>
         <rule header="for ループに到達しないコードがあってはならない" id="14_1_e" impl="MISRA2004-14_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
         </rule>
         <rule header="if または switch の後に到達しないコードがあってはならない" id="14_1_f" impl="MISRA2004-14_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
         </rule>
         <rule header="while、for、do...while ループの中の if または switch の後に到達できないコードがあってはならない" id="14_1_g" impl="MISRA2004-14_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
         </rule>
         <rule header="すべての空でない文は、どのように実行されても1つ以上の副作用を持つか、制御フローを変えなければならない" id="14_2" impl="MISRA2004-14_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_2.rule"/>
         </rule>
         <rule header="空の文は、それ自体だけを一行に置くか、後にコメントを続けなければならない" id="14_3" impl="MISRA2004-14_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_3.rule"/>
         </rule>
         <rule header="goto 文を用いてはならない" id="14_4" impl="MISRA2004-14_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_4.rule"/>
         </rule>
         <rule header="continue 文を用いてはならない" id="14_5" impl="MISRA2004-14_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_5.rule"/>
         </rule>
         <rule header="繰り返し文にはループを終了させるために 1つだけ break 文を置くことができる" id="14_6" impl="MISRA2004-14_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_6.rule"/>
         </rule>
         <rule header="関数では、関数の最後に唯一の出口がなければならない" id="14_7" impl="MISRA2004-14_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_7.rule"/>
         </rule>
         <rule header="switch、while、do...while 、for 文の本体を構成する文は、複合文でなければならない" id="14_8" impl="MISRA2004-14_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_8.rule"/>
         </rule>
         <rule header="if および else の後には複合文を続けなければならない" id="14_9" impl="MISRA2004-14_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_9.rule"/>
         </rule>
         <rule header="break 文は switch 句の最後にだけ置くべきである" id="15_0_a" impl="MISRA2004-15_0_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_a.rule"/>
         </rule>
         <rule header="switch 文には switch ラベルと switch 節のみ使用し、他のコードを入れるべきではない" id="15_0_b" impl="MISRA2004-15_0_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_b.rule"/>
         </rule>
         <rule header="switch ラベルは、それを直接内包している複合文が switch 文の本文である場合にだけ用いなければならない" id="15_1" impl="MISRA2004-15_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_1.rule"/>
         </rule>
         <rule header="空でない case 節は、無条件 break 文で終了しなければならない" id="15_2" impl="MISRA2004-15_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2.rule"/>
         </rule>
         <rule header="空でない default 節は、無条件 break 文で終了しなければならない" id="15_2_b" impl="MISRA2004-15_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
         </rule>
         <rule header="switch の最後の節は、default 節でなければならない" id="15_3" impl="MISRA2004-15_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_3.rule"/>
         </rule>
         <rule header="switch 式では、実質的なブール型になる値を用いてはならない" id="15_4" impl="MISRA2004-15_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="switch 文では、実質的なブール型になる値を用いてはならない" id="15_4_b" impl="MISRA2004-15_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4_b.rule"/>
         </rule>
         <rule header="すべての switch 文には、最低でも 1 つの case 節を記述しなければならない" id="15_5" impl="MISRA2004-15_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="可変個引数を持つ関数を定義してはならない" id="16_1" impl="MISRA2004-16_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_1.rule"/>
         </rule>
         <rule header="関数がエラー情報を戻す場合、エラー情報をテストしなければならない" id="16_10" impl="MISRA2004-16_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_10.rule"/>
         </rule>
         <rule header="関数は、直接的か間接的かにかかわらず、その関数自身を呼び出してはならない" id="16_2" impl="MISRA2004-16_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_2.rule"/>
         </rule>
         <rule header="関数プロトタイプ宣言では、すべての仮引数に対して識別子を指定しなければならない" id="16_3" impl="MISRA2004-16_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_3.rule"/>
         </rule>
         <rule header="関数の宣言とその定義で用いられる識別子とは一致しなければならない" id="16_4" impl="MISRA2004-16_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_4.rule"/>
         </rule>
         <rule header="引数を持たない関数は、仮引数を void 型で宣言しなければならない" id="16_5" impl="MISRA2004-16_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_5.rule"/>
         </rule>
         <rule header="関数に渡される実引数の数は、仮引数の数と一致しなければならない" id="16_6" impl="MISRA2004-16_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_6.rule"/>
         </rule>
         <rule header="関数プロトタイプのポインタ仮引数は、指し示しているオブジェクトを変更する目的でポインタが用いられていない場合、 const へのポインタとして宣言すべきである" id="16_7" impl="MISRA2004-16_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7.rule"/>
         </rule>
         <rule header="仮引数の型は、指し示しているオブジェクトを変更する目的でポインタが用いられていない場合、 const へのポインタの typedef として宣言すべきである" id="16_7_b" impl="MISRA2004-16_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
         </rule>
         <rule header="戻り値の型が非 void の関数の場合、すべての出口で、式を持つ明示的な return 文を記述しなければならない" id="16_8" impl="MISRA2004-16_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="関数識別子を使用する場合、必ず前に &amp; を付けるか、括弧で囲んだパラメーター リスト (空でも構わない) を付ける" id="16_9" impl="MISRA2004-16_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_9.rule"/>
         </rule>
         <rule header="ポインタ算術は、配列または配列要素を扱うポインタだけに適用しなければならない" id="17_1" impl="MISRA2004-17_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_1.rule"/>
         </rule>
         <rule header="ポインタ算術で許される形式は、配列添え字付けだけでなければならない" id="17_4" impl="MISRA2004-17_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_4.rule"/>
         </rule>
         <rule header="オブジェクトの宣言には、3 階層以上のポインター間接参照があってはならない" id="17_5" impl="MISRA2004-17_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_5.rule"/>
         </rule>
         <rule header="自動記憶域のオブジェクトのアドレスを関数から返してはいけない" id="17_6_a" impl="MISRA2004-17_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
         </rule>
         <rule header="自動記憶域のオブジェクトのアドレスを、オブジェクトが存在しなくなった後にも存在し続ける可能性がある別のオブジェクトに代入してはならない" id="17_6_b" impl="MISRA2004-17_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
         </rule>
         <rule header="すべての構造体及び共用体の型は、コンパイル単位の最後には完全でなければならない" id="18_1" impl="MISRA2004-18_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_1.rule"/>
         </rule>
         <rule header="オブジェクトを重複するオブジェクトに代入してはならない" id="18_2" impl="MISRA2004-18_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2.rule"/>
         </rule>
         <rule header="オブジェクトを重複するオブジェクトに代入してはならない" id="18_2_b" impl="MISRA2004-18_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
         </rule>
         <rule header="共用体は、用いてはならない" id="18_4" impl="MISRA2004-18_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_4.rule"/>
         </rule>
         <rule header="ファイルの中で、#include 文の前には、他の前処理指令またはコメントだけを記述すべきである" id="19_1" impl="MISRA2004-19_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_1.rule"/>
         </rule>
         <rule header="# または ## のオペランドとして用いられる場合を除き、関数形式マクロの定義では、仮引数のそれぞれのインスタンスを括弧で囲まなければならない" id="19_10" impl="MISRA2004-19_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_10.rule"/>
         </rule>
         <rule header="翻訳単位内に定義されていないマクロを前処理指令 #if および #elif で使用してはならない" id="19_11_b" impl="MISRA2004-19_11_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
         </rule>
         <rule header="1 つのマクロ定義内で、# または ## 前処理演算子を複数回用いてはならない" id="19_12" impl="MISRA2004-19_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_12.rule"/>
         </rule>
         <rule header="前処理演算子 # 及び ## を用いてはならない" id="19_13" impl="MISRA2004-19_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_13.rule"/>
         </rule>
         <rule header="defined 前処理演算子は、2 つの標準形式のうち、いずれかの形式を用いなければならない" id="19_14" impl="MISRA2004-19_14" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_14.rule"/>
         </rule>
         <rule header="同じヘッダー ファイルの内容が 2 回取り込まれないように、予防措置を採らなければならない" id="19_15" impl="MISRA2004-19_15" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_15.rule"/>
         </rule>
         <rule header="前処理指令は、前処理で除外されたとしても、構文的に意味を持つようにしなければならない" id="19_16" impl="MISRA2004-19_16" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_16.rule"/>
         </rule>
         <rule header="すべての #else、#elif、#endif 前処理指令は、それに関連する #if 指令または #ifdef 指令と同じファイル内に存在しなければならない" id="19_17" impl="MISRA2004-19_17" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_17.rule"/>
         </rule>
         <rule header="#include 指令のヘッダー ファイル名には、非標準文字を記述すべきではない" id="19_2" impl="MISRA2004-19_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_2.rule"/>
         </rule>
         <rule header="マクロでキーワードや基本型を使用しない" id="19_4" impl="MISRA2004-19_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_4.rule"/>
         </rule>
         <rule header="マクロは、ブロック内で #define または #undef してはならない" id="19_5" impl="MISRA2004-19_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_5.rule"/>
         </rule>
         <rule header="#undef を用いてはならない" id="19_6" impl="MISRA2004-19_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_6.rule"/>
         </rule>
         <rule header="関数形式マクロよりも関数を用いるべきである" id="19_7" impl="MISRA2004-19_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_7.rule"/>
         </rule>
         <rule header="実引数のすべてを指定せずに、関数形式マクロを呼び出してはならない" id="19_8" impl="MISRA2004-19_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_8.rule"/>
         </rule>
         <rule header="関数形式マクロの引数には、前処理指令のような字句を記述してはならない" id="19_9" impl="MISRA2004-19_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_9.rule"/>
         </rule>
         <rule header="&lt;stdlib.h&gt;ライブラリのライブラリ関数 atof、atoi、atol は、用いてはならない" id="20_10" impl="MISRA2004-20_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_10.rule"/>
         </rule>
         <rule header="&lt;time.h&gt; ライブラリの時間操作関数は、用いてはならない" id="20_12" impl="MISRA2004-20_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12.rule"/>
         </rule>
         <rule header="名前がアンダースコアで始まる識別子を #define または #undef してはならない" id="20_1_a" impl="MISRA2004-20_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
         </rule>
         <rule header="予約済み識別子を再定義してはならない" id="20_1_b" impl="MISRA2004-20_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
         </rule>
         <rule header="defined 識別子を #define または #undef してはならない" id="20_1_e" impl="MISRA2004-20_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
         </rule>
         <rule header="標準ライブラリのマクロ、オブジェクト、関数の名前を再利用してはならない" id="20_2" impl="MISRA2004-20_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2.rule"/>
         </rule>
         <rule header="標準ライブラリのマクロ、オブジェクト、関数の名前を再利用してはならない (C90)" id="20_2_a" impl="MISRA2004-20_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_a.rule"/>
         </rule>
         <rule header="標準ライブラリのマクロ、オブジェクト、関数の名前を再利用してはならない (C99)" id="20_2_b" impl="MISRA2004-20_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_b.rule"/>
         </rule>
         <rule header="ライブラリ関数に渡される値については、その妥当性をチェックしなければならない" id="20_3" impl="MISRA2004-20_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_3.rule"/>
         </rule>
         <rule header="動的なヒープ メモリの割り当ては、用いてはならない" id="20_4" impl="MISRA2004-20_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_4.rule"/>
         </rule>
         <rule header="エラー指示子 errno は、用いてはならない" id="20_5" impl="MISRA2004-20_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_5.rule"/>
         </rule>
         <rule header="&lt;stddef.h&gt; ライブラリのoffsetof マクロは、用いてはならない" id="20_6" impl="MISRA2004-20_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_6.rule"/>
         </rule>
         <rule header="setjmp マクロと longjmp 関数は、用いてはならない" id="20_7" impl="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="&lt;setjmp.h&gt; ヘッダーをインクルードしてはいけない" id="20_7_b" impl="MISRA2004-20_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
         </rule>
         <rule header="ヘッダー ファイル &lt;signal.h&gt; をインクルードしてはいけない" id="20_8" impl="MISRA2004-20_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8.rule"/>
         </rule>
         <rule header="&lt;signal.h&gt; のシグナル処理を用いてはならない" id="20_8_b" impl="MISRA2004-20_8_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
         </rule>
         <rule header="入出力ライブラリ &lt;stdio.h&gt; を使用してはならない" id="20_9" impl="MISRA2004-20_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_9.rule"/>
         </rule>
         <rule header="アセンブリ言語は、カプセル化して分離しなければならない" id="2_1" impl="MISRA2004-2_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_1.rule"/>
         </rule>
         <rule header="ソース コードでは、 /* ... */ スタイルのコメントだけを用いなければならない" id="2_2" impl="MISRA2004-2_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_2.rule"/>
         </rule>
         <rule header="文字列 /* を C スタイルコメント内で用いてはならない" id="2_3" impl="MISRA2004-2_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_3.rule"/>
         </rule>
         <rule header="コード セクションを &quot;コメント アウト&quot; してはならない" id="2_4" impl="MISRA2004-2_4" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-2_4.rule"/>
         </rule>
         <rule header="用いる #pragma 指令は、すべて文書化し、説明しなければならない" id="3_4" impl="MISRA2004-3_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_4.rule"/>
         </rule>
         <rule header="ビットフィールドと他のデータを同じ構造体に混在させない" id="3_5" impl="MISRA2004-3_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_5.rule"/>
         </rule>
         <rule header="ISO C 規格で定義されているエスケープ シーケンスのみ使用する" id="4_1" impl="MISRA2004-4_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_1.rule"/>
         </rule>
         <rule header="3 文字表記は、用いてはならない" id="4_2" impl="MISRA2004-4_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_2.rule"/>
         </rule>
         <rule header="ローカルまたは関数プロトタイプ スコープで宣言された識別子は、グローバルまたは名前空間のスコープで宣言された識別子を隠蔽してはならない" id="5_2_a" impl="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="内側のローカル スコープで宣言された識別子は、外側のローカル スコープで宣言された識別子を隠蔽してはならない" id="5_2_b" impl="MISRA2004-5_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
         </rule>
         <rule header="typedef名を再利用してはならない" id="5_3_a" impl="MISRA2004-5_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_a.rule"/>
         </rule>
         <rule header="typedef 名を typedef 名として再利用してはならない" id="5_3_b" impl="MISRA2004-5_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_b.rule"/>
         </rule>
         <rule header="タグ名を他の目的で再利用してはならない" id="5_4_a" impl="MISRA2004-5_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_a.rule"/>
         </rule>
         <rule header="タグ名は、固有の識別子でなければならない" id="5_4_b" impl="MISRA2004-5_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_b.rule"/>
         </rule>
         <rule header="typedef 名はそれが指す型と同じ名前にするべきではない" id="5_4_c" impl="MISRA2004-5_4_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_c.rule"/>
         </rule>
         <rule header="静的記憶域期間を持つオブジェクトや関数識別子は、再使用すべきでない" id="5_5_a" impl="MISRA2004-5_5_a" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_a.rule"/>
         </rule>
         <rule header="静的記憶域期間を持つオブジェクトや関数識別子は、再使用すべきでない" id="5_5_b" impl="MISRA2004-5_5_b" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_b.rule"/>
         </rule>
         <rule header="構造体及び共用体のメンバ名を除いて、あるネームスペースの識別子を別のネームスペースの識別子と同じ綴りにしてはいけない" id="5_6" impl="MISRA2004-5_6" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_6.rule"/>
         </rule>
         <rule header="識別子名は、再使用すべきではない" id="5_7" impl="MISRA2004-5_7" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_7.rule"/>
         </rule>
         <rule header="単なる char 型は、文字データの格納及び使用に限って用いなければならない" id="6_1" impl="MISRA2004-6_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_1.rule"/>
         </rule>
         <rule header="signed char 型及び unsigned char 型は、数値データの格納及び使用に限って用いなければならない" id="6_2" impl="MISRA2004-6_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_2.rule"/>
         </rule>
         <rule header="基本型を指す typedef の名前は数字を含むべきである" id="6_3" impl="MISRA2004-6_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3.rule"/>
         </rule>
         <rule header="基本型の代わりに typedef を使用するべきである" id="6_3_b" impl="MISRA2004-6_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
         </rule>
         <rule header="ビットフィールドは、unsigned int 型または signed int 型だけで定義しなければならない" id="6_4" impl="MISRA2004-6_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_4.rule"/>
         </rule>
         <rule header="signed int 型の名前なしビット フィールドの長さは 2 ビット以上でなければならない" id="6_5_a" impl="MISRA2004-6_5_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_5_a.rule"/>
         </rule>
         <rule header="ゼロ以外の 8 進定数を使用してはいけない" id="7_1_a" impl="MISRA2004-7_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
         </rule>
         <rule header="8 進拡張表記を使用してはいけない" id="7_1_b" impl="MISRA2004-7_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_b.rule"/>
         </rule>
         <rule header="static 記憶域クラス指定子は、内部結合を持つオブジェクト並びに関数の定義および宣言に対して用いなければならない" id="8_11" impl="MISRA2004-8_11" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_11.rule"/>
         </rule>
         <rule header="外部結合を持つ配列を宣言するときは、明示的にサイズを記述するか、初期化によって暗黙的にサイズを定義しなければならない" id="8_12" impl="MISRA2004-8_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_12.rule"/>
         </rule>
         <rule header="オブジェクトまたは関数を宣言または定義するときは、常にその型を明記しなければならない" id="8_2_a" impl="MISRA2004-8_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_a.rule"/>
         </rule>
         <rule header="オブジェクトまたは関数を宣言または定義するときは、常にその型を明記しなければならない" id="8_2_b" impl="MISRA2004-8_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_b.rule"/>
         </rule>
         <rule header="宣言と定義で同一の型を使用する" id="8_3_a" impl="MISRA2004-8_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_a.rule"/>
         </rule>
         <rule header="宣言と定義で同一の型を使用する" id="8_3_b" impl="MISRA2004-8_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_b.rule"/>
         </rule>
         <rule header="オブジェクトまたは関数が 2 回以上宣言される場合、型は互換性がなければならない" id="8_4" impl="MISRA2004-8_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_4.rule"/>
         </rule>
         <rule header="ヘッダー ファイル内で、オブジェクトまたは関数の定義を記述してはならない" id="8_5" impl="MISRA2004-8_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_5.rule"/>
         </rule>
         <rule header="常にファイル スコープで関数を宣言する" id="8_6" impl="MISRA2004-8_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_6.rule"/>
         </rule>
         <rule header="オブジェクトが単一の関数内だけでアクセスされている場合は、そのオブジェクトをブロック スコープで定義しなければならない" id="8_7" impl="MISRA2004-8_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_7.rule"/>
         </rule>
         <rule header="配列を部分的に初期化してはならない" id="9_2_b" impl="MISRA2004-9_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
         </rule>
         <rule header="ゼロ以外で構造体を初期化する場合、各要素に対して明示的な初期化子が必要である" id="9_2_c" impl="MISRA2004-9_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_c.rule"/>
         </rule>
         <rule header="すべての要素を明示的に初期化する場合を除き、列挙子リストでは、先頭以外のメンバを明示的に初期化するために　=　構文を用いてはならない" id="9_3" impl="MISRA2004-9_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_3.rule"/>
         </rule>
      </category>
      <category description="メモリおよびリソース管理" name="MRM">
         <rule header="関数のパラメータの評価順は未定義であるため、関数の引数リストでリソースを割り当てない" id="01" impl="MRM-01" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-01.rule"/>
         </rule>
         <rule header="1 つの文で 2 つ以上のリソースを割り当てない" id="02" impl="MRM-02" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-02.rule"/>
         </rule>
         <rule header="すべてのクラスに代入演算子または適切なコメントがなければならない" id="04" impl="MRM-04" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-04.rule"/>
         </rule>
         <rule header="すべてのクラスにコピー コンストラクタまたは適切なコメントがなければならない" id="05" impl="MRM-05" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-05.rule"/>
         </rule>
         <rule header="対応する new/malloc および delete/free の呼び出しでは、同じ形式を使用する" id="06" impl="MRM-06" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-06.rule"/>
         </rule>
         <rule header="POD 型以外では memcpy や memcmp を使用しない" id="07" impl="MRM-07" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-07.rule"/>
         </rule>
         <rule header="コンストラクタのあるオブジェクトに対し malloc/realloc を呼び出さない" id="08" impl="MRM-08" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-08.rule"/>
         </rule>
         <rule header="解放したメモリを指す式には、必ず新しい値を割り当てる" id="09" impl="MRM-09" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-09.rule"/>
         </rule>
         <rule header="解放したメモリを指すグローバル変数またはメンバー変数には、必ず新しい値を割り当てる" id="10" impl="MRM-10" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-10.rule"/>
         </rule>
         <rule header="解放したメモリを指すパラメーターまたはローカル変数には、必ず新しい値を割り当てる" id="11" impl="MRM-11" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-11.rule"/>
         </rule>
         <rule header="new と delete の定義を自分で書く場合は慣例に従う" id="12" impl="MRM-12" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-12.rule"/>
         </rule>
         <rule header="new の使用では、慣例に従う" id="13" impl="MRM-13" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-13.rule"/>
         </rule>
         <rule header="クラスで operator new のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="14" impl="MRM-14" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-14.rule"/>
         </rule>
         <rule header="クラスで operator new[] のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="15" impl="MRM-15" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-15.rule"/>
         </rule>
         <rule header="クラスで operator delete のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="16" impl="MRM-16" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-16.rule"/>
         </rule>
         <rule header="クラスで operator delete[] のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="17" impl="MRM-17" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-17.rule"/>
         </rule>
         <rule header="割り当てたメモリが後に他の場所で解放されることを期待してはならない" id="18" impl="MRM-18" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-18.rule"/>
         </rule>
         <rule header="割り当てたメモリが後に他の場所で解放されることを期待してはならない" id="19" impl="MRM-19" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-19.rule"/>
         </rule>
         <rule header="割り当てたメモリが後に他の場所で解放されることを期待してはならない" id="20" impl="MRM-20" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-20.rule"/>
         </rule>
         <rule header="リソース管理にオブジェクトを使用する" id="21" impl="MRM-21" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-21.rule"/>
         </rule>
         <rule header="リソース管理にオブジェクトを使用する" id="22" impl="MRM-22" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-22.rule"/>
         </rule>
         <rule header="関数内の new によって初期化された間接参照 ローカル ポインタを返さない" id="23" impl="MRM-23" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-23.rule"/>
         </rule>
         <rule header="new で生成したオブジェクトをスマートポインタに渡すのは、独立したステートメントで行う" id="25" impl="MRM-25" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-25.rule"/>
         </rule>
         <rule header="演算子 new を記述した場合は演算子 delete を記述する" id="26" impl="MRM-26" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-26.rule"/>
         </rule>
         <rule header="演算子 new[] を記述した場合は演算子 delete[] を記述する" id="27" impl="MRM-27" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-27.rule"/>
         </rule>
         <rule header="new と delete はいつも一緒に提供する" id="28" impl="MRM-28" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-28.rule"/>
         </rule>
         <rule header="new[] と delete[] は常に一緒に提供する" id="29" impl="MRM-29" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-29.rule"/>
         </rule>
         <rule header="new または malloc ではなく、宣言によって割り当てる" id="30" impl="MRM-30" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-30.rule"/>
         </rule>
         <rule header="解放されたメモリはいかなる場合でもその後にアクセスしてはならない" id="31" impl="MRM-31" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31.rule"/>
         </rule>
         <rule header="デストラクターを手動で呼び出してはならない" id="31_b" impl="MRM-31_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31_b.rule"/>
         </rule>
         <rule header="グローバルな new を隠さないようにする" id="32" impl="MRM-32" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-32.rule"/>
         </rule>
         <rule header="デストラクタ中でポインタ メンバに対して delete を呼び出す" id="33" impl="MRM-33" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-33.rule"/>
         </rule>
         <rule header="new の戻り値をチェックする" id="34" impl="MRM-34" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-34.rule"/>
         </rule>
         <rule header="配列でないものを解放する場合、delete に空の括弧 ([]) を付けてはならない" id="35" impl="MRM-35" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-35.rule"/>
         </rule>
         <rule header="配列を解放する場合、必ず delete に空の括弧 ([]) を付ける" id="36" impl="MRM-36" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-36.rule"/>
         </rule>
         <rule header="動的にメモリを割り当てるクラスにはコピー代入演算子を宣言する" id="37" impl="MRM-37" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-37.rule"/>
         </rule>
         <rule header="メモリを動的に割り当てるクラスには、コピー コンストラクタを定義する" id="38" impl="MRM-38" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-38.rule"/>
         </rule>
         <rule header="fopen の呼び出しの直後にファイル オープン エラーの処理を置く" id="39" impl="MRM-39" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-39.rule"/>
         </rule>
         <rule header="copy と destroy は一貫して行う" id="40" impl="MRM-40" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40.rule"/>
         </rule>
         <rule header="コピー コンストラクターを宣言する場合は、コピー代入演算子を宣言するべきである (逆の場合も同様に)" id="40_a" impl="MRM-40_a" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_a.rule"/>
         </rule>
         <rule header="コピー コンストラクターとコピー代入演算子は同じ public/protected/private パーミッションを持つべきである" id="40_b" impl="MRM-40_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_b.rule"/>
         </rule>
         <rule header="非自明なコピー コンストラクターまたはコピー代入演算子がある場合、デストラクターも宣言するべきである" id="40_c" impl="MRM-40_c" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_c.rule"/>
         </rule>
         <rule header="非自明なデストラクターがあるクラスには、コピー コンストラクターおよびコピー代入演算子も宣言するべきである" id="40_d" impl="MRM-40_d" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_d.rule"/>
         </rule>
         <rule header="コピー コンストラクタは、すべてのデータ メンバと基底クラスのメンバをコピーしなければならない" id="41" impl="MRM-41" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-41.rule"/>
         </rule>
         <rule header="ポインタを使用してファイルを開いた場合は、デストラクタでポインタ メンバに対し fclose() を呼び出す" id="42" impl="MRM-42" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-42.rule"/>
         </rule>
         <rule header="代入演算子は、すべての基底データに代入しなければならない" id="43" impl="MRM-43" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-43.rule"/>
         </rule>
         <rule header="sizeof 演算子をポインタ型に使用して、malloc、calloc、realloc 関数で割り当てるメモリのサイズを指定してはならない" id="45" impl="MRM-45" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-45.rule"/>
         </rule>
         <rule header="calloc、malloc、realloc および free 関数を使用してはならない" id="46" impl="MRM-46" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-46.rule"/>
         </rule>
         <rule header="1 つ以上の非 static メンバー変数を持つクラスは、代入演算子を宣言するか、適切なコメントを記述するべきである" id="47" impl="MRM-47" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-47.rule"/>
         </rule>
         <rule header="1 つ以上の非 static メンバー変数を持つクラスは、コピー コンストラクターを宣言するか、適切なコメントを記述するべきである" id="48" impl="MRM-48" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-48.rule"/>
         </rule>
         <rule header="データ アイテムへのポインターまたはある程度の処理を行うデストラクターのあるクラスには、コピー コンストラクターおよびコピー代入演算子を宣言しなければならない" id="49" impl="MRM-49" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-49.rule"/>
         </rule>
         <rule header="コピー コンストラクターとコピー代入演算子は、両方同時に private 宣言する" id="50" impl="MRM-50" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-50.rule"/>
         </rule>
         <rule header="void 型を指すポインターに対して delete を使用してはならない" id="51" impl="MRM-51" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-51.rule"/>
         </rule>
         <rule header="RAII を使用してリソース リークを防止する" id="52" impl="MRM-52" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-52.rule"/>
         </rule>
         <rule header="ユーザー定義の new 演算子は、割り当てが失敗した場合、std::bad_alloc 例外をスローするべきである" id="53" impl="MRM-53" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-53.rule"/>
         </rule>
         <rule header="オーバーアラインされた型ではデフォルトの new 演算子の使用を避ける" id="54" impl="MRM-54" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-54.rule"/>
         </rule>
         <rule header="不適切なストレージ容量を持つポインターまたは作成されるオブジェクトに対して適切にアラインされていないポインターを配置 new に渡さない" id="55" impl="MRM-55" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-55.rule"/>
         </rule>
         <rule header="配置 new アロケーション関数にオブジェクトの配列を渡す場合、オーバーヘッドを使用するべきである" id="55_b" impl="MRM-55_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-55_b.rule"/>
         </rule>
         <rule header="コピー代入演算子は、オブジェクトのコピーに影響を与える可能性がある副作用を持つべきではない" id="56" impl="MRM-56" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-56.rule"/>
         </rule>
         <rule header="ムーブ代入演算子は、オブジェクトのムーブに影響を与える可能性がある副作用を持つべきではない" id="57" impl="MRM-57" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-57.rule"/>
         </rule>
      </category>
      <category description="名前付け規則" name="NAMING">
         <rule header="#define 定数は必ず大文字にしなければならない" id="01" impl="NAMING-01" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-01.rule"/>
         </rule>
         <rule header="列挙リストでは、リスト メンバ (要素) は大文字、リストの名前は小文字でなければならない。またリストのタグまたは名前は小文字でなければならない" id="02" impl="NAMING-02" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-02.rule"/>
         </rule>
         <rule header="ファイル名には小文字を使用する" id="03" impl="NAMING-03" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-03.rule"/>
         </rule>
         <rule header="グローバル接頭辞は、グローバル変数にだけ使うべきである" id="04" impl="NAMING-04" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-04.rule"/>
         </rule>
         <rule header="ローカル変数名は小文字で開始しなければならない" id="05" impl="NAMING-05" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-05.rule"/>
         </rule>
         <rule header="グローバル変数名は小文字で開始しなければならない" id="06" impl="NAMING-06" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-06.rule"/>
         </rule>
         <rule header="メンバ変数名は小文字で開始しなければならない" id="07" impl="NAMING-07" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-07.rule"/>
         </rule>
         <rule header="boolean 型の変数名の先頭は b にする" id="08" impl="NAMING-08" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-08.rule"/>
         </rule>
         <rule header="クラス、構造体、共用体、列挙、typedef の先頭文字は大文字にする" id="09" impl="NAMING-09" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-09.rule"/>
         </rule>
         <rule header="抽象データー型、構造体、typedef、列挙名は大文字で開始しなければならない" id="10" impl="NAMING-10" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-10.rule"/>
         </rule>
         <rule header="列挙型の名前は、大文字で開始し、接尾辞 _t で終了させなければならない" id="11" impl="NAMING-11" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-11.rule"/>
         </rule>
         <rule header="構造体の名前は、大文字で開始し、接尾辞 '_t' で終了させなければならない" id="12" impl="NAMING-12" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-12.rule"/>
         </rule>
         <rule header="const 変数名の先頭は c にする" id="13" impl="NAMING-13" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-13.rule"/>
         </rule>
         <rule header="クラス データ メンバ名の先頭は its にする" id="14" impl="NAMING-14" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-14.rule"/>
         </rule>
         <rule header="double 型の変数名の先頭は d にする" id="15" impl="NAMING-15" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-15.rule"/>
         </rule>
         <rule header="float 型の変数名の先頭は f にする" id="16" impl="NAMING-16" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-16.rule"/>
         </rule>
         <rule header="関数名の先頭は大文字にする" id="17" impl="NAMING-17" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-17.rule"/>
         </rule>
         <rule header="グローバル変数名の先頭は the にする" id="18" impl="NAMING-18" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-18.rule"/>
         </rule>
         <rule header="int 型の変数名の先頭は i にする" id="19" impl="NAMING-19" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-19.rule"/>
         </rule>
         <rule header="is 関数は bool 値を返さなくてはならない" id="20" impl="NAMING-20" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-20.rule"/>
         </rule>
         <rule header="long int 型の変数名の先頭は li にする" id="21" impl="NAMING-21" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-21.rule"/>
         </rule>
         <rule header="ポインタ変数の変数名の先頭には p を付ける" id="22" impl="NAMING-22" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-22.rule"/>
         </rule>
         <rule header="short int 型の変数名の先頭は si にする" id="23" impl="NAMING-23" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-23.rule"/>
         </rule>
         <rule header="signed char 型の変数名の先頭は c にする" id="24" impl="NAMING-24" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-24.rule"/>
         </rule>
         <rule header="終端文字の変数の先頭は sz にする" id="25" impl="NAMING-25" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-25.rule"/>
         </rule>
         <rule header="unsigned char 型の変数名の先頭は uc にする" id="26" impl="NAMING-26" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-26.rule"/>
         </rule>
         <rule header="unsigned int 型の変数の先頭は ui にする" id="27" impl="NAMING-27" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-27.rule"/>
         </rule>
         <rule header="構造体と共用体のメンバ名には小文字を使用する" id="28" impl="NAMING-28" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-28.rule"/>
         </rule>
         <rule header="scalar ではない typedef には、必ず最後に _t を付ける" id="29" impl="NAMING-29" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-29.rule"/>
         </rule>
         <rule header="C 言語の実装ファイル名には拡張子 .c を使用する" id="30" impl="NAMING-30" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-30.rule"/>
         </rule>
         <rule header="大文字小文字の違いしかない型定義名を使用してはいけない" id="31" impl="NAMING-31" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-31.rule"/>
         </rule>
         <rule header="クラスのインクルード ファイル名の形式は“クラス名+ 拡張子”にするべきである" id="32" impl="NAMING-32" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-32.rule"/>
         </rule>
         <rule header="1 つまたは 2 つのアンダースコア (_ または __) で始まる識別子を使用しない" id="33" impl="NAMING-33" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-33.rule"/>
         </rule>
         <rule header="グローバル関数名は小文字で開始しなければならない" id="34" impl="NAMING-34" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-34.rule"/>
         </rule>
         <rule header="メンバ関数名は小文字で開始しなければならない" id="35" impl="NAMING-35" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-35.rule"/>
         </rule>
         <rule header="パラメータ名は宣言と定義で一致させる" id="36" impl="NAMING-36" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-36.rule"/>
         </rule>
         <rule header="C++ のインクルード ファイルの拡張子は .hh にする" id="37" impl="NAMING-37" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-37.rule"/>
         </rule>
         <rule header="C++ の実装ファイルの拡張子は .cc にする" id="38" impl="NAMING-38" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-38.rule"/>
         </rule>
         <rule header="インライン定義ファイルの拡張子は .icc にする" id="39" impl="NAMING-39" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-39.rule"/>
         </rule>
         <rule header="クラス、構造体、名前空間、列挙型、typedef の最初の 1 文字を大文字にする" id="40" impl="NAMING-40" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-40.rule"/>
         </rule>
         <rule header="ヘッダー ファイルの拡張子は常に .h にする" id="41" impl="NAMING-41" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-41.rule"/>
         </rule>
         <rule header="定数および列挙値の識別子は小文字でなければならない" id="42" impl="NAMING-42" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-42.rule"/>
         </rule>
         <rule header="ファイル拡張子がある場合は、&quot;*.cpp&quot; または &quot;*.h&quot;でなければならない" id="43" impl="NAMING-43" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-43.rule"/>
         </rule>
         <rule header="関数および変数名はすべて小文字でなければならない" id="44" impl="NAMING-44" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-44.rule"/>
         </rule>
         <rule header="大文字/小文字の違い、アンダースコア、見た目の似た文字や数字の違いで識別子を区別してはならない" id="45" impl="NAMING-45" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-45.rule"/>
         </rule>
         <rule header="文字 '、&quot;、/* または // をヘッダー ファイル名で使用してはならない" id="46" impl="NAMING-46" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-46.rule"/>
         </rule>
         <rule header="異なる識別子は見た目にも明確に区別できなければならない" id="47" impl="NAMING-47" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-47.rule"/>
         </rule>
         <rule header="ヘッダー ファイル名に \ 文字を使用するべきではない" id="48" impl="NAMING-48" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-48.rule"/>
         </rule>
         <rule header="C++ 言語の実装ファイルには、常に拡張子 &quot;.cpp&quot; がなければならない" id="49" impl="NAMING-49" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-49.rule"/>
         </rule>
         <rule header="同じ名前空間にあり可視性が重なる識別子は見た目で明確に区別できなければならない" id="50" impl="NAMING-50" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-50.rule"/>
         </rule>
         <rule header="ユーザー定義リテラル演算子のユーザー定義の接尾辞は、アンダースコアで始まり 1 文字以上の文字が続く必要がある" id="51" impl="NAMING-51" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-51.rule"/>
         </rule>
         <rule header="ユニバーサル文字名は、文字または文字列リテラルの内部でだけ使用する" id="52" impl="NAMING-52" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-52.rule"/>
         </rule>
         <rule header="ヘッダー ファイルにはファイル拡張子  &quot;.h&quot;、&quot;.hpp&quot; または &quot;.hxx&quot; を付けるべきである" id="53" impl="NAMING-53" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-53.rule"/>
         </rule>
         <rule header="視覚的に区別しやすい識別子を使用する" id="54" impl="NAMING-54" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-54.rule"/>
         </rule>
         <category description="ハンガリー記法" name="HN">
            <rule header="配列変数およびパラメータのハンガリー記法" id="01" impl="NAMING-HN-01" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-01.rule"/>
            </rule>
            <rule header="ブール型のハンガリー記法" id="02" impl="NAMING-HN-02" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-02.rule"/>
            </rule>
            <rule header="ブール型のポインタ、配列、または参照型のハンガリー記法" id="03" impl="NAMING-HN-03" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-03.rule"/>
            </rule>
            <rule header="バイト型のハンガリー記法" id="04" impl="NAMING-HN-04" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-04.rule"/>
            </rule>
            <rule header="バイト型のポインタ、配列、参照型のハンガリー記法" id="05" impl="NAMING-HN-05" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-05.rule"/>
            </rule>
            <rule header="char 型のハンガリー記法" id="06" impl="NAMING-HN-06" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-06.rule"/>
            </rule>
            <rule header="char 型の配列のハンガリー記法" id="07" impl="NAMING-HN-07" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-07.rule"/>
            </rule>
            <rule header="char 型のポインタ、配列、配列への参照のハンガリー記法" id="08" impl="NAMING-HN-08" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-08.rule"/>
            </rule>
            <rule header="char 型のポインタ、配列、参照型のハンガリー記法" id="09" impl="NAMING-HN-09" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-09.rule"/>
            </rule>
            <rule header="char 型のポインタ、参照型のハンガリー記法" id="10" impl="NAMING-HN-10" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-10.rule"/>
            </rule>
            <rule header="const パラメータのハンガリー記法" id="11" impl="NAMING-HN-11" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-11.rule"/>
            </rule>
            <rule header="倍精度浮動小数点型のハンガリー記法" id="12" impl="NAMING-HN-12" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-12.rule"/>
            </rule>
            <rule header="倍精度浮動小数点型のポインタ、配列、参照型のハンガリー記法" id="13" impl="NAMING-HN-13" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-13.rule"/>
            </rule>
            <rule header="dword 型のハンガリー記法" id="14" impl="NAMING-HN-14" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-14.rule"/>
            </rule>
            <rule header="dwar 型のポインタ、配列、参照型のハンガリー記法" id="15" impl="NAMING-HN-15" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-15.rule"/>
            </rule>
            <rule header="動的に割り当てられた配列のハンガリー記法" id="16" impl="NAMING-HN-16" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-16.rule"/>
            </rule>
            <rule header="浮動小数点型のハンガリー記法" id="17" impl="NAMING-HN-17" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-17.rule"/>
            </rule>
            <rule header="浮動小数点型のポインタ、配列、参照型のハンガリー記法" id="18" impl="NAMING-HN-18" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-18.rule"/>
            </rule>
            <rule header="クラス宣言のハンガリー記法" id="19" impl="NAMING-HN-19" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-19.rule"/>
            </rule>
            <rule header="構造体宣言のハンガリー記法" id="20" impl="NAMING-HN-20" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-20.rule"/>
            </rule>
            <rule header="ifstream 型の変数およびパラメータのハンガリー記法" id="21" impl="NAMING-HN-21" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-21.rule"/>
            </rule>
            <rule header="int 型のハンガリー記法" id="22" impl="NAMING-HN-22" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-22.rule"/>
            </rule>
            <rule header="int 型のポインタ、配列、参照型のハンガリー記法" id="23" impl="NAMING-HN-23" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-23.rule"/>
            </rule>
            <rule header="istream 型の変数およびパラメータのハンガリー記法" id="24" impl="NAMING-HN-24" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-24.rule"/>
            </rule>
            <rule header="long int 型のハンガリー記法" id="25" impl="NAMING-HN-25" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-25.rule"/>
            </rule>
            <rule header="長倍精度浮動小数点型のハンガリー記法" id="26" impl="NAMING-HN-26" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-26.rule"/>
            </rule>
            <rule header="長倍精度浮動小数点型のポインタ、配列、参照型のハンガリー記法" id="27" impl="NAMING-HN-27" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-27.rule"/>
            </rule>
            <rule header="long int 型のポインタ、配列、参照型のハンガリー記法" id="28" impl="NAMING-HN-28" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-28.rule"/>
            </rule>
            <rule header="メンバ変数のハンガリー記法" id="29" impl="NAMING-HN-29" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-29.rule"/>
            </rule>
            <rule header="int 型のハンガリー記法" id="30" impl="NAMING-HN-30" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-30.rule"/>
            </rule>
            <rule header="int 型のポインタ、配列、参照型のハンガリー記法" id="31" impl="NAMING-HN-31" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-31.rule"/>
            </rule>
            <rule header="ofstream 型の変数およびパラメータのハンガリー記法" id="32" impl="NAMING-HN-32" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-32.rule"/>
            </rule>
            <rule header="ostream 型の変数およびパラメータのハンガリー記法" id="33" impl="NAMING-HN-33" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-33.rule"/>
            </rule>
            <rule header="ポインタのハンガリー記法" id="34" impl="NAMING-HN-34" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-34.rule"/>
            </rule>
            <rule header="参照ポインタのハンガリー記法" id="35" impl="NAMING-HN-35" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-35.rule"/>
            </rule>
            <rule header="shor int 型のハンガリー記法" id="36" impl="NAMING-HN-36" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-36.rule"/>
            </rule>
            <rule header="shor int 型のポインタ、配列、参照型のハンガリー記法" id="37" impl="NAMING-HN-37" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-37.rule"/>
            </rule>
            <rule header="静的変数のハンガリー記法" id="38" impl="NAMING-HN-38" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-38.rule"/>
            </rule>
            <rule header="string 型のハンガリー記法" id="39" impl="NAMING-HN-39" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-39.rule"/>
            </rule>
            <rule header="string 型のポインタ、配列、参照型のハンガリー記法" id="40" impl="NAMING-HN-40" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-40.rule"/>
            </rule>
            <rule header="unsigned 型のハンガリー記法" id="41" impl="NAMING-HN-41" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-41.rule"/>
            </rule>
            <rule header="void ポインタ型のハンガリー記法" id="42" impl="NAMING-HN-42" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-42.rule"/>
            </rule>
            <rule header="word 型のハンガリー記法" id="43" impl="NAMING-HN-43" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-43.rule"/>
            </rule>
            <rule header="word 型のポインタ、配列、参照型のハンガリー記法" id="44" impl="NAMING-HN-44" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-44.rule"/>
            </rule>
         </category>
      </category>
      <category description="オブジェクト指向" name="OOP">
         <rule header="基底クラスでは、public コピー コンストラクターおよび代入演算子を避ける" id="01" impl="OOP-01" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-01.rule"/>
         </rule>
         <rule header="スライシングを避ける。基底クラスでのコピーの代わりにクローンを使用する" id="02" impl="OOP-02" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-02.rule"/>
         </rule>
         <rule header="仮想継承を除いて、クラスは他のクラスを 2 回以上継承してはならない" id="03" impl="OOP-03" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-03.rule"/>
         </rule>
         <rule header="2 つ以上の基底クラスから同じ名前の関数を継承しない" id="04" impl="OOP-04" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-04.rule"/>
         </rule>
         <rule header="多重継承を使ってはいけない" id="05" impl="OOP-05" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-05.rule"/>
         </rule>
         <rule header="多重継承では仮想共通基底クラスを使用する" id="06" impl="OOP-06" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-06.rule"/>
         </rule>
         <rule header="抽象インターフェイスでないクラスの多重継承に注意する" id="07" impl="OOP-07" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-07.rule"/>
         </rule>
         <rule header="多重継承は最大でも 1 つの protected 実装に制限する" id="07_a" impl="OOP-07_a" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_a.rule"/>
         </rule>
         <rule header="多重継承では、public 実装を使用しない" id="07_b" impl="OOP-07_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_b.rule"/>
         </rule>
         <rule header="コンストラクタから直接グローバル データにアクセスしてはいけない" id="08" impl="OOP-08" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-08.rule"/>
         </rule>
         <rule header="デストラクタでのグローバルオブジェクトの使用を避ける" id="09" impl="OOP-09" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-09.rule"/>
         </rule>
         <rule header="メンバ関数でグローバル データを使用しない" id="10" impl="OOP-10" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-10.rule"/>
         </rule>
         <rule header="フレンド メカニズムを使用してはいけない" id="11" impl="OOP-11" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-11.rule"/>
         </rule>
         <rule header="protected メンバー関数は private クラス データへの const ではないハンドルを返してはならない" id="12" impl="OOP-12" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-12.rule"/>
         </rule>
         <rule header="継承された仮想関数を別のデフォルト パラメーター値で再定義してはならない" id="13" impl="OOP-13" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-13.rule"/>
         </rule>
         <rule header="private 継承ではなくコンポジションを使用する" id="14" impl="OOP-14" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-14.rule"/>
         </rule>
         <rule header="コンストラクターから仮想関数を呼び出してはいけない" id="16" impl="OOP-16" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16.rule"/>
         </rule>
         <rule header="デストラクターから仮想関数を呼び出してはいけない" id="16_b" impl="OOP-16_b" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16_b.rule"/>
         </rule>
         <rule header="オーバーロードされた関数を再宣言する場合、using 宣言を使用する" id="17" impl="OOP-17" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-17.rule"/>
         </rule>
         <rule header="public データ メンバを使用しない" id="18" impl="OOP-18" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-18.rule"/>
         </rule>
         <rule header="protected データ メンバは使用しない" id="19" impl="OOP-19" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-19.rule"/>
         </rule>
         <rule header="派生クラスから基底クラスへの明示的キャストを避ける" id="20" impl="OOP-20" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-20.rule"/>
         </rule>
         <rule header="サブクラスで仮想関数を実装する場合は virtual キーワードを使用する" id="21" impl="OOP-21" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-21.rule"/>
         </rule>
         <rule header="基底クラスとして使用され仮想関数を持つクラスに仮想デストラクタを定義する" id="22" impl="OOP-22" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-22.rule"/>
         </rule>
         <rule header="クラスに仮想関数がある場合、仮想デストラクタがなければならない" id="23" impl="OOP-23" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-23.rule"/>
         </rule>
         <rule header="基底クラスではデストラクタを仮想にする" id="24" impl="OOP-24" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-24.rule"/>
         </rule>
         <rule header="仮想関数をインライン化しない" id="25" impl="OOP-25" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-25.rule"/>
         </rule>
         <rule header="派生クラスのオブジェクトへのポインタを、仮想基底クラスのオブジェクトへのポインタに変換してはならない" id="26" impl="OOP-26" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-26.rule"/>
         </rule>
         <rule header="参照または const メンバを持つクラスのコピー代入演算子を宣言する" id="27" impl="OOP-27" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-27.rule"/>
         </rule>
         <rule header="継承階層をダウンキャストしてはいけない" id="28" impl="OOP-28" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-28.rule"/>
         </rule>
         <rule header="抽象クラスへのポインタを、そのクラスを継承しているクラスへのポインタに変換してはいけない" id="29" impl="OOP-29" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-29.rule"/>
         </rule>
         <rule header="コピーコンストラクタとコピー代入演算子を private に宣言した基底クラスをつくる" id="30" impl="OOP-30" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-30.rule"/>
         </rule>
         <rule header="基底クラスのデストラクタを public かつ仮想、または protected かつ非仮想にする" id="31" impl="OOP-31" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-31.rule"/>
         </rule>
         <rule header="継承された非仮想関数を再定義してはいけない" id="32" impl="OOP-32" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-32.rule"/>
         </rule>
         <rule header="テンプレート パラメーターを持つ継承された非仮想関数を再定義してはいけない" id="33" impl="OOP-33" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-33.rule"/>
         </rule>
         <rule header="operator= での自分自身への代入をチェックする" id="34" impl="OOP-34" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-34.rule"/>
         </rule>
         <rule header="ダウンキャスト (基底クラスから派生クラスへのキャスト) を許可してはいけない" id="35" impl="OOP-35" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-35.rule"/>
         </rule>
         <rule header="public メンバー関数は private/protected クラス データへの const ではないハンドルを返してはならない" id="36" impl="OOP-36" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-36.rule"/>
         </rule>
         <rule header="継承が必要ない場合、合成を使用する" id="37" impl="OOP-37" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-37.rule"/>
         </rule>
         <rule header="仮想関数があるクラスのデストラクタが呼び出される場合、クラスは仮想デストラクタを持つべきである" id="38" impl="OOP-38" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-38.rule"/>
         </rule>
         <rule header="仮想基底クラスは、派生クラスで明示的に宣言する" id="39" impl="OOP-39" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-39.rule"/>
         </rule>
         <rule header="状態を持つ仮想基底クラスは、クラスにアクセスする派生クラスで明示的に宣言する" id="39_b" impl="OOP-39_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-39_b.rule"/>
         </rule>
         <rule header="抽象クラスから階層を開始する" id="40" impl="OOP-40" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-40.rule"/>
         </rule>
         <rule header="同じ階層の中で、基底クラスを仮想と非仮想の両方にすることはできない" id="41" impl="OOP-41" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-41.rule"/>
         </rule>
         <rule header="抽象クラスではコピー代入演算子を protected または private として宣言する" id="42" impl="OOP-42" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-42.rule"/>
         </rule>
         <rule header="純粋仮想関数として宣言された仮想関数だけを純粋仮想関数によってオーバーライドできる" id="43" impl="OOP-43" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-43.rule"/>
         </rule>
         <rule header="継承階層のすべてのパスで各仮想関数に複数の定義があってはならない" id="44" impl="OOP-44" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-44.rule"/>
         </rule>
         <rule header="基本型の 1 つの引数で呼び出せるすべてのコンストラクタを explicit として宣言する" id="45" impl="OOP-45" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-45.rule"/>
         </rule>
         <rule header="コピー コンストラクタは基底クラスと自身がメンバであるクラスの静的でないメンバの初期化だけを行う" id="46" impl="OOP-46" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-46.rule"/>
         </rule>
         <rule header="仮想基底クラスからクラスを派生するべきではない" id="47" impl="OOP-47" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-47.rule"/>
         </rule>
         <rule header="非 POD 型のメンバー データは private でなければならない" id="48" impl="OOP-48" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-48.rule"/>
         </rule>
         <rule header="ポリモーフィックな型で基底クラスから派生クラスへのキャストを行うべきではない" id="49" impl="OOP-49" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-49.rule"/>
         </rule>
         <rule header="仮想基底クラスへのポインタは dynamic_cast によってだけ派生クラスへのポインタにキャストできる" id="50" impl="OOP-50" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-50.rule"/>
         </rule>
         <rule header="static 関数だけを含むクラスまたは構造体の代わりに名前空間を使用する" id="51" impl="OOP-51" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-51.rule"/>
         </rule>
         <rule header="クラスへのポインターを派生クラス以外の別のクラスへのポインターに変換してはならない" id="52" impl="OOP-52" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-52.rule"/>
         </rule>
         <rule header="派生クラスで宣言されたメンバー関数は、基底クラスで宣言された関数を隠してはならない" id="53" impl="OOP-53" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-53.rule"/>
         </rule>
         <rule header="オーバーライドされたメソッドまたは隠されたメソッドのアクセシビリティを引き上げてはならない" id="54" impl="OOP-54" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-54.rule"/>
         </rule>
         <rule header="非 POD 型はクラスとして定義するべきである" id="55" impl="OOP-55" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-55.rule"/>
         </rule>
         <rule header="ユーザー定義の代入演算子は virtual であってはならない" id="56" impl="OOP-56" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-56.rule"/>
         </rule>
         <rule header="構造体には、public データ メンバーだけを含めるべきであり、基底であったり継承を行ったりするべきではない" id="57" impl="OOP-57" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-57.rule"/>
         </rule>
      </category>
      <category description="最適化" name="OPT">
         <rule header="変数をできるかぎり局所的に宣言する" id="01" impl="OPT-01" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-01.rule"/>
         </rule>
         <rule header="使用されないローカル変数は避ける" id="02" impl="OPT-02" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-02.rule"/>
         </rule>
         <rule header="使用されないパラメータは削除する" id="03" impl="OPT-03" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-03.rule"/>
         </rule>
         <rule header="++ および -- の標準形式の推奨。前置形式の呼び出しを使用する" id="04" impl="OPT-04" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-04.rule"/>
         </rule>
         <rule header="使用されない private メンバ変数は削除する" id="05" impl="OPT-05" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-05.rule"/>
         </rule>
         <rule header="不要なローカル変数を避ける" id="06" impl="OPT-06" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-06.rule"/>
         </rule>
         <rule header="@が +、-、*、/、% である場合、a = a @ b ではなく a @= b を使用する" id="07" impl="OPT-07" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-07.rule"/>
         </rule>
         <rule header="@が &amp;、|、^、&lt;&lt;、&gt;&gt; である場合、a = a @ b ではなく a @= b を使用する" id="08" impl="OPT-08" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-08.rule"/>
         </rule>
         <rule header="不要な == true を削除する" id="09" impl="OPT-09" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-09.rule"/>
         </rule>
         <rule header="if、for、while、do while 文の中で変数を宣言しない" id="10" impl="OPT-10" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-10.rule"/>
         </rule>
         <rule header="ファイル レベルの静的変数が 1 つの関数でだけ使用または参照される場合、変数を関数の一部とする" id="11" impl="OPT-11" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-11.rule"/>
         </rule>
         <rule header="ファイル レベルの静的変数が、1 つのクラスでだけ使用または参照される場合、変数をクラスの一部とする" id="12" impl="OPT-12" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-12.rule"/>
         </rule>
         <rule header="メンバ変数を大きさの降順に宣言する" id="13" impl="OPT-13" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-13.rule"/>
         </rule>
         <rule header="値ではなく参照でオブジェクトを渡す" id="14" impl="OPT-14" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-14.rule"/>
         </rule>
         <rule header="暗黙的な型変換を避けるため、オーバーロードを使用する" id="15" impl="OPT-15" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-15.rule"/>
         </rule>
         <rule header="再帰、ループ、仮想関数の呼び出しを含むグローバル関数をインライン化してはならない" id="16" impl="OPT-16" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-16.rule"/>
         </rule>
         <rule header="コンストラクタおよびデストラクタをインライン化してはならない" id="17" impl="OPT-17" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-17.rule"/>
         </rule>
         <rule header="再帰またはループを含むメンバー関数をインライン化してはならない" id="18" impl="OPT-18" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-18.rule"/>
         </rule>
         <rule header="単独の op ではなく op= の使用を推奨する" id="19" impl="OPT-19" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-19.rule"/>
         </rule>
         <rule header="変数の定義は可能な限り先延ばしする" id="20" impl="OPT-20" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-20.rule"/>
         </rule>
         <rule header="すべての switch 文に空ではない case 句が 1 つ以上なければならない" id="21" impl="OPT-21" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-21.rule"/>
         </rule>
         <rule header="意味のない case 文は許されない" id="22" impl="OPT-22" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-22.rule"/>
         </rule>
         <rule header="小さいアクセサ関数やミューテータ関数はインラインにする" id="23" impl="OPT-23" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-23.rule"/>
         </rule>
         <rule header="小さいフォワード関数はインラインにする" id="24" impl="OPT-24" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-24.rule"/>
         </rule>
         <rule header="文の数が 1 つか 2 つの関数だけをインライン関数にする" id="25" impl="OPT-25" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-25.rule"/>
         </rule>
         <rule header="意味のある値で初期化できる時まで、変数を宣言しない" id="26" impl="OPT-26" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-26.rule"/>
         </rule>
         <rule header="アクセサおよびミューテータの数を最小にする" id="27" impl="OPT-27" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-27.rule"/>
         </rule>
         <rule header="strlen 関数を使用して文字列が NULL か NULL 以外かをチェックしてはならない" id="28" impl="OPT-28" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-28.rule"/>
         </rule>
         <rule header="同じ型への冗長なキャストを行わない" id="29" impl="OPT-29" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-29.rule"/>
         </rule>
         <rule header="内部リンケージを持つ定義されたすべての関数は少なくとも 1 度は使用されなければならない" id="30" impl="OPT-30" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-30.rule"/>
         </rule>
         <rule header="virtual でない関数には使用されない名前付きまたは無名のパラメータがあってはならない" id="31" impl="OPT-31" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-31.rule"/>
         </rule>
         <rule header="void 型の戻り値を持つ空ではないすべての関数には外部的な副作用がなければならない" id="32" impl="OPT-32" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-32.rule"/>
         </rule>
         <rule header="void 型の戻り値を持つ関数は空であってはならない" id="32_b" impl="OPT-32_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-32_b.rule"/>
         </rule>
         <rule header="オブジェクトを値ではなく参照で返すことを検討する" id="33" impl="OPT-33" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-33.rule"/>
         </rule>
         <rule header="変数を自分自身に代入してはならない" id="35" impl="OPT-35" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-35.rule"/>
         </rule>
         <rule header="変数の初期化子の中で自分自身を使用してはならない" id="36" impl="OPT-36" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-36.rule"/>
         </rule>
         <rule header="関数は未使用のラベル宣言を持つべきではない" id="37" impl="OPT-37" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-37.rule"/>
         </rule>
         <rule header="関数に未使用のパラメーターがあってはならない" id="38" impl="OPT-38" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-38.rule"/>
         </rule>
         <rule header="switch 文には少なくとも 2 個の switch 句がなければならない" id="39" impl="OPT-39" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-39.rule"/>
         </rule>
         <rule header="if-else-if 連鎖の 2 つのブランチに (プリプロセス後の状態で) 同一のコードがある" id="40_a" impl="OPT-40_a" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_a.rule"/>
         </rule>
         <rule header="switch 文の複数の句に (プリプロセス後の状態で) 同一のコードがある" id="40_b" impl="OPT-40_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_b.rule"/>
         </rule>
         <rule header="ファイルは、そのファイルをコンパイルするのに必要な宣言および定義を含むヘッダーだけを直接的にインクルードするべきである" id="41" impl="OPT-41" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-41.rule"/>
         </rule>
         <rule header="仮想関数に未使用の名前付きパラメーターがあってはならない" id="42" impl="OPT-42" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-42.rule"/>
         </rule>
      </category>
      <category description="バグの可能性" name="PB">
         <rule header="ポインタ型の式の間接参照を行ってはならない" id="01" impl="PB-01" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-01.rule"/>
         </rule>
         <rule header="a(b)、a[b]、キャストの中で代入を使用しない" id="02" impl="PB-02" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-02.rule"/>
         </rule>
         <rule header="3 項演算子で型を混合させてはならない" id="03" impl="PB-03" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-03.rule"/>
         </rule>
         <rule header="関数の戻り値は宣言された型と一致しなければならない" id="05" impl="PB-05" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-05.rule"/>
         </rule>
         <rule header="代入演算子のオペランドの型には互換性がなければならない" id="06" impl="PB-06" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-06.rule"/>
         </rule>
         <rule header="関数の戻り値を互換性のない型の変数に代入してはならない" id="07" impl="PB-07" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-07.rule"/>
         </rule>
         <rule header="符号付き定数を符号なし整数変数に代入してはならない" id="08" impl="PB-08" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-08.rule"/>
         </rule>
         <rule header="演算子は値を参照で返してはならない" id="09" impl="PB-09" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-09.rule"/>
         </rule>
         <rule header="配列をポリモーフィックに処理しない" id="10" impl="PB-10" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-10.rule"/>
         </rule>
         <rule header="関数の仮引数と実引数の宣言型は一致しなければならない" id="11" impl="PB-11" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-11.rule"/>
         </rule>
         <rule header="signed char を unsigned int にキャストしてはいけない" id="12" impl="PB-12" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-12.rule"/>
         </rule>
         <rule header="非ポインタに対して delete を呼び出してはいけない" id="13" impl="PB-13" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-13.rule"/>
         </rule>
         <rule header="不正な End-Of-String (EOS) 定義" id="14" impl="PB-14" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-14.rule"/>
         </rule>
         <rule header="2 つの整数型の除算の結果を浮動小数点型に代入してはいけない" id="15" impl="PB-15" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15.rule"/>
         </rule>
         <rule header="整数の除算の剰余が意図せず破棄されるのを防ぐ" id="15_b" impl="PB-15_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15_b.rule"/>
         </rule>
         <rule header="char 型の範囲を超えた定数は避ける" id="16" impl="PB-16" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-16.rule"/>
         </rule>
         <rule header="unsigned char 型の範囲を超えた定数は避ける" id="17" impl="PB-17" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-17.rule"/>
         </rule>
         <rule header="ポインタおよび数値型でクラス メソッドをオーバーロードすることを避ける" id="18" impl="PB-18" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-18.rule"/>
         </rule>
         <rule header="ローカルな静的データを含むインライン非メンバ関数を作成しない" id="19" impl="PB-19" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-19.rule"/>
         </rule>
         <rule header="関数引数および戻り値のスライシングを避ける" id="20" impl="PB-20" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-20.rule"/>
         </rule>
         <rule header="適切に文字列を終了させる" id="21" impl="PB-21" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-21.rule"/>
         </rule>
         <rule header="a(b)、a[b]、キャストの中でインクリメント式およびデクリメント式を使用しない" id="22" impl="PB-22" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-22.rule"/>
         </rule>
         <rule header="クラスに静的でないポインタがあり、コピー コンストラクタが宣言されていない場合、クラスのオブジェクトを参照で渡さなければならない" id="23" impl="PB-23" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-23.rule"/>
         </rule>
         <rule header="コンストラクターは、暗黙に定義されたコピー コンストラクターと同じシグネチャになるデフォルト引数を定義してはならない" id="24" impl="PB-24" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-24.rule"/>
         </rule>
         <rule header="符号なしの算術を使用してはならない" id="25" impl="PB-25" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-25.rule"/>
         </rule>
         <rule header="クラスのコンストラクタから public および protected メソッドを呼び出してはならない" id="26" impl="PB-26" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-26.rule"/>
         </rule>
         <rule header="文字列リテラルを変更してはならない" id="27" impl="PB-27" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-27.rule"/>
         </rule>
         <rule header="次の文字群はヘッダー ファイル名に出現してはならない: '、\、/*、//、&quot;" id="28" impl="PB-28" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-28.rule"/>
         </rule>
         <rule header="右シフト演算の左辺のオペランドは負数であってはならない" id="29" impl="PB-29" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-29.rule"/>
         </rule>
         <rule header="複数の列挙型を switch 条件または case 文のラベルとして使用してはならない" id="30" impl="PB-30" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-30.rule"/>
         </rule>
         <rule header="定数で sizeof を呼び出してはならない" id="31" impl="PB-31" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-31.rule"/>
         </rule>
         <rule header="ポインタ型で sizeof を呼び出してはならない" id="32" impl="PB-32" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-32.rule"/>
         </rule>
         <rule header="列挙型を含む代入での暗黙の型変換を避ける" id="33" impl="PB-33" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33.rule"/>
         </rule>
         <rule header="列挙型を含む比較での暗黙の型変換を避ける" id="33_b" impl="PB-33_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33_b.rule"/>
         </rule>
         <rule header="memcpy/strncpy/memmove の 3 番目のパラメータは 2 番目のパラメータに依存してはならない" id="34" impl="PB-34" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-34.rule"/>
         </rule>
         <rule header="条件文で括弧なしに代入演算子を使用してはならない" id="35" impl="PB-35" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-35.rule"/>
         </rule>
         <rule header="コンストラクタまたはデストラクタの本体からオブジェクトの動的な型を使用してはならない" id="36" impl="PB-36" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-36.rule"/>
         </rule>
         <rule header="&lt;cstring&gt; ライブラリの無制限の関数を使用してはならない" id="37" impl="PB-37" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-37.rule"/>
         </rule>
         <rule header="ナロー文字列リテラルとワイド文字列リテラルを連結してはならない" id="38" impl="PB-38" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38.rule"/>
         </rule>
         <rule header="エンコーディング接頭辞が異なる文字列リテラルを結合してはならない" id="38_b" impl="PB-38_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38_b.rule"/>
         </rule>
         <rule header="関数は参照または const 参照によって渡されたパラメータへの参照またはポインタを返してはならない" id="39" impl="PB-39" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39.rule"/>
         </rule>
         <rule header="関数は const 参照によって渡されたパラメータへの参照またはポインタを返してはならない" id="39_b" impl="PB-39_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39_b.rule"/>
         </rule>
         <rule header="関数への引数として渡される配列型の識別子をポインタに変化させてはならない" id="41" impl="PB-41" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41.rule"/>
         </rule>
         <rule header="ポインター型または配列型のパラメーターを持つ関数に配列型の式を渡してはならない" id="41_b" impl="PB-41_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41_b.rule"/>
         </rule>
         <rule header="オブジェクトを重複するオブジェクトに代入してはならない" id="42" impl="PB-42" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-42.rule"/>
         </rule>
         <rule header="クラスのすべてのコンストラクタは明示的に直接の基底クラスおよびすべての仮想基底クラスのコンストラクタを呼び出すべきである" id="43" impl="PB-43" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-43.rule"/>
         </rule>
         <rule header="'std::atexit()' または 'std::at_quick_exit()' で登録された関数の実行は、例外によって終了すべきではない" id="44" impl="PB-44" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-44.rule"/>
         </rule>
         <rule header="文字列書式関数の呼び出しで、書式文字列の '%s' または '%c' 書式指定子と対応する引数の間に不整合があってはならない" id="45" impl="PB-45" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-45.rule"/>
         </rule>
         <rule header="文字列書式関数の呼び出しで、書式文字列の '%f' 書式指定子と対応する引数の間に不整合があってはならない" id="46" impl="PB-46" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-46.rule"/>
         </rule>
         <rule header="文字列書式関数の呼び出しで、書式文字列の '%i' および '%d' 書式指定子と対応する引数の間に不整合があってはならない" id="47" impl="PB-47" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-47.rule"/>
         </rule>
         <rule header="文字列書式関数の呼び出しで、書式文字列の '%u' 書式指定子と対応する引数の間に不整合があってはならない" id="48" impl="PB-48" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-48.rule"/>
         </rule>
         <rule header="文字列書式関数の呼び出しで、書式文字列の '%p' 書式指定子と対応する引数の間に不整合があってはならない" id="49" impl="PB-49" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-49.rule"/>
         </rule>
         <rule header="文字列書式関数の呼び出しで、書式文字列中の書式指定子の数と対応する引数の数は同じでなければならない" id="50" impl="PB-50" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-50.rule"/>
         </rule>
         <rule header="非配列型を扱うポインタにポインタ算術を適用してはならない" id="51" impl="PB-51" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-51.rule"/>
         </rule>
         <rule header="ポインタおよび数値型でグローバル関数をオーバーロードすることを避ける" id="52" impl="PB-52" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-52.rule"/>
         </rule>
         <rule header="ポインタおよび数値型で名前空間の関数をオーバーロードすることを避ける" id="53" impl="PB-53" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-53.rule"/>
         </rule>
         <rule header="キャストの時点で不完全なクラスから、またはそのようなクラスへ、キャストしてはならない" id="54" impl="PB-54" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-54.rule"/>
         </rule>
         <rule header="削除の時点で不完全なオブジェクトを削除してはならない" id="55" impl="PB-55" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-55.rule"/>
         </rule>
         <rule header="signed 型から unsigned 型への暗黙の変換を避ける" id="56" impl="PB-56" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-56.rule"/>
         </rule>
         <rule header="派生クラス オブジェクトの配列を指すポインターを、基底クラスのポインターに変換してはいけない" id="57" impl="PB-57" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-57.rule"/>
         </rule>
         <rule header="列挙子リストで、非明示的に指定された列挙定数の値は一意でなければならない" id="58" impl="PB-58" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-58.rule"/>
         </rule>
         <rule header="文字列配列の初期化にカンマがない" id="59" impl="PB-59" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-59.rule"/>
         </rule>
         <rule header="malloc への疑わしい引数" id="60" impl="PB-60" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-60.rule"/>
         </rule>
         <rule header="割り当てられたばかりのメモリに対してポインター算術演算が行われている" id="61" impl="PB-61" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-61.rule"/>
         </rule>
         <rule header="誤った引数の順序で関数を呼び出さない" id="62" impl="PB-62" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-62.rule"/>
         </rule>
         <rule header="関数のアドレスとゼロを比較するべきではない" id="63" impl="PB-63" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-63.rule"/>
         </rule>
         <rule header="文字列比較関数から返された値はゼロとだけ比較するべきである" id="64" impl="PB-64" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-64.rule"/>
         </rule>
         <rule header="結果がより広い整数型に代入されている式での整数オーバーフローの可能性を避ける" id="65" impl="PB-65" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65.rule"/>
         </rule>
         <rule header="結果がより広い整数型の式と比較されている式での整数オーバーフローの可能性を避ける" id="65_b" impl="PB-65_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65_b.rule"/>
         </rule>
         <rule header="'+', '-', '*' 演算子の定数式における整数オーバーフローまたはアンダーフロー" id="66_a" impl="PB-66_a" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-66_a.rule"/>
         </rule>
         <rule header="'&lt;&lt;' 演算子の定数式における整数オーバーフローまたはアンダーフロー" id="66_b" impl="PB-66_b" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-66_b.rule"/>
         </rule>
         <rule header="if-else 文の 2 つのブランチに (プリプロセス後の状態で) 同一のコードがある" id="67" impl="PB-67" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-67.rule"/>
         </rule>
         <rule header="列挙型にゼロ定数だけ、またはゼロ以外の定数だけしかないために、常に同じ値に評価されるブール条件" id="68" impl="PB-68" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-68.rule"/>
         </rule>
         <rule header="オブジェクトの要素を複数回初期化してはならない" id="69" impl="PB-69" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-69.rule"/>
         </rule>
         <rule header="列挙型を潜在型とする式は、列挙型の列挙子に対応する値だけを持つことができる" id="70" impl="PB-70" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-70.rule"/>
         </rule>
         <rule header="フレキシブルな配列メンバーを含む構造体のインスタンスをコピーしない" id="71" impl="PB-71" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-71.rule"/>
         </rule>
         <rule header="誤った型の引数を指定して va_arg を呼び出さない" id="72" impl="PB-72" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-72.rule"/>
         </rule>
         <rule header="符号なし整数定数式の評価はラップアラウンドするべきではない" id="73" impl="PB-73" quickfix="false" scope="line" severity="5">
            <file path="PB\PB-73.rule"/>
         </rule>
         <rule header="1 より大きい値の定数をイテレーターに加算またはイテレーターから減算してはならない" id="74" impl="PB-74" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-74.rule"/>
         </rule>
         <rule header="stdlib.h または cstdlib ライブラリの abort() 関数を使用しない" id="75" impl="PB-75" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75.rule"/>
         </rule>
         <rule header="stdlib.h または cstdlib ライブラリの exit() 関数を使用しない" id="75_b" impl="PB-75_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75_b.rule"/>
         </rule>
         <rule header="stdlib.h または cstdlib ライブラリの関数 quick_exit() および _Exit() は使用してはならない" id="75_c" impl="PB-75_c" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75_c.rule"/>
         </rule>
         <rule header="C スタイルの文字列を使用してはならない" id="76" impl="PB-76" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-76.rule"/>
         </rule>
         <rule header="式文は、一時オブジェクトのコンストラクターの明示的な呼び出しだけを含むべきではない" id="77" impl="PB-77" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-77.rule"/>
         </rule>
      </category>
      <category description="物理ファイル編成" name="PFO">
         <rule header="リンケージを持つ実体をヘッダー ファイルに定義しない" id="01" impl="PFO-01" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-01.rule"/>
         </rule>
         <rule header="多重インクルード ガードを使用する" id="02" impl="PFO-02" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-02.rule"/>
         </rule>
         <rule header="インクルード ファイルには 2 つ以上クラス定義があってはならない" id="03" impl="PFO-03" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-03.rule"/>
         </rule>
         <rule header="各実装ファイルは、ファイルを説明するローカル定数文字列を宣言しなければならない" id="04" impl="PFO-04" quickfix="false" scope="line" severity="5">
            <file path="PFO\PFO-04.rule"/>
         </rule>
         <rule header=".c ファイルに他の .c ファイルをインクルードしてはならない" id="05" impl="PFO-05" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-05.rule"/>
         </rule>
         <rule header=".icc ファイルに別のファイルをインクルードしてはいけない" id="06" impl="PFO-06" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-06.rule"/>
         </rule>
         <rule header="ヘッダー ファイル名に基づいたパターンの多重インクルード ガードを使用する" id="07" impl="PFO-07" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-07.rule"/>
         </rule>
         <rule header="多重インクルードを防ぐメカニズムとしてインクルード ガードまたは #pragma once プリプロセッサ命令を使用する" id="08" impl="PFO-08" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-08.rule"/>
         </rule>
         <rule header="&quot;#pragma once&quot; プリプロセッサ命令をソース ファイルで使用してはならない" id="09" impl="PFO-09" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-09.rule"/>
         </rule>
      </category>
      <category description="移植性" name="PORT">
         <rule header="long 型を指示するには、小文字の l ではなく大文字の L を使用する" id="01" impl="PORT-01" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-01.rule"/>
         </rule>
         <rule header="int 型の演算の結果を long 型に代入する場合、演算の前に少なくとも 1 つの int をlong にキャストするべきである" id="02" impl="PORT-02" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-02.rule"/>
         </rule>
         <rule header="構造体で、オフセットのハード コーディング値を使用してはいけない" id="03" impl="PORT-03" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-03.rule"/>
         </rule>
         <rule header="16 進定数 '0xffffffff' をエラーのマーカーとして使用してはならない" id="04" impl="PORT-04" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-04.rule"/>
         </rule>
         <rule header="long へのポインタはint へのポインタにキャストするべきでない" id="05" impl="PORT-05" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-05.rule"/>
         </rule>
         <rule header="long int を int に代入してはならない" id="06" impl="PORT-06" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-06.rule"/>
         </rule>
         <rule header="関数呼び出しで int にキャストした long を渡してはならない" id="07" impl="PORT-07" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-07.rule"/>
         </rule>
         <rule header="long への定数の代入は、整数リテラルを含むべきではない" id="08" impl="PORT-08" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-08.rule"/>
         </rule>
         <rule header="long int 型を int 型リテラルで初期化してはならない" id="10" impl="PORT-10" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-10.rule"/>
         </rule>
         <rule header="int のポインタを long のポインタにキャストしてはならない" id="11" impl="PORT-11" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-11.rule"/>
         </rule>
         <rule header="32-bit の乗算の結果を long の値に代入してはならない" id="12" impl="PORT-12" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-12.rule"/>
         </rule>
         <rule header="int 型を常に unsigned int または signed int として宣言する" id="13" impl="PORT-13" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-13.rule"/>
         </rule>
         <rule header="より短い型からより長い型に型変換しないよう注意する" id="14" impl="PORT-14" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-14.rule"/>
         </rule>
         <rule header="より短い型からより長い型に型変換しないよう注意する" id="15" impl="PORT-15" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-15.rule"/>
         </rule>
         <rule header="より短い型からより長い型に型変換しないよう注意する" id="16" impl="PORT-16" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-16.rule"/>
         </rule>
         <rule header="i64 または L サフィックスを直接使用してはいけない" id="17" impl="PORT-17" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-17.rule"/>
         </rule>
         <rule header="式の long 型のオペランドをキャストするのではなく、式の結果をキャストする" id="19" impl="PORT-19" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-19.rule"/>
         </rule>
         <rule header="long 型の変数を直接宣言してはならない" id="20" impl="PORT-20" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-20.rule"/>
         </rule>
         <rule header="long の値を double に代入してはならない" id="21" impl="PORT-21" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-21.rule"/>
         </rule>
         <rule header="long 型の大きな配列の代わりに int 型の配列を使用する" id="22" impl="PORT-22" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-22.rule"/>
         </rule>
         <rule header="long 型の大きな動的配列の代わりに int 型の配列を使用する" id="23" impl="PORT-23" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-23.rule"/>
         </rule>
         <rule header="bool、char、short、int および float 型へのポインタの大きな配列を使用しない" id="24" impl="PORT-24" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-24.rule"/>
         </rule>
         <rule header="識別子の名前は 64 文字を超えるべきではない" id="25" impl="PORT-25" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-25.rule"/>
         </rule>
         <rule header="アクセス指定子によって分けられた非静的データ メンバの割り当ての順序について、アルゴリズムは仮定を設けてはならない" id="26" impl="PORT-26" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-26.rule"/>
         </rule>
         <rule header="より狭い型への暗黙の変換を避ける" id="27" impl="PORT-27" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-27.rule"/>
         </rule>
         <rule header="定数値のより狭い型への変換を避ける" id="28" impl="PORT-28" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-28.rule"/>
         </rule>
         <rule header="データをファイルに書き込む関数に構造体へのポインターを渡すべきではない" id="29" impl="PORT-29" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-29.rule"/>
         </rule>
         <rule header="実行境界を越えて例外をスローしてはならない" id="30" impl="PORT-30" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-30.rule"/>
         </rule>
         <rule header="実行境界を越えて非標準レイアウト型のオブジェクトを渡してはならない" id="31" impl="PORT-31" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-31.rule"/>
         </rule>
         <rule header="long double 型を使用してはならない" id="32" impl="PORT-32" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-32.rule"/>
         </rule>
         <rule header="wchar_t 型を使用してはならない" id="33" impl="PORT-33" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-33.rule"/>
         </rule>
         <rule header="ユーザー定義の C++ 外部識別子は、 先頭から 64 文字目までに違いがあるべきである" id="34_a" impl="PORT-34_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_a.rule"/>
         </rule>
         <rule header="ユーザー定義の C++ 内部識別子は、外部識別子と先頭から 64 文字目までに違いがあるべきである" id="34_b" impl="PORT-34_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_b.rule"/>
         </rule>
         <rule header="同一スコープで宣言されたユーザー定義の C++ 内部識別子は、先頭から 64 文字目までに違いがあるべきである" id="34_c" impl="PORT-34_c" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_c.rule"/>
         </rule>
         <rule header="ユーザー定義の C 外部識別子は、 先頭から 31 文字目までに違いがあるべきである" id="35_a" impl="PORT-35_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_a.rule"/>
         </rule>
         <rule header="ユーザー定義の C 内部識別子は、外部識別子と先頭から 31 文字目までに違いがあるべきである" id="35_b" impl="PORT-35_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_b.rule"/>
         </rule>
         <rule header="同一スコープで宣言されたユーザー定義の C 内部識別子は、先頭から 31 文字目までに違いがあるべきである" id="35_c" impl="PORT-35_c" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_c.rule"/>
         </rule>
         <rule header="識別子の名前は 31 文字を超えるべきではない" id="36_a" impl="PORT-36_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-36_a.rule"/>
         </rule>
         <rule header="マクロ識別子の名前は 31 文字を超えるべきではない" id="36_b" impl="PORT-36_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-36_b.rule"/>
         </rule>
      </category>
      <category description="プリプロセッサ" name="PREPROC">
         <rule header="マクロを使用しない" id="01" impl="PREPROC-01" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-01.rule"/>
         </rule>
         <rule header="include 文の中でマクロを使ってはいけない" id="02" impl="PREPROC-02" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-02.rule"/>
         </rule>
         <rule header="プリミティブ型を再定義してはならない" id="03" impl="PREPROC-03" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-03.rule"/>
         </rule>
         <rule header="命令の一部を定義してはいけない。" id="04" impl="PREPROC-04" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-04.rule"/>
         </rule>
         <rule header="マクロ関数では、乗算または除算の前後に括弧を使用する" id="05" impl="PREPROC-05" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-05.rule"/>
         </rule>
         <rule header="#include 文で絶対または相対パス名を許可しない" id="06" impl="PREPROC-06" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-06.rule"/>
         </rule>
         <rule header="不正な NULL 定義である" id="07" impl="PREPROC-07" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-07.rule"/>
         </rule>
         <rule header="#include プリプロセッサ命令はヘッダー ファイル (*.h) をインクルードするためにだけ使用する" id="08" impl="PREPROC-08" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-08.rule"/>
         </rule>
         <rule header="#include 命令は &lt;filename.h&gt; という表記を使用してヘッダー ファイルをインクルードしなければならない" id="09" impl="PREPROC-09" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-09.rule"/>
         </rule>
         <rule header="#ifndef および #endif プリプロセッサ命令は、同じファイルの多重インクルードを防ぐためだけに使用する" id="10" impl="PREPROC-10" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10.rule"/>
         </rule>
         <rule header="次のプリプロセッサ命令だけを使用する: #ifndef、#define、#endif、#include" id="11" impl="PREPROC-11" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-11.rule"/>
         </rule>
         <rule header="C++ マクロはインクルード ガード、型修飾子、記憶域クラス指定子のためにだけ使用する" id="12" impl="PREPROC-12" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-12.rule"/>
         </rule>
         <rule header="マクロにはトークン ペースト、可変引数リスト、マクロの再帰呼び出しが含まれていてはならない" id="13" impl="PREPROC-13" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-13.rule"/>
         </rule>
         <rule header="すべてのマクロは完全な構文単位に展開されなければならない" id="14" impl="PREPROC-14" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-14.rule"/>
         </rule>
         <rule header="ポインターの間接参照演算がマクロ定義に隠されていてはいけない" id="15" impl="PREPROC-15" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-15.rule"/>
         </rule>
         <rule header="# 演算子があるマクロ パラメーターは、直前、直後に ## 演算子があってはいけない" id="16" impl="PREPROC-16" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-16.rule"/>
         </rule>
         <rule header="# または ## 演算子のオペランドとして使用されており、それ自体がマクロ置換の対象であるマクロ パラメーターは、それらの演算子のオペランドとしてだけ使用されなければならない" id="17" impl="PREPROC-17" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-17.rule"/>
         </rule>
         <rule header="入出力ライブラリ stdio.h をインクルードしてはならない" id="18" impl="PREPROC-18" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-18.rule"/>
         </rule>
         <rule header="#if または #elif プリプロセッサ ディレクティブの制御式は 0 または 1 に評価されなければならない" id="19" impl="PREPROC-19" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-19.rule"/>
         </rule>
         <rule header="#include ディレクティブのファイル名をファイルシステムのファイルに合わせる" id="20" impl="PREPROC-20" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-20.rule"/>
         </rule>
         <rule header="結果がユニバーサル文字名になる可能性があるトークンの連結を行わない" id="21" impl="PREPROC-21" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-21.rule"/>
         </rule>
         <rule header="#error ディレクティブを使用してはならない" id="22" impl="PREPROC-22" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-22.rule"/>
         </rule>
         <rule header="#pragma ディレクティブを使用してはならない" id="23" impl="PREPROC-23" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-23.rule"/>
         </rule>
         <rule header="#ifdef および #ifndef プリプロセッサ ディレクティブと defined() 演算子を除いて、プリプロセッサ ディレクティブ内のすべてのマクロ識別子は、使用する前に定義される必要がある" id="24" impl="PREPROC-24" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-24.rule"/>
         </rule>
      </category>
      <category description="Qt ベスト プラクティス" name="QT">
         <rule header="すべての QObject のサブクラスに、Q_OBJECT マクロがなければならない" id="01" impl="QT-01" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-01.rule"/>
         </rule>
         <rule header="QObject を 2 回以上継承してはならない" id="02" impl="QT-02" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-02.rule"/>
         </rule>
         <rule header="シグナルをスロットに、またはシグナルを他のシグナルに接続することだけができる" id="03" impl="QT-03" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-03.rule"/>
         </rule>
         <rule header="SIGNAL および SLOT マクロ内のメソッドが存在しなければならない" id="04" impl="QT-04" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-04.rule"/>
         </rule>
         <rule header="シグナルの発信をキーワード emit でマークし、シグナルの発信と他のメソッド呼び出しを区別する" id="05" impl="QT-05" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-05.rule"/>
         </rule>
         <rule header="QThread に Idle または Critical 優先度を設定しない。High/Low/Med だけを使用する" id="06" impl="QT-06" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-06.rule"/>
         </rule>
         <rule header="QThread::terminate() を呼び出してスレッドを強制終了しない" id="07" impl="QT-07" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-07.rule"/>
         </rule>
         <rule header="関数で mutex のロックを使用している場合、同じ関数内でロックを解除する" id="08" impl="QT-08" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-08.rule"/>
         </rule>
         <rule header="QMutexLocker で new を呼び出さない" id="09" impl="QT-09" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-09.rule"/>
         </rule>
         <rule header="ポインタを持ち Qt - を継承するすべてのクラスに対し、コピー コンストラクタおよび = 演算子を宣言する" id="10" impl="QT-10" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-10.rule"/>
         </rule>
         <rule header="Widget で setWindowFlags 関数を使用しない" id="11" impl="QT-11" quickfix="false" scope="line" severity="4">
            <file path="QT\QT-11.rule"/>
         </rule>
         <rule header="Qt カーネルによって設定される特定の Widget 属性を直接設定しない" id="12" impl="QT-12" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-12.rule"/>
         </rule>
         <rule header="代入の中で定数反復子と非定数反復子を混用しない" id="13" impl="QT-13" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-13.rule"/>
         </rule>
         <rule header="Q_DECLARE_FLAGS を使用する場合、Q_DECLARE_OPERATORS_FOR_FLAGS も使用する" id="14" impl="QT-14" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-14.rule"/>
         </rule>
         <rule header="Q_DECLARE_OPERATORS_FOR_FLAGS はグローバルな名前空間に、 Q_DECLARE_FLAGS は列挙型の名前空間になければならない" id="15" impl="QT-15" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-15.rule"/>
         </rule>
         <rule header="Q_PROPERTY のゲッターおよびセッターが存在し、型が一致しなければならない" id="16" impl="QT-16" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-16.rule"/>
         </rule>
         <rule header="列挙型のプロパティは Q_ENUMS を使用する" id="17" impl="QT-17" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-17.rule"/>
         </rule>
         <rule header="Qt オブジェクトに対し非定数関数を呼び出さない" id="18" impl="QT-18" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-18.rule"/>
         </rule>
      </category>
      <category description="セキュリティ" name="SECURITY">
         <rule header="時刻を使用する標準 C ライブラリ関数を使用しないようにする" id="01" impl="SECURITY-01" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-01.rule"/>
         </rule>
         <rule header="C ライブラリの乱数を使用する関数は使用しないようにする" id="02" impl="SECURITY-02" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-02.rule"/>
         </rule>
         <rule header="疑似乱数の生成に rand() 関数を使用しない" id="02_b" impl="SECURITY-02_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-02_b.rule"/>
         </rule>
         <rule header="システム プロパティ (環境変数) の使用は制限されるべきである" id="03" impl="SECURITY-03" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-03.rule"/>
         </rule>
         <rule header="LoadLibrary() が正しいライブラリをロードするよう注意する" id="04" impl="SECURITY-04" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-04.rule"/>
         </rule>
         <rule header="printf/wprintf 関数を文字列定数以外の引数 1 個だけで使用しないようにする" id="05" impl="SECURITY-05" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-05.rule"/>
         </rule>
         <rule header="時刻を使用する MFC ライブラリ関数を使用しないようにする" id="06" impl="SECURITY-06" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-06.rule"/>
         </rule>
         <rule header="範囲チェックされていないバッファに書き込む安全でない C 関数を使用しない" id="07" impl="SECURITY-07" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-07.rule"/>
         </rule>
         <rule header="2 番目のパラメータが変数である場合に、fprintf/fwprintf 関数をパラメータ 2 個だけで使用してはいけない" id="08" impl="SECURITY-08" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-08.rule"/>
         </rule>
         <rule header="string 標準ライブラリ クラスの data() 関数は使用しないようにする" id="09" impl="SECURITY-09" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-09.rule"/>
         </rule>
         <rule header="'vfork()' 関数を使用しない" id="10" impl="SECURITY-10" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-10.rule"/>
         </rule>
         <rule header="shell メタ文字に影響される可能性があるため安全でない shell 関数は使用しない" id="11" impl="SECURITY-11" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-11.rule"/>
         </rule>
         <rule header="バッファ オーバーフローの原因になる可能性があるため、安全ではない文字列関数を使用しないようにする" id="12" impl="SECURITY-12" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-12.rule"/>
         </rule>
         <rule header="範囲をチェックしないため安全ではない文字列関数を使用しないようにする" id="13" impl="SECURITY-13" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-13.rule"/>
         </rule>
         <rule header="書式文字列で変数サイズを指定せずに scanf または fscanf 関数を使用しない" id="14" impl="SECURITY-14" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-14.rule"/>
         </rule>
         <rule header="アプリケーション　エラーを例外メッセージに含めることによって、機密の可能性がある情報を出力してはならない" id="15" impl="SECURITY-15" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-15.rule"/>
         </rule>
         <rule header="gets() を使用しない" id="16" impl="SECURITY-16" quickfix="false" scope="line" severity="1">
            <file path="SECURITY\SECURITY-16.rule"/>
         </rule>
         <rule header="非定数パラメータや変数を exec に渡さないようにする" id="17" impl="SECURITY-17" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-17.rule"/>
         </rule>
         <rule header="動的に作成された文字列を exec に渡さないようにする" id="18" impl="SECURITY-18" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-18.rule"/>
         </rule>
         <rule header="競合の原因となる関数を使用してはいけない" id="19" impl="SECURITY-19" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-19.rule"/>
         </rule>
         <rule header="パラメータとしてユーザ入力をメソッドに渡してはいけない" id="20" impl="SECURITY-20" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-20.rule"/>
         </rule>
         <rule header="ロギングのために syslog 関数を使用しない" id="21" impl="SECURITY-21" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-21.rule"/>
         </rule>
         <rule header="mbstowcs() 関数を使用しない" id="22" impl="SECURITY-22" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-22.rule"/>
         </rule>
         <rule header="カレント ディレクトリまたは windows ディレクトリを返す可能性のある関数に注意する" id="23" impl="SECURITY-23" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-23.rule"/>
         </rule>
         <rule header="InitializeCriticalSection を使用しない" id="24" impl="SECURITY-24" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-24.rule"/>
         </rule>
         <rule header="スレッド セーフでない関数を使用してはならない" id="25" impl="SECURITY-25" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-25.rule"/>
         </rule>
         <rule header="setuid を使用しない" id="26" impl="SECURITY-26" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-26.rule"/>
         </rule>
         <rule header="chmod()、chown()、chgrp() を使用しない" id="27" impl="SECURITY-27" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-27.rule"/>
         </rule>
         <rule header="セキュリティ上の理由で乱数が必要な場合に、標準の乱数ジェネレータを使用してはならない" id="28" impl="SECURITY-28" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-28.rule"/>
         </rule>
         <rule header="非推奨の C ルーティン ulimit() を使用しない" id="29" impl="SECURITY-29" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-29.rule"/>
         </rule>
         <rule header="プログラム コードで getpw 関数を使用しないようにする" id="30" impl="SECURITY-30" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-30.rule"/>
         </rule>
         <rule header="cuserid 関数を使用しない" id="31" impl="SECURITY-31" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-31.rule"/>
         </rule>
         <rule header="非推奨の C ルーティン usleep を使用しない" id="32" impl="SECURITY-32" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-32.rule"/>
         </rule>
         <rule header="NULL 終端子のない文字列を適切に処理していない関数を使用してはならない" id="33" impl="SECURITY-33" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-33.rule"/>
         </rule>
         <rule header="環境変数を使用しない" id="34" impl="SECURITY-34" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-34.rule"/>
         </rule>
         <rule header="攻撃者から設定可能なコマンド ラインの値を信頼しない" id="35" impl="SECURITY-35" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-35.rule"/>
         </rule>
         <rule header="信頼されないユーザからの入力をフィルタせずに書式パラメータに使用してはならない" id="36" impl="SECURITY-36" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-36.rule"/>
         </rule>
         <rule header="弱い暗号化関数を使用してはならない" id="37" impl="SECURITY-37" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-37.rule"/>
         </rule>
         <rule header="信頼性のないデータをループの境界として使用してはならない" id="38" impl="SECURITY-38" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-38.rule"/>
         </rule>
         <rule header="安全な一時ファイル名関数を使用する" id="39" impl="SECURITY-39" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-39.rule"/>
         </rule>
         <rule header="mkstemp を呼び出す前に umask を呼び出す" id="40" impl="SECURITY-40" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-40.rule"/>
         </rule>
         <rule header="chroot を呼び出す場合、chdir を呼び出す" id="41" impl="SECURITY-41" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-41.rule"/>
         </rule>
         <rule header="open または openat システム コールを使用してファイルを作成する場合、アクセス パーミッション ビットを指定する" id="42" impl="SECURITY-42" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-42.rule"/>
         </rule>
         <rule header="'PTHREAD_CANCEL_ASYNCHRONOUS' 引数を指定して 'pthread_setcanceltype()' 関数を呼び出すべきではない" id="43" impl="SECURITY-43" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-43.rule"/>
         </rule>
         <rule header="権限を正しい順序で破棄する" id="44" impl="SECURITY-44" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-44.rule"/>
         </rule>
         <rule header="権限が正常に破棄されたことを確認する" id="45" impl="SECURITY-45" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-45.rule"/>
         </rule>
         <rule header="データをユーザー領域にコピーできる関数に構造体へのポインターを渡すべきではない" id="46" impl="SECURITY-46" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-46.rule"/>
         </rule>
         <rule header="シフト演算子の右辺のオペランドをチェックする際、適切な整数精度を使用する" id="47" impl="SECURITY-47" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-47.rule"/>
         </rule>
         <rule header="stdlib.h または cstdlib ライブラリの system() 関数を '0' (null ポインター) 以外の引数で呼び出さない" id="48" impl="SECURITY-48" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48.rule"/>
         </rule>
         <rule header="stdlib.h または cstdlib ライブラリの system() 関数を使用しない" id="48_b" impl="SECURITY-48_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48_b.rule"/>
         </rule>
         <rule header="固有の条件変数とともに 'cnd_signal()' 関数を使用する" id="49" impl="SECURITY-49" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-49.rule"/>
         </rule>
         <rule header="複数のスレッドが同じ条件変数を待機している場合、'notify_one()' 関数を使用しない" id="50" impl="SECURITY-50" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-50.rule"/>
         </rule>
         <rule header="char バッファーを使用して std::cin の入力を格納しない" id="51" impl="SECURITY-51" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-51.rule"/>
         </rule>
         <rule header="stdlib.h または cstdlib ライブラリの 'getenv() 関数を使用しない" id="52" impl="SECURITY-52" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-52.rule"/>
         </rule>
      </category>
      <category description="STL ベスト プラクティス" name="STL">
         <rule header="コンテナに依存しないコードを書こうとするより、クラスのカプセル化を使用する" id="01" impl="STL-01" quickfix="false" scope="line" severity="5">
            <file path="STL\STL-01.rule"/>
         </rule>
         <rule header="コピーを効率的かつ正確に行い、スライシングの問題を避けるため、オブジェクトのコンテナではなくポインタのコンテナを作成する" id="02" impl="STL-02" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-02.rule"/>
         </rule>
         <rule header="size() で 0 を調べる代わりに empty を呼び出す" id="03" impl="STL-03" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-03.rule"/>
         </rule>
         <rule header="明示的なループで insert を繰り返し呼び出してはならない" id="04" impl="STL-04" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-04.rule"/>
         </rule>
         <rule header="挿入反復子によりコピー先範囲を指定するほとんどの場合を、範囲メンバ関数の呼び出しに置き換えるべきである" id="05" impl="STL-05" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-05.rule"/>
         </rule>
         <rule header="関数パラメータとして使用する場合、無名の istream_iterator オブジェクトではなく、istream_iterator の名前を使用する" id="06" impl="STL-06" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-06.rule"/>
         </rule>
         <rule header="new したポインタのコンテナを使うときは、必ずポインタを delete した後にコンテナを破棄する" id="07" impl="STL-07" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-07.rule"/>
         </rule>
         <rule header="auto_ptr 型のコンテナを作成しない" id="08" impl="STL-08" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-08.rule"/>
         </rule>
         <rule header="list および標準連想コンテナで remove アルゴリズムを使用しない" id="09" impl="STL-09" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-09.rule"/>
         </rule>
         <rule header="動的に割り当てられる配列より vector と string を優先して使う" id="10" impl="STL-10" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-10.rule"/>
         </rule>
         <rule header="string ではなく vector&lt;char&gt; を使用する" id="11" impl="STL-11" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-11.rule"/>
         </rule>
         <rule header="reserve を使って不必要な割り当てを避ける" id="12" impl="STL-12" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-12.rule"/>
         </rule>
         <rule header="vector または string を C 関数に渡す前に、空でないかチェックしなければならない" id="13" impl="STL-13" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-13.rule"/>
         </rule>
         <rule header="vector&lt;bool&gt; を使用しない" id="14" impl="STL-14" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-14.rule"/>
         </rule>
         <rule header="ポインタの連想コンテナに対する比較の種類を指定する" id="15" impl="STL-15" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-15.rule"/>
         </rule>
         <rule header="等しい値に対して true を返す比較関数を連想コンテナに使用しない" id="16" impl="STL-16" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-16.rule"/>
         </rule>
         <rule header="等しい値に対して true を返す比較関数を連想コンテナに使用しない" id="17" impl="STL-17" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-17.rule"/>
         </rule>
         <rule header="const_iterator、reverse_iterator、const_reverse_iterator より iterator を優先的に使う" id="18" impl="STL-18" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-18.rule"/>
         </rule>
         <rule header="コンテナの const_iterator を iterator に変換するには、distance と advance を使用する" id="19" impl="STL-19" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-19.rule"/>
         </rule>
         <rule header="消去目的で reverse_iterator の基底 iterator を使用する場合は注意が必要である" id="20" impl="STL-20" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-20.rule"/>
         </rule>
         <rule header="1 文字ごとの入力には istreambuf_iterator の使用を考える" id="21" impl="STL-21" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-21.rule"/>
         </rule>
         <rule header="出力範囲の大きさを確認する" id="22" impl="STL-22" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-22.rule"/>
         </rule>
         <rule header="本当に削除したい場合は、remove 風アルゴリズムの後に erase を使う" id="23" impl="STL-23" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-23.rule"/>
         </rule>
         <rule header="動的に割り当てられるポインタのコンテナに対して remove や同様のアルゴリズム (remove_if と unique) の使用を避ける" id="24" impl="STL-24" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-24.rule"/>
         </rule>
         <rule header="アルゴリズムにソート済み範囲と共に比較関数も渡す場合、範囲のソートに使った関数と同じように動作する比較関数を渡す必要がある" id="25" impl="STL-25" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-25.rule"/>
         </rule>
         <rule header="copy_if の正しい実装は、述語の前に not1 がある remove_copy_if の戻り値に基づくものであってはならない" id="26" impl="STL-26" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-26.rule"/>
         </rule>
         <rule header="accumulate() を浮動小数点型の値のコンテナに使用する場合、浮動小数点型の初期値を使用する" id="27" impl="STL-27" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-27.rule"/>
         </rule>
         <rule header="値渡し用のファンクタ クラスを設計する" id="28" impl="STL-28" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-28.rule"/>
         </rule>
         <rule header="述語を純粋関数にする" id="29" impl="STL-29" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-29.rule"/>
         </rule>
         <rule header="ファンクタクラスは 1 つの operator() 関数だけを持つべきであり、またパラメータと戻り値の型を unary_function または binary_function に渡さなければならない" id="30" impl="STL-30" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-30.rule"/>
         </rule>
         <rule header="STL のコンポーネントに関数を渡す場合、ptr_fun、mem_fun、または mem_fun_ref を使用しなければならない" id="31" impl="STL-31" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-31.rule"/>
         </rule>
         <rule header="less&lt;T&gt; が operator&lt; を意味することを理解する" id="32" impl="STL-32" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-32.rule"/>
         </rule>
         <rule header="独自に作成したループよりアルゴリズムの呼び出しを優先して使用する" id="33" impl="STL-33" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-33.rule"/>
         </rule>
         <rule header="アルゴリズムより同名のメンバ関数を優先して使用する" id="34" impl="STL-34" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-34.rule"/>
         </rule>
         <rule header="count() の非ゼロ値から true 、または ゼロから false への変換に頼らない" id="35" impl="STL-35" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-35.rule"/>
         </rule>
         <rule header="実際には範囲ではないイテレータ範囲を使用してはならない" id="36" impl="STL-36" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-36.rule"/>
         </rule>
         <rule header="C スタイルの配列を使用してはならない" id="37" impl="STL-37" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-37.rule"/>
         </rule>
         <rule header="イテレータの比較には  &lt; ではなく != を使用する" id="38" impl="STL-38" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-38.rule"/>
         </rule>
         <rule header="オーバーロードと traits クラスを組み合わせて使用する" id="39" impl="STL-39" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-39.rule"/>
         </rule>
         <rule header="swap を呼び出す場合、std::swap を using 宣言し、swap を名前空間修飾なしで呼び出す" id="40" impl="STL-40" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-40.rule"/>
         </rule>
         <rule header="非メンバの swap を std::swap のオーバーロードとして宣言しない" id="41" impl="STL-41" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-41.rule"/>
         </rule>
         <rule header="メンバ関数の swap は決して例外を投げてはならない" id="42" impl="STL-42" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-42.rule"/>
         </rule>
      </category>
      <category description="テンプレート" name="TEMPL">
         <rule header="パラメータに依存しないコードはテンプレートから外に出す" id="01" impl="TEMPL-01" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-01.rule"/>
         </rule>
         <rule header="型変換をさせたいなら、メンバでない関数をクラステンプレートの中で定義する" id="02" impl="TEMPL-02" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-02.rule"/>
         </rule>
         <rule header="テンプレート クラス中の関数をオーバーロードしてはいけない" id="03" impl="TEMPL-03" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-03.rule"/>
         </rule>
         <rule header="テンプレート グローバル関数では、ネストされた依存名指定に typename を使用する" id="04" impl="TEMPL-04" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-04.rule"/>
         </rule>
         <rule header="テンプレート グローバル関数で、ネストされた依存名を指定するには typename を使用する" id="05" impl="TEMPL-05" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-05.rule"/>
         </rule>
         <rule header="テンプレート クラスでは、仮想関数のデフォルト引数を変更してはならない" id="06" impl="TEMPL-06" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-06.rule"/>
         </rule>
         <rule header="1 つのジェネリック パラメータを持つテンプレート  コンストラクタがある場合、コピー コンストラクタを宣言する" id="07" impl="TEMPL-07" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-07.rule"/>
         </rule>
         <rule header="関数呼び出しの実行可能な関数セットには関数の特殊化が含まれていないか、関数の特殊化だけが含まれるべきである" id="08" impl="TEMPL-08" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-08.rule"/>
         </rule>
         <rule header="オーバーロードされた関数テンプレートを明示的に特殊化してはならない" id="09" impl="TEMPL-09" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-09.rule"/>
         </rule>
         <rule header="テンプレートの部分特殊化および明示的な特殊化は、一次テンプレートと同じファイルに宣言する" id="10" impl="TEMPL-10" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-10.rule"/>
         </rule>
         <rule header="1 つのジェネリック パラメータを持つテンプレート代入演算子がある場合、コピー代入演算子を宣言する" id="11" impl="TEMPL-11" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-11.rule"/>
         </rule>
         <rule header="依存基底クラスを持つクラス テンプレートでは、依存基底クラスで見つかるすべての名前を修飾識別子または this-&gt; を使用して参照する" id="12" impl="TEMPL-12" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-12.rule"/>
         </rule>
         <rule header="関連する名前空間に非メンバー ジェネリック関数を宣言しない" id="13" impl="TEMPL-13" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-13.rule"/>
         </rule>
         <rule header="関数は、翻訳単位で事前に宣言されている関数に解決されなければならない" id="14" impl="TEMPL-14" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-14.rule"/>
         </rule>
         <rule header="明示的にインスタンス化されるテンプレートを extern 宣言する" id="15" impl="TEMPL-15" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-15.rule"/>
         </rule>
         <rule header="テンプレートの特殊化は、一次テンプレートまたは特殊化が宣言されたユーザー定義型と同じファイルに宣言する" id="16" impl="TEMPL-16" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-16.rule"/>
         </rule>
         <rule header="typename キーワードが戻り値型の前にある場合、後置戻り値型構文を使用する" id="17" impl="TEMPL-17" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-17.rule"/>
         </rule>
         <rule header="非 メンバー ジェネリック演算子は、クラス (構造体) 型、列挙型、共用体型の宣言を含まない名前空間にだけ宣言できる" id="18" impl="TEMPL-18" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-18.rule"/>
         </rule>
      </category>
   </builtin>
</rules>
