<?xml version="1.0" encoding="utf-8"?>
<rules><!--このファイルは自動生成です。編集する場合、上書きしたくないルール エントリから autogen="true" 属性を削除してください。-->
   <builtin>
      <category description="コーディング規約" name="CODSTA">
         <category description="C++ コーディング規約" name="CPP">
            <rule autogen="true" header="stdio.h よりも iostream.h を使用する" id="01" impl="CODSTA-CPP-01" severity="5"/>
            <rule autogen="true" header="代入演算子に *this への参照を返させる。また代入演算子の戻り値の型を自身のクラス型への非 const 参照にする" id="02" impl="CODSTA-CPP-02" severity="3"/>
            <rule autogen="true" header="ビット演算子、比較演算子、論理演算子、カンマ演算子は const でなければならない" id="03" impl="CODSTA-CPP-03" severity="3"/>
            <rule autogen="true" header="変換を可能にするコンストラクタは  explicit にする" id="04" impl="CODSTA-CPP-04" severity="1"/>
            <rule autogen="true" header="ユーザ定義の変換関数を使用しない" id="05" impl="CODSTA-CPP-05" severity="1"/>
            <rule autogen="true" header="メンバー関数からクラス データへのハンドルを返却してはいけない" id="06" impl="CODSTA-CPP-06" severity="3"/>
            <rule autogen="true" header="インクリメントとデクリメントの後置形式は、前置形式を使用して実装しなければならない" id="07" impl="CODSTA-CPP-07" severity="3"/>
            <rule autogen="true" header="論理演算子 AND、OR (&amp;&amp;、||) をオーバーロードしてはいけない" id="08" impl="CODSTA-CPP-08" severity="3"/>
            <rule autogen="true" header="reinterpret_cast を使用しない" id="09" impl="CODSTA-CPP-09" severity="3"/>
            <rule autogen="true" header="メンバ関数を持った構造体を定義してはいけない" id="10" impl="CODSTA-CPP-10" severity="3"/>
            <rule autogen="true" header="パディング ビットを含む可能性があるクラスのオブジェクトを C の標準ライブラリ関数で比較してはならない" id="100" impl="CODSTA-CPP-100" severity="3"/>
            <rule autogen="true" header="関係演算子はブール値を返す必要がある" id="101" impl="CODSTA-CPP-101" severity="3"/>
            <rule autogen="true" header="2 項算術演算子およびビット演算子は 'prvalue' を返す必要がある" id="102" impl="CODSTA-CPP-102" severity="3"/>
            <rule autogen="true" header="出力パラメーターを使用してはならない" id="103" impl="CODSTA-CPP-103" severity="3"/>
            <rule autogen="true" header="typeid 演算子のオペランドに副作用を持つ式が含まれていてはならない" id="104" impl="CODSTA-CPP-104" severity="3"/>
            <rule autogen="true" header="typeid 演算子のオペランドに副作用を発生させる関数の呼び出しが含まれていてはならない" id="104_b" impl="CODSTA-CPP-104_b" severity="3"/>
            <rule autogen="true" header="特別なメンバーの動作がコンパイラの動作と同じである場合は、=default と定義する" id="105" impl="CODSTA-CPP-105" severity="3"/>
            <rule autogen="true" header="コードの重複を減らすため、移譲コンストラクターを使用する" id="106" impl="CODSTA-CPP-106" severity="3"/>
            <rule autogen="true" header="比較演算子は非メンバー関数でなければならない" id="107" impl="CODSTA-CPP-107" severity="3"/>
            <rule autogen="true" header="比較演算子は同じパラメーター型とnoexcept を持つ非メンバー関数でなければならない" id="107_b" impl="CODSTA-CPP-107_b" severity="3"/>
            <rule autogen="true" header="C++ スタイルのキャストを使用する" id="11" impl="CODSTA-CPP-11" severity="3"/>
            <rule autogen="true" header="基底クラスまたはメンバ変数として使用するクラスは別個のインクルードファイルに置く" id="12" impl="CODSTA-CPP-12" severity="3"/>
            <rule autogen="true" header="関数の戻り値の型として使用するクラスは別個のインクルードファイルに置く" id="13" impl="CODSTA-CPP-13" severity="3"/>
            <rule autogen="true" header="関数プロトタイプの引数の型として使用されるクラスは別個のインクルードファイルに置く" id="14" impl="CODSTA-CPP-14" severity="3"/>
            <rule autogen="true" header="インラインメンバ関数で使用される関数は別個のインクルードファイルに置く" id="15" impl="CODSTA-CPP-15" severity="3"/>
            <rule autogen="true" header="== と != など 2  つの演算子が反対の意味を持つ場合、両方を定義するのが適切である" id="16" impl="CODSTA-CPP-16" severity="3"/>
            <rule autogen="true" header="C++ では、struct キーワードを使って変数を宣言してはいけない" id="17" impl="CODSTA-CPP-17" severity="3"/>
            <rule autogen="true" header="クラスでグローバルな変数、定数、列挙型、型定義をカプセル化する" id="18" impl="CODSTA-CPP-18" severity="5"/>
            <rule autogen="true" header="コンストラクタを少なくとも 1 つ定義し、デフォルト コンストラクタが使用されることは避ける" id="19" impl="CODSTA-CPP-19" severity="2"/>
            <rule autogen="true" header="混合モードの演算子をサポートする場合、演算子を非メンバ関数にする" id="20" impl="CODSTA-CPP-20" severity="3"/>
            <rule autogen="true" header="代入演算子は const 参照を返さなければならない" id="21" impl="CODSTA-CPP-21" severity="5"/>
            <rule autogen="true" header="メンバ関数より、メンバでも friend でもない関数を使う" id="22" impl="CODSTA-CPP-22" severity="4"/>
            <rule autogen="true" header="グローバル関数を参照する場合は常に :: 演算子を使用する" id="23" impl="CODSTA-CPP-23" severity="5"/>
            <rule autogen="true" header="代入演算子を仮想にしない。また代入演算子から const T&amp; を返してはならない。" id="24" impl="CODSTA-CPP-24" severity="3"/>
            <rule autogen="true" header="仮想関数を public にしない。また public 関数を仮想関数にしない" id="25" impl="CODSTA-CPP-25" severity="3"/>
            <rule autogen="true" header="特に共同の作業が意図されていない限り、型と関数は別の名前空間に置く" id="26" impl="CODSTA-CPP-26" severity="3"/>
            <rule autogen="true" header="型および非メンバ関数インターフェイスを同じ名前空間に保持する" id="27" impl="CODSTA-CPP-27" severity="3"/>
            <rule autogen="true" header="二項算術演算子 (+、-、*、/、^、%、|、&amp;) を定義する場合は、代入形式も用意する" id="28" impl="CODSTA-CPP-28" severity="3"/>
            <rule autogen="true" header="算術演算子と代入演算子の標準形式を使用する" id="29" impl="CODSTA-CPP-29" severity="3"/>
            <rule autogen="true" header="混合モードの算術をサポートするには、メンバ演算子ではなくメンバでない演算子を使う" id="30" impl="CODSTA-CPP-30" severity="3"/>
            <rule autogen="true" header="明示的な (explicit) コンストラクタの使用は避ける" id="31" impl="CODSTA-CPP-31" severity="5"/>
            <rule autogen="true" header="関数がインライン化されることを意図しているのでなければ、関数定義はクラス仕様の中に置かれるべきではない" id="32" impl="CODSTA-CPP-32" severity="3"/>
            <rule autogen="true" header="テンプレート クラス定義でメンバ関数を定義してはいけない" id="33" impl="CODSTA-CPP-33" severity="3"/>
            <rule autogen="true" header="ポインタの static_cast を使用しない" id="34" impl="CODSTA-CPP-34" severity="3"/>
            <rule autogen="true" header="動的キャストを使用しない" id="35" impl="CODSTA-CPP-35" severity="3"/>
            <rule autogen="true" header="グローバル名前空間は main() および名前空間の宣言だけを含むことができる" id="36" impl="CODSTA-CPP-36" severity="3"/>
            <rule autogen="true" header="関数定義の中でクラス/構造体/共用体を定義しない" id="37" impl="CODSTA-CPP-37" severity="3"/>
            <rule autogen="true" header="型変換演算子、-&gt; 演算子、() 演算子、[] 演算子 は const でなければならない" id="38" impl="CODSTA-CPP-38" severity="3"/>
            <rule autogen="true" header="名前空間 using をヘッダー ファイルまたは #include の前に記述しない" id="39" impl="CODSTA-CPP-39" severity="3"/>
            <rule autogen="true" header="クラス中のオブジェクト数の制限" id="40" impl="CODSTA-CPP-40" severity="5"/>
            <rule autogen="true" header="C++ では、変数宣言で enum キーワードを使ってはいけない" id="41" impl="CODSTA-CPP-41" severity="3"/>
            <rule autogen="true" header="mutable キーワードを使ってメンバ変数を宣言してはいけない" id="42" impl="CODSTA-CPP-42" severity="3"/>
            <rule autogen="true" header="できる限り参照パラメータを const 参照として宣言する" id="43" impl="CODSTA-CPP-43" severity="3"/>
            <rule autogen="true" header="const メンバ関数を複製する代わりに、非 const 関数から const 関数を呼び出す" id="44" impl="CODSTA-CPP-44" severity="3"/>
            <rule autogen="true" header="private セクションでは、次の順序でエンティティを宣言する: コンス トラクタ、デストラクタ、メンバ関数、メンバ変換関数、列挙、その他" id="45" impl="CODSTA-CPP-45" severity="3"/>
            <rule autogen="true" header="クラスでのスコープの順序: public を最初に置く" id="46" impl="CODSTA-CPP-46" severity="3"/>
            <rule autogen="true" header="クラスでのスコープの順序: protected を private の前に置く" id="47" impl="CODSTA-CPP-47" severity="3"/>
            <rule autogen="true" header="protected セクションでは、次の順序でエンティティを宣言する: コン ストラクタ、デストラクタ、メンバ関数、メンバ変換関数、列挙、その他" id="48" impl="CODSTA-CPP-48" severity="3"/>
            <rule autogen="true" header="public セクションでは、次の順序でエンティティを宣言する: コンスト ラクタ、デストラクタ、メンバ関数、メンバ変換関数、列挙、その他" id="49" impl="CODSTA-CPP-49" severity="3"/>
            <rule autogen="true" header="関数およびクラスの外部で static キーワードを使用してはならない" id="50" impl="CODSTA-CPP-50" severity="3"/>
            <rule autogen="true" header="ソース ファイルで inline キーワードを定義してはならない" id="51" impl="CODSTA-CPP-51" severity="3"/>
            <rule autogen="true" header="代入バージョンの演算子と単独バージョンの演算子の自然な関係を使用することを考慮する" id="52" impl="CODSTA-CPP-52" severity="3"/>
            <rule autogen="true" header="可能な場合は常にパラメータまたはローカル変数を const 宣言する" id="53" impl="CODSTA-CPP-53" severity="3"/>
            <rule autogen="true" header="可能な場合は常にメンバ関数を const 宣言する" id="54" impl="CODSTA-CPP-54" severity="3"/>
            <rule autogen="true" header="インターフェイスで配列を使用するべきではない" id="55" impl="CODSTA-CPP-55" severity="2"/>
            <rule autogen="true" header="private および protected メソッドは配列型のパラメーターを宣言してはならない" id="55_b" impl="CODSTA-CPP-55_b" severity="2"/>
            <rule autogen="true" header="クラス、構造体、列挙型を、型の定義の中で宣言してはならない" id="56" impl="CODSTA-CPP-56" severity="3"/>
            <rule autogen="true" header="名前空間を 2 階層より深くネストしてはならない" id="57" impl="CODSTA-CPP-57" severity="3"/>
            <rule autogen="true" header="オーバーロードされた演算子ではない関数から返された void 以外の戻り値は必ず使用する" id="58" impl="CODSTA-CPP-58" severity="3"/>
            <rule autogen="true" header="C ライブラリを使用してはならない" id="59" impl="CODSTA-CPP-59" severity="3"/>
            <rule autogen="true" header="ISO/IEC 14882:2003 で定義されたエスケープ シーケンスだけを使用する" id="60" impl="CODSTA-CPP-60" severity="3"/>
            <rule autogen="true" header="NULL を整数値として使用してはならない" id="62" impl="CODSTA-CPP-62" severity="3"/>
            <rule autogen="true" header="リテラルのゼロ (0) を null ポインター定数として使用してはならない" id="63" impl="CODSTA-CPP-63" severity="3"/>
            <rule autogen="true" header="if 文または反復文の条件ではブール型を使用する" id="64" impl="CODSTA-CPP-64" severity="3"/>
            <rule autogen="true" header="条件演算子の第一オペランドはブール型でなければならない" id="65" impl="CODSTA-CPP-65" severity="1"/>
            <rule autogen="true" header="void へのキャスト以外の C スタイルのキャストおよび明示的なコンストラクタ呼び出し以外の関数スタイルのキャストを使用してはならない" id="66" impl="CODSTA-CPP-66" severity="3"/>
            <rule autogen="true" header="! 演算子、論理演算子 &amp;&amp; または || のオペランドはブール型でなければならない" id="67" impl="CODSTA-CPP-67" severity="3"/>
            <rule autogen="true" header="単項演算子 &amp; をオーバーロードしてはならない" id="68" impl="CODSTA-CPP-68" severity="3"/>
            <rule autogen="true" header="for ループには 1 つの浮動小数点型ではないループ カウンタがなければならない" id="69" impl="CODSTA-CPP-69" severity="3"/>
            <rule autogen="true" header="ループ カウンタが -- または ++ で変更されていない場合、条件ではループ カウンタを &lt;=、&lt;、&gt; または &gt;= 演算子のオペランドとして使用する" id="70" impl="CODSTA-CPP-70" severity="3"/>
            <rule autogen="true" header="ループ カウンタは --、++、-=n、+=n のいずれかの方法で変更しなければならない。n はループの持続期間中は一定であるものとする" id="71" impl="CODSTA-CPP-71" severity="3"/>
            <rule autogen="true" header="ループ カウンタ以外のループ制御変数を条件式または更新式で変更してはならない" id="72" impl="CODSTA-CPP-72" severity="3"/>
            <rule autogen="true" header="文で変更されるループ カウンタ以外のループ制御変数はブール型でなければならない" id="73" impl="CODSTA-CPP-73" severity="3"/>
            <rule autogen="true" header="ヘッダー ファイルに無名の名前空間があってはならない" id="74" impl="CODSTA-CPP-74" severity="3"/>
            <rule autogen="true" header="using 指令を使用してはならない" id="75" impl="CODSTA-CPP-75" severity="3"/>
            <rule autogen="true" header="同じ名前空間にある 1 つの識別子の複数の宣言は using 宣言をまたいではならない" id="76" impl="CODSTA-CPP-76" severity="3"/>
            <rule autogen="true" header="const メンバー関数は const ではないクラス データへのポインターまたは参照を返してはならない" id="77" impl="CODSTA-CPP-77" severity="3"/>
            <rule autogen="true" header="メンバー関数を static にできる場合はそうする。その他の場合で const にできるときはそうする。" id="78" impl="CODSTA-CPP-78" severity="3"/>
            <rule autogen="true" header="等価演算子 (== または !=) のオペランドは、仮想メンバー関数へのポインターであってはならない" id="79" impl="CODSTA-CPP-79" severity="3"/>
            <rule autogen="true" header="カンマ演算子 &#34;,&#34; をオーバーロードしてはいけない" id="80" impl="CODSTA-CPP-80" severity="3"/>
            <rule autogen="true" header="ゲッター/セッター (アクセサー/ミューテーター) だけしかないクラスを作成してはならない" id="81" impl="CODSTA-CPP-81" severity="4"/>
            <rule autogen="true" header="カプセル化されていないグローバル変数 (名前空間で宣言された変数や public static メンバーを含む) を避ける" id="82" impl="CODSTA-CPP-82" severity="3"/>
            <rule autogen="true" header="ローカル スコープで宣言された識別子は、クラス スコープで宣言された識別子を隠ぺいしてはならない" id="83" impl="CODSTA-CPP-83" severity="3"/>
            <rule autogen="true" header="クラス スコープで宣言された識別子は、グローバルまたは名前空間のスコープで宣言された識別子を隠ぺいしてはならない" id="84" impl="CODSTA-CPP-84" severity="3"/>
            <rule autogen="true" header="内部クラスのスコープで宣言された識別子は、外側のクラスのスコープで宣言された識別子を隠ぺいしてはならない" id="85" impl="CODSTA-CPP-85" severity="3"/>
            <rule autogen="true" header="1 つのクラスに 2 つの正反対の等価演算子 ('==', '!=') を定義する場合、一方の観点から他方を定義する" id="86" impl="CODSTA-CPP-86" severity="3"/>
            <rule autogen="true" header="型を参照する識別子は、同じスコープにあるオブジェクトまたは関数を参照してはならない" id="87_a" impl="CODSTA-CPP-87_a" severity="3"/>
            <rule autogen="true" header="型を参照する識別子は、同じスコープにあるオブジェクトまたは関数を参照してはならない" id="87_b" impl="CODSTA-CPP-87_b" severity="3"/>
            <rule autogen="true" header="型を参照する識別子は、同じスコープにあるオブジェクトまたは関数を参照してはならない" id="87_c" impl="CODSTA-CPP-87_c" severity="3"/>
            <rule autogen="true" header="typedef の名前は、その基本型の名前と同じにするべきではない" id="88" impl="CODSTA-CPP-88" severity="3"/>
            <rule autogen="true" header="列挙型を bool 型に代入してはならない" id="89" impl="CODSTA-CPP-89" severity="4"/>
            <rule autogen="true" header="ヘッダー ファイルで using ディレクティブおよび using 宣言 (クラス スコープまたは関数スコープの using 宣言を除く) を使用してはならない" id="90" impl="CODSTA-CPP-90" severity="3"/>
            <rule autogen="true" header="オーバーロードされた二項演算子は対応する複合代入演算子を使って実装するべきである" id="91" impl="CODSTA-CPP-91" severity="3"/>
            <rule autogen="true" header="多重継承階層内のすべてのアクセス可能な名前は一意でなければならない" id="92" impl="CODSTA-CPP-92" severity="3"/>
            <rule autogen="true" header="C の標準ライブラリ関数を使用してノントリビアル クラス型のオブジェクトを初期化してはならない" id="93" impl="CODSTA-CPP-93" severity="3"/>
            <rule autogen="true" header="C の標準ライブラリ関数を使用して非標準レイアウト クラス型のオブジェクトを比較してはならない" id="94" impl="CODSTA-CPP-94" severity="3"/>
            <rule autogen="true" header="標準の名前空間 std および posix を変更してはならない" id="95" impl="CODSTA-CPP-95" severity="3"/>
            <rule autogen="true" header="別の言語リンケージで関数を呼び出さない" id="96" impl="CODSTA-CPP-96" severity="3"/>
            <rule autogen="true" header="参照型を const または volatile で修飾してはならない" id="97" impl="CODSTA-CPP-97" severity="3"/>
            <rule autogen="true" header="コピー演算はソース オブジェクトを変更してはならない" id="98" impl="CODSTA-CPP-98" severity="2"/>
            <rule autogen="true" header="offsetof() は有効な型およびメンバーに対して使用する" id="99" impl="CODSTA-CPP-99" severity="3"/>
         </category>
         <category description="Modern C++ コーディング規約" name="MCPP">
            <rule autogen="true" header="ユーザー定義の変換を行うキャスト演算子は explicit にするべきである" id="01" impl="CODSTA-MCPP-01" severity="3"/>
            <rule autogen="true" header="typedef ではなくエイリアス宣言を使用する" id="02" impl="CODSTA-MCPP-02" severity="3"/>
            <rule autogen="true" header="スコープなしの列挙型ではなく、スコープ付きの列挙型を使用する" id="03" impl="CODSTA-MCPP-03" severity="3"/>
            <rule autogen="true" header="NULL または 0 (ゼロ) ではなく nullptr を使用する" id="04" impl="CODSTA-MCPP-04" severity="4"/>
            <rule autogen="true" header="オーバーライド仮想関数は override または final 指定子付きで宣言する必要がある" id="05" impl="CODSTA-MCPP-05" severity="3"/>
            <rule autogen="true" header="クラスのコピーを防ぐため、コピー コンストラクターおよびコピー代入演算子に delete を指定して宣言する" id="06_a" impl="CODSTA-MCPP-06_a" severity="3"/>
            <rule autogen="true" header="クラスのコピーを防ぐため、private メソッドを持つ基底クラスを使用するのではなく、コピー コンストラクターおよびコピー代入演算子に delete を指定して宣言する" id="06_b" impl="CODSTA-MCPP-06_b" severity="3"/>
            <rule autogen="true" header="std::bind、std::bind1st および std::bind2nd ではなくラムダを使用する" id="07" impl="CODSTA-MCPP-07" severity="2"/>
            <rule autogen="true" header="'binder1st' および 'binder2nd' 識別子を使用するべきではない" id="07_b" impl="CODSTA-MCPP-07_b" severity="3"/>
            <rule autogen="true" header="変数の宣言では、明示的な型名ではなく auto を使用する" id="08_a" impl="CODSTA-MCPP-08_a" severity="2"/>
            <rule autogen="true" header="関数の戻り値の型では、明示的な型名ではなく auto を使用する" id="08_b" impl="CODSTA-MCPP-08_b" severity="2"/>
            <rule autogen="true" header="例外を発生させない関数は noexcept 宣言する" id="09" impl="CODSTA-MCPP-09" severity="3"/>
            <rule autogen="true" header="iterator ではなく const iterator を使用する" id="10_a" impl="CODSTA-MCPP-10_a" severity="3"/>
            <rule autogen="true" header="cbegin()、crbegin()、cend()、crend() 関数を優先的に使用する" id="10_b" impl="CODSTA-MCPP-10_b" severity="3"/>
            <rule autogen="true" header="できるだけ constexpr を使用して定数変数を宣言する" id="11_a_cpp11" impl="CODSTA-MCPP-11_a_cpp11" severity="4"/>
            <rule autogen="true" header="できるだけ constexpr を使用して関数を宣言する" id="11_b_cpp11" impl="CODSTA-MCPP-11_b_cpp11" severity="4"/>
            <rule autogen="true" header="右辺値参照には std::move() を使用し、ユニバーサル参照には std::forward() を使用する" id="13" impl="CODSTA-MCPP-13" severity="3"/>
            <rule autogen="true" header="ユニバーサル参照を転送する場合、std::forward 関数を使用する" id="13_b" impl="CODSTA-MCPP-13_b" severity="3"/>
            <rule autogen="true" header="前方参照でのオーバーロードを避ける" id="14" impl="CODSTA-MCPP-14" severity="3"/>
            <rule autogen="true" header="デフォルトのキャプチャ モードを避ける" id="15_a" impl="CODSTA-MCPP-15_a" severity="3"/>
            <rule autogen="true" header="デフォルトの by-reference キャプチャを使用するラムダでは、明示的に 'this' ポインターを使用する" id="15_b" impl="CODSTA-MCPP-15_b" severity="3"/>
            <rule autogen="true" header="なるべく raw ポインター メンバーではなくスマート ポインター メンバーを使用する" id="16_a" impl="CODSTA-MCPP-16_a" severity="4"/>
            <rule autogen="true" header="配列または STL コンテナーでは、なるべく raw ポインター メンバーではなくスマート ポインター メンバーを使用する" id="16_b" impl="CODSTA-MCPP-16_b" severity="4"/>
            <rule autogen="true" header="new を直接使用するのではなく、できるだけ 'std::make_shared' を使用する" id="16_c" impl="CODSTA-MCPP-16_c" severity="3"/>
            <rule autogen="true" header="std::auto_ptr ではなく、できるだけ std::unique_ptr を使用する" id="16_d" impl="CODSTA-MCPP-16_d" severity="3"/>
            <rule autogen="true" header="'std::unique_ptr' によって所有されるオブジェクトの構築には 'std::make_unique' を使用する" id="16_e" impl="CODSTA-MCPP-16_e" severity="3"/>
            <rule autogen="true" header="ローカル オブジェクトを参照でキャプチャするラムダを返してはならない" id="17" impl="CODSTA-MCPP-17" severity="3"/>
            <rule autogen="true" header="外側のラムダから参照によってローカル オブジェクトをキャプチャしてはならない" id="17_b" impl="CODSTA-MCPP-17_b" severity="3"/>
            <rule autogen="true" header="ローカル オブジェクトを参照によってキャプチャするラムダは、より長い存続期間を持つ変数に代入するべきではない" id="17_c" impl="CODSTA-MCPP-17_c" severity="3"/>
            <rule autogen="true" header="ラムダ式では不要なデフォルト キャプチャ モードを避ける" id="18_a" impl="CODSTA-MCPP-18_a" severity="3"/>
            <rule autogen="true" header="不要なラムダ キャプチャを避ける" id="18_b" impl="CODSTA-MCPP-18_b" severity="3"/>
            <rule autogen="true" header="参照修飾子 &amp; を付けて代入演算子を宣言する" id="19" impl="CODSTA-MCPP-19" severity="3"/>
            <rule autogen="true" header="できるだけ raw ローカル ポインターではなくスマート ポインターを使用する" id="20" impl="CODSTA-MCPP-20" severity="4"/>
            <rule autogen="true" header="mutex に対して直接 lock() を呼び出さない" id="21" impl="CODSTA-MCPP-21" severity="4"/>
            <rule autogen="true" header="範囲ベースの for ループでは auto 宣言に対して明示的な参照修飾子を使用する" id="22" impl="CODSTA-MCPP-22" severity="3"/>
            <rule autogen="true" header="クラスの public なデストラクターが非 virtual である場合、クラスを final 宣言するべきである" id="23" impl="CODSTA-MCPP-23" severity="3"/>
            <rule autogen="true" header="メンバー関数の宣言では virtual、override、final のいずれか 1 つだけを指定するべきである" id="24" impl="CODSTA-MCPP-24" severity="3"/>
            <rule autogen="true" header="桁区切り ' は一貫性をもって使用する" id="25" impl="CODSTA-MCPP-25" severity="3"/>
            <rule autogen="true" header="メンバー仮想関数を指すポインターは、null ポインター定数と等価かどうかだけをテストするべきである" id="26" impl="CODSTA-MCPP-26" severity="3"/>
            <rule autogen="true" header="ユーザー定義型のすべての std::hash 特殊化は、noexcept 関数呼び出し演算子を持つ必要がある" id="27" impl="CODSTA-MCPP-27" severity="2"/>
            <rule autogen="true" header="ラムダを typeid のオペランドにしてはならない" id="28" impl="CODSTA-MCPP-28" severity="3"/>
            <rule autogen="true" header="スレッドにオブジェクトへのポインターを渡す場合はスマート ポインターを使用する" id="29" impl="CODSTA-MCPP-29" severity="3"/>
            <rule autogen="true" header="ローカル オブジェクトに対して 'std::shared_ptr' ではなく 'std::unique_ptr' を使用することを検討する" id="30" impl="CODSTA-MCPP-30" severity="3"/>
            <rule autogen="true" header="サイズ指定付きとサイズ指定なしの両方のバージョンの delete 演算子を定義する" id="31" impl="CODSTA-MCPP-31" severity="3"/>
            <rule autogen="true" header="静的およびスレッドローカルなオブジェクトは定数初期化される必要がある" id="32" impl="CODSTA-MCPP-32" severity="3"/>
            <rule autogen="true" header="ユーザー定義のリテラル演算子は、渡されたパラメーターの変換だけを行う必要がある" id="33" impl="CODSTA-MCPP-33" severity="3"/>
            <rule autogen="true" header="生存期間を表現する場合にだけパラメーター型としてスマートポインターを使用する" id="34" impl="CODSTA-MCPP-34" severity="3"/>
            <rule autogen="true" header="パラメーターは、管理対象オブジェクトを関数が置き換える場合にだけ  'std::shared_ptr' または 'std::unique_ptr' への非 const lvalue 参照として宣言するべきである" id="35" impl="CODSTA-MCPP-35" severity="3"/>
            <rule autogen="true" header="パラメーターの型を 'std::shared_ptr' または 'std::unique_ptr' への rvalue 参照として宣言しない" id="36" impl="CODSTA-MCPP-36" severity="3"/>
            <rule autogen="true" header="追加の明示的な初期化を必要とせず、基底クラスのすべてのコンストラクターを必要とする派生クラスは、継承コンストラクターを使用する必要がある" id="37" impl="CODSTA-MCPP-37" severity="3"/>
            <rule autogen="true" header="変数の初期化には、等号なしの {} 括弧による初期化を使用する必要がある" id="38" impl="CODSTA-MCPP-38" severity="3"/>
            <rule autogen="true" header="auto 型の変数は、 {} または ={} を使用した括弧による初期化で初期化してはならない" id="39" impl="CODSTA-MCPP-39" severity="3"/>
            <rule autogen="true" header="'auto' 指定子を過度に使用しない" id="40" impl="CODSTA-MCPP-40" severity="3"/>
            <rule autogen="true" header="'random_shuffle' 識別子を使用するべきではない" id="41" impl="CODSTA-MCPP-41" severity="3"/>
            <rule autogen="true" header="bool 型のオペランドにインクリメント演算子 (++) を使用しない" id="42" impl="CODSTA-MCPP-42" severity="3"/>
            <rule autogen="true" header="'set_unexpected' 識別子を使用するべきではない" id="43" impl="CODSTA-MCPP-43" severity="3"/>
            <rule autogen="true" header="ラムダ式の中に別のラムダ式を定義するべきではない" id="44" impl="CODSTA-MCPP-44" severity="3"/>
            <rule autogen="true" header="void 型以外のラムダ式の戻り値型は明示的に指定するべきである" id="45" impl="CODSTA-MCPP-45" severity="3"/>
            <rule autogen="true" header="すべてのラムダ式にパラメーター リストを含める" id="46" impl="CODSTA-MCPP-46" severity="3"/>
            <rule autogen="true" header="std::initializer_list でコンストラクターをオーバーロードしない" id="47" impl="CODSTA-MCPP-47" severity="3"/>
            <rule autogen="true" header="関数の複数の出力値は構造体またはタプルとして返すべきである" id="48" impl="CODSTA-MCPP-48" severity="3"/>
            <rule autogen="true" header="ユーザー定義のコピー代入演算子およびムーブ代入演算子は、ユーザー定義の例外をスローしないスワップ関数を使用するべきである" id="49" impl="CODSTA-MCPP-49" severity="3"/>
            <rule autogen="true" header="コンテナーのすべての要素をループし、ループ カウンターを使用していない for ループを使用してはならない" id="50" impl="CODSTA-MCPP-50" severity="3"/>
            <rule autogen="true" header="結果がただちに const iterator に変換される場合、const コンテナーの呼び出しを使用する" id="51" impl="CODSTA-MCPP-51" severity="3"/>
            <rule autogen="true" header="final クラスに仮想関数を導入しない" id="52" impl="CODSTA-MCPP-52" severity="3"/>
            <rule autogen="true" header="const または const &amp; 型で宣言されたオブジェクトに std::move を使用しない" id="53" impl="CODSTA-MCPP-53" severity="3"/>
            <rule autogen="true" header="std::array の rvalue 参照を作成しない" id="54" impl="CODSTA-MCPP-54" severity="3"/>
         </category>
         <rule autogen="true" header="配列要素には、配列演算子 [ ] によってアクセスするべきである" id="01" impl="CODSTA-01" severity="3"/>
         <rule autogen="true" header="メンバ変数をビット フィールドとして宣言してはいけない" id="02" impl="CODSTA-02" severity="5"/>
         <rule autogen="true" header="#define を使用して定数を定義しない" id="03" impl="CODSTA-03" severity="3"/>
         <rule autogen="true" header="static を使ってローカル変数を宣言してはいけない" id="04" impl="CODSTA-04" severity="5"/>
         <rule autogen="true" header="ポインタへのポインタは可能な限り避けるべきである" id="05" impl="CODSTA-05" severity="3"/>
         <rule autogen="true" header="?: 演算子を使ってはいけない" id="06" impl="CODSTA-06" severity="3"/>
         <rule autogen="true" header="関数にパラメータがない場合、(void) ではなく () を使用する" id="07" impl="CODSTA-07" severity="3"/>
         <rule autogen="true" header="for ループ中で break を使ってはいけない" id="08" impl="CODSTA-08" severity="2"/>
         <rule autogen="true" header="関数へのポインタを基本型へのポインタにキャストしてはいけない" id="09" impl="CODSTA-09" severity="3"/>
         <rule autogen="true" header="ストレージタイプ修飾子は、変数や関数ではなく、型に関連付けなければならない" id="10" impl="CODSTA-10" severity="3"/>
         <rule autogen="true" header="算術演算で符号ありの値と符号なしの値を混在させてはならない" id="100" impl="CODSTA-100" severity="3"/>
         <rule autogen="true" header="条件演算子の 2 番目のオペランドと 3 番目のオペランドに符号ありの値と符号なしの値を混在させてはならない" id="101" impl="CODSTA-101" severity="3"/>
         <rule autogen="true" header="副作用がある単一の演算子は適切なコンテキストでだけ使用する" id="102" impl="CODSTA-102" severity="3"/>
         <rule autogen="true" header="副作用がある関数の呼び出しは適切なコンテキストでだけ使用する" id="103" impl="CODSTA-103" severity="3"/>
         <rule autogen="true" header="論理演算子 &amp;&amp; または || のオペランドに二項演算子が含まれる場合、オペランドを括弧で囲む必要がある" id="104" impl="CODSTA-104" severity="3"/>
         <rule autogen="true" header="3 項演算子 '?:' の 2 番目または 3 番目のオペランドに副作用があってはならない" id="105" impl="CODSTA-105" severity="4"/>
         <rule autogen="true" header="&lt;stdlib.h&gt; のライブラリ関数 bsearch および qsort を使用してはいけない" id="107" impl="CODSTA-107" severity="3"/>
         <rule autogen="true" header="&lt;tgmath.h&gt; ヘッダーをインクルードしない" id="108" impl="CODSTA-108" severity="3"/>
         <rule autogen="true" header="&lt;fenv.h&gt; の例外処理を使用してはいけない" id="109" impl="CODSTA-109" severity="4"/>
         <rule autogen="true" header="Assert を多く使用して内部的な仮定条件や不変条件を文書化する" id="11" impl="CODSTA-11" severity="5"/>
         <rule autogen="true" header="標準ライブラリの入出力関数を使用してはいけない" id="110" impl="CODSTA-110" severity="3"/>
         <rule autogen="true" header="union キーワードを使用してはいけない" id="111" impl="CODSTA-111" severity="3"/>
         <rule autogen="true" header="可変長配列を使用してはいけない" id="112" impl="CODSTA-112" severity="3"/>
         <rule autogen="true" header="フレキシブル配列メンバーを宣言してはいけない" id="113" impl="CODSTA-113" severity="3"/>
         <rule autogen="true" header="アセンブリ言語はカプセル化して C/C++ 関数で分離しなければならない" id="114" impl="CODSTA-114" severity="3"/>
         <rule autogen="true" header="構造体または共用体を指すポインターが翻訳単位内で 1 回も間接参照されない場合、オブジェクトの実装を隠すべきである" id="115" impl="CODSTA-115" severity="4"/>
         <rule autogen="true" header="'default' ラベルがある場合、 'default' ラベルは switch 文の最初または最後の switch ラベルとして出現しなければならない" id="116" impl="CODSTA-116" severity="3"/>
         <rule autogen="true" header="8 進または 16 進のエスケープ シーケンスは終了させなければならない" id="117" impl="CODSTA-117" severity="3"/>
         <rule autogen="true" header="外部リンケージを持つオブジェクトまたは関数を定義する場合、宣言が参照できなければならない" id="118" impl="CODSTA-118" severity="3"/>
         <rule autogen="true" header="default ラベルの終了の break の前に 文またはコメントがなければならない" id="119" impl="CODSTA-119" severity="3"/>
         <rule autogen="true" header="算術演算の代わりにシフト演算を使用するのは避ける" id="12" impl="CODSTA-12" severity="3"/>
         <rule autogen="true" header="インライン関数は static 記憶域クラスを使って宣言しなければならない" id="120" impl="CODSTA-120" severity="3"/>
         <rule autogen="true" header="restrict 型修飾子を使用してはいけない" id="121" impl="CODSTA-121" severity="3"/>
         <rule autogen="true" header="戻り型が void ではない関数によって返却される値を使用しなければならない" id="122_a" impl="CODSTA-122_a" severity="3"/>
         <rule autogen="true" header="戻り型が void ではない関数によって返却される値を使用しなければならない" id="122_b" impl="CODSTA-122_b" severity="3"/>
         <rule autogen="true" header="インクリメント (++) またはデクリメント (--) 演算子がある完全な式は、他の副作用の可能性があってはならない" id="123" impl="CODSTA-123" severity="4"/>
         <rule autogen="true" header="関数へのポインターとそれ以外の型との間で変換を行ってはならない" id="124_a" impl="CODSTA-124_a" severity="3"/>
         <rule autogen="true" header="互換性のない関数型へのポインターの間で変換を行ってはならない" id="124_b" impl="CODSTA-124_b" severity="3"/>
         <rule autogen="true" header="不完全型へのポインターと他の型との間で変換を行ってはならない" id="125" impl="CODSTA-125" severity="3"/>
         <rule autogen="true" header="オブジェクト型へのポインターと別のオブジェクト型へのポインターとの間で変換を行ってはならない" id="126" impl="CODSTA-126" severity="3"/>
         <rule autogen="true" header="オブジェクトへのポインターと整数型との間で変換を行ってはならない" id="127" impl="CODSTA-127" severity="4"/>
         <rule autogen="true" header="オブジェクト型へのポインターと 'uintptr_t' または 'intptr_t' 以外の整数型の間で変換を行うべきではない" id="127_b" impl="CODSTA-127_b" severity="4"/>
         <rule autogen="true" header="void へのポインターをオブジェクトへのポインターに変換してはならない" id="128" impl="CODSTA-128" severity="4"/>
         <rule autogen="true" header="void へのポインターと数値型との間でキャストしてはならない" id="129_a" impl="CODSTA-129_a" severity="3"/>
         <rule autogen="true" header="void へのポインターと数値型との間で暗黙の変換を行ってはならない" id="129_b" impl="CODSTA-129_b" severity="3"/>
         <rule autogen="true" header="同じ配列を指している場合を除き、ポインター型に &gt;、&gt;=、&lt;、&lt;= を適用してはならない" id="13" impl="CODSTA-13" severity="3"/>
         <rule autogen="true" header="オブジェクトへのポインターと非整数数値型との間でキャストしてはならない" id="130" impl="CODSTA-130" severity="3"/>
         <rule autogen="true" header="null ポインター定数としてリテラルのゼロ (0) ではなく NULL を使用する" id="131" impl="CODSTA-131" severity="3"/>
         <rule autogen="true" header="関数のパラメーターを変更するべきではない" id="132" impl="CODSTA-132" severity="4"/>
         <rule autogen="true" header="C90 のキーワードと同じ名前を持つマクロを定義してはならない" id="133_a" impl="CODSTA-133_a" severity="3"/>
         <rule autogen="true" header="C99 のキーワードと同じ名前を持つマクロを定義してはならない" id="133_b" impl="CODSTA-133_b" severity="3"/>
         <rule autogen="true" header="配列型として宣言されたパラメーターに対応する関数引数には、適切な数の要素がなければならない" id="134" impl="CODSTA-134" severity="4"/>
         <rule autogen="true" header="他の型からポインター型へのキャスト、またはポインター型からのキャストを使用してはならない" id="135" impl="CODSTA-135" severity="3"/>
         <rule autogen="true" header="識別子 va_list、va_arg、va_start、va_end、va_copy を使用するべきではない" id="136_a" impl="CODSTA-136_a" severity="3"/>
         <rule autogen="true" header="識別子 va_list、va_arg、va_start、va_end を使用するべきではない" id="136_b" impl="CODSTA-136_b" severity="3"/>
         <rule autogen="true" header="関数の呼び出しを sizeof 演算子のオペランドとして使用してはならない" id="137" impl="CODSTA-137" severity="3"/>
         <rule autogen="true" header="組み込みの代入演算子の結果を使用するべきではない" id="138" impl="CODSTA-138" severity="3"/>
         <rule autogen="true" header="ポインターの減算は、同じ配列の要素を指すポインターにだけ適用する" id="13_b" impl="CODSTA-13_b" severity="3"/>
         <rule autogen="true" header="絶対に const を non-const に変換してはいけない" id="14" impl="CODSTA-14" severity="3"/>
         <rule autogen="true" header="初期化リストに永続的な副作用が含まれていてはならない" id="141_a" impl="CODSTA-141_a" severity="3"/>
         <rule autogen="true" header="グローバル関数は配列型のパラメーターを宣言してはならない" id="142" impl="CODSTA-142" severity="2"/>
         <rule autogen="true" header="配列引数を使用して呼び出される関数はポインター型のパラメーターを宣言してはならない" id="142_b" impl="CODSTA-142_b" severity="3"/>
         <rule autogen="true" header="コピー元バッファーのサイズをチェックしていない、疑わしい strcpy の使用" id="143" impl="CODSTA-143" severity="3"/>
         <rule autogen="true" header="read および readlink 関数から返される値を使用する" id="144" impl="CODSTA-144" severity="3"/>
         <rule autogen="true" header="null 終端された文字列を期待する関数での null 終端されていない可能性がある文字列の使用" id="145" impl="CODSTA-145" severity="3"/>
         <rule autogen="true" header="stdio 文字 I/O 関数の戻り値を int より小さい型に暗黙的に変換してはならない" id="146" impl="CODSTA-146" severity="3"/>
         <rule autogen="true" header="関係演算子 &lt;、&gt;、&gt;=、&lt;= を使用してポインターと NULL を比較してはならない" id="147" impl="CODSTA-147" severity="3"/>
         <rule autogen="true" header="等価演算子または関係演算子のオペランドとして文字列リテラルを使用しない" id="148" impl="CODSTA-148" severity="3"/>
         <rule autogen="true" header="switch 文の case の間に break 文がない" id="149" impl="CODSTA-149" severity="3"/>
         <rule autogen="true" header="関数のパラメータとして渡される配列の大きさを宣言してはいけない" id="15" impl="CODSTA-15" severity="2"/>
         <rule autogen="true" header="アサーションに代入、インクリメント、またはデクリメント演算子を含めてはならない" id="150" impl="CODSTA-150" severity="3"/>
         <rule autogen="true" header="アサーションに関数の呼び出しや関数マクロの呼び出しを含めてはならない" id="150_b" impl="CODSTA-150_b" severity="5"/>
         <rule autogen="true" header="安全ではないマクロの引数での副作用を避ける" id="150_c" impl="CODSTA-150_c" severity="3"/>
         <rule autogen="true" header="ブール条件で列挙型を使用しない" id="151" impl="CODSTA-151" severity="4"/>
         <rule autogen="true" header="複合式の値を別の実質的な型カテゴリまたはより大きい実質的な型にキャストしてはならない" id="152" impl="CODSTA-152" severity="3"/>
         <rule autogen="true" header="翻訳単位の中で、外部オブジェクトまたは外部関数に 2 つ以上の非定義宣言があってはならない" id="154" impl="CODSTA-154" severity="3"/>
         <rule autogen="true" header="C99 規格のコードでは、独自の typedef を宣言する代わりに stdint.h の typedef を使用する" id="155" impl="CODSTA-155" severity="3"/>
         <rule autogen="true" header="通常の数値変換が行われる演算子のオペランドの 1 つとして複合式が使用される場合、他方のオペランドはより大きい実質的な型を持つ型であってはならない" id="156_a" impl="CODSTA-156_a" severity="3"/>
         <rule autogen="true" header="条件演算子の (2 つ目または 3 つ目の) オペランドとして複合式が使用される場合、他のオペランドはより大きい実質的な型を持つ型であってはならない" id="156_b" impl="CODSTA-156_b" severity="3"/>
         <rule autogen="true" header="複合式の値をより大きい実質的な型を持つオブジェクトに代入してはならない" id="157" impl="CODSTA-157" severity="3"/>
         <rule autogen="true" header="関数型には名前付きのパラメーターがなければならない" id="158" impl="CODSTA-158" severity="3"/>
         <rule autogen="true" header="関数型はプロトタイプ形式でなければならない" id="159" impl="CODSTA-159" severity="3"/>
         <rule autogen="true" header="配列を初期化する場合、配列の大きさを宣言してはいけない" id="16" impl="CODSTA-16" severity="2"/>
         <rule autogen="true" header="配列パラメーターの宣言の [ ] の中に static キーワードが含まれていてはならない" id="160" impl="CODSTA-160" severity="2"/>
         <rule autogen="true" header="オペランドがブール値として解釈される場合、常に実質的なブール型の式を使用するべきである" id="161_a" impl="CODSTA-161_a" severity="3"/>
         <rule autogen="true" header="オペランドが数値として解釈される場合、実質的なブール型のオペランドを使用するべきではない" id="161_b" impl="CODSTA-161_b" severity="3"/>
         <rule autogen="true" header="オペランドが数値として解釈される場合、実質的な文字型のオペランドを使用するべきではない" id="161_c" impl="CODSTA-161_c" severity="3"/>
         <rule autogen="true" header="算術演算では実質的な列挙型のオペランドを使用するべきではない" id="161_d" impl="CODSTA-161_d" severity="3"/>
         <rule autogen="true" header="実質的な signed 型または列挙型のオペランドに対してシフトおよびビット演算を行うべきではない" id="161_e" impl="CODSTA-161_e" severity="3"/>
         <rule autogen="true" header="ビット シフト演算の右辺のオペランドとして実質的な signed 型または列挙型のオペランドを使用するべきではない" id="161_f" impl="CODSTA-161_f" severity="3"/>
         <rule autogen="true" header="単項マイナス演算子のオペランドとして実質的な unsigned 型のオペランドを使用するべきではない" id="161_g" impl="CODSTA-161_g" severity="3"/>
         <rule autogen="true" header="実質的な文字型の式を加算または減算演算で不適切に使用するべきではない" id="162" impl="CODSTA-162" severity="3"/>
         <rule autogen="true" header="式の値をより小さい実質的な型を持つオブジェクトに代入してはならない" id="163_a" impl="CODSTA-163_a" severity="3"/>
         <rule autogen="true" header="式の値を実質的な型カテゴリが異なるオブジェクトに代入してはならない" id="163_b" impl="CODSTA-163_b" severity="3"/>
         <rule autogen="true" header="通常の算術変換が行われる演算子の 2 つのオペランドは、同じ実質的な型カテゴリでなければならない" id="164_a" impl="CODSTA-164_a" severity="3"/>
         <rule autogen="true" header="3 項演算子の 2 番目および 3 番目のオペランドは同じ実質的な型カテゴリでなければならない" id="164_b" impl="CODSTA-164_b" severity="3"/>
         <rule autogen="true" header="実質的な列挙型へのキャスト演算は許されない" id="165_a" impl="CODSTA-165_a" severity="4"/>
         <rule autogen="true" header="実質的なブール型から、また実質的なブール型にキャストしてはならない" id="165_b" impl="CODSTA-165_b" severity="3"/>
         <rule autogen="true" header="実質的な文字型と実質的な浮動小数点型の間でキャストしてはならない" id="165_c" impl="CODSTA-165_c" severity="4"/>
         <rule autogen="true" header="FILE オブジェクトへのポインターを間接参照してはいけない" id="166_a" impl="CODSTA-166_a" severity="2"/>
         <rule autogen="true" header="FILE オブジェクトへのポインターをライブラリ関数から間接参照してはいけない" id="166_b" impl="CODSTA-166_b" severity="2"/>
         <rule autogen="true" header="for ループのカウンターは、実質的な浮動小数点型であってはならない" id="167_a" impl="CODSTA-167_a" severity="3"/>
         <rule autogen="true" header="while および do-while ループのカウンターは、実質的な浮動小数点型であってはならない" id="167_b" impl="CODSTA-167_b" severity="3"/>
         <rule autogen="true" header="for ループにはループ カウンターが 1 つだけあること、またループ カウンターが for ループ本文で変更されてはならない" id="168" impl="CODSTA-168" severity="3"/>
         <rule autogen="true" header="for ループの最初の句は整形式でなければならない" id="169_a" impl="CODSTA-169_a" severity="3"/>
         <rule autogen="true" header="for ループの 2 番目の句は整形式でなければならない" id="169_b" impl="CODSTA-169_b" severity="3"/>
         <rule autogen="true" header="for ループの 3 番目の句は整形式でなければならない" id="169_c" impl="CODSTA-169_c" severity="3"/>
         <rule autogen="true" header="NULL 識別子を使用してはならない。代わりに 0 を使用する" id="17" impl="CODSTA-17" severity="3"/>
         <rule autogen="true" header="プリプロセスの前に存在するマクロの名前は、プリプロセス後に存在する識別子と違っているべきである (c90)" id="170_c90" impl="CODSTA-170_c90" severity="3"/>
         <rule autogen="true" header="プリプロセスの前に存在するマクロの名前は、プリプロセス後に存在する識別子と違っているべきである (c99)" id="170_c99" impl="CODSTA-170_c99" severity="3"/>
         <rule autogen="true" header="マクロの名前はマクロのパラメーターと違っているべきである(c90)" id="171_c90" impl="CODSTA-171_c90" severity="3"/>
         <rule autogen="true" header="マクロの名前はマクロのパラメーターと違っているべきである (c99)" id="171_c99" impl="CODSTA-171_c99" severity="3"/>
         <rule autogen="true" header="マクロの名前は現在定義されている他のマクロの名前と違っているべきである(c90)" id="172_c90" impl="CODSTA-172_c90" severity="3"/>
         <rule autogen="true" header="マクロの名前は現在定義されている他のマクロの名前と違っているべきである(c99)" id="172_c99" impl="CODSTA-172_c99" severity="3"/>
         <rule autogen="true" header="プログラムは規格によって定められた翻訳限界を超えてはならない (c90)" id="174_a_c90" impl="CODSTA-174_a_c90" severity="3"/>
         <rule autogen="true" header="プログラムは規格によって定められた翻訳限界を超えてはならない (c99)" id="174_a_c99" impl="CODSTA-174_a_c99" severity="3"/>
         <rule autogen="true" header="プログラムは規格によって定められた翻訳限界を超えてはならない (c90)" id="174_b_c90" impl="CODSTA-174_b_c90" severity="3"/>
         <rule autogen="true" header="プログラムは規格によって定められた翻訳限界を超えてはならない (c99)" id="174_b_c99" impl="CODSTA-174_b_c99" severity="3"/>
         <rule autogen="true" header="関数は未使用の型宣言を持つべきではない" id="175_a" impl="CODSTA-175_a" severity="4"/>
         <rule autogen="true" header="ソース ファイルは未使用の型宣言を持つべきではない" id="175_b" impl="CODSTA-175_b" severity="4"/>
         <rule autogen="true" header="関数は未使用のローカル タグ宣言を持つべきではない" id="176_a" impl="CODSTA-176_a" severity="4"/>
         <rule autogen="true" header="ソース ファイルは未使用のタグ宣言を持つべきではない" id="176_b" impl="CODSTA-176_b" severity="4"/>
         <rule autogen="true" header="ソース ファイルは未使用のマクロ宣言を持つべきではない" id="177" impl="CODSTA-177" severity="4"/>
         <rule autogen="true" header="外部識別子は区別できなければならない" id="178" impl="CODSTA-178" severity="3"/>
         <rule autogen="true" header="ファイル スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c90)" id="179_a_c90" impl="CODSTA-179_a_c90" severity="3"/>
         <rule autogen="true" header="ファイル スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c99)" id="179_a_c99" impl="CODSTA-179_a_c99" severity="3"/>
         <rule autogen="true" header="同じブロック スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c90)" id="179_b_c90" impl="CODSTA-179_b_c90" severity="3"/>
         <rule autogen="true" header="同じブロック スコープおよび同じ名前空間で宣言された識別子は区別できなければならない (c99)" id="179_b_c99" impl="CODSTA-179_b_c99" severity="3"/>
         <rule autogen="true" header="do 文よりも while 文を使用する" id="18" impl="CODSTA-18" severity="5"/>
         <rule autogen="true" header="外部リンケージを持つオブジェクトや関数を定義する識別子はユニークでなければならない" id="180" impl="CODSTA-180" severity="3"/>
         <rule autogen="true" header="+、-、+= および -= 演算子をポインター型の式に適用するべきではない" id="181" impl="CODSTA-181" severity="4"/>
         <rule autogen="true" header="sizeof 演算子のオペランドは「配列型」として宣言された関数のパラメーターであってはならない" id="182" impl="CODSTA-182" severity="2"/>
         <rule autogen="true" header="標準ライブラリ関数 memcmp、memmove および memcmp へのポインター引数は、互換性のある型の修飾付きおよび修飾なし版へのポインターでなければならない" id="183" impl="CODSTA-183" severity="3"/>
         <rule autogen="true" header="標準ライブラリ関数 memcmp へのポインター引数は、ポインター型、実質的な signed 型、実質的な unsigned 型、実質的なブール型、または実質的な列挙型を指していなければならない" id="184" impl="CODSTA-184" severity="3"/>
         <rule autogen="true" header="標準ライブラリ関数 localeconv、getenv、setlocale または strerror から返されたポインターは、const 修飾された型へのポインターとしてだけ使用する" id="185_a" impl="CODSTA-185_a" severity="2"/>
         <rule autogen="true" header="lconv 構造体のメンバーによって指し示される文字列を変更してはならない" id="185_b" impl="CODSTA-185_b" severity="3"/>
         <rule autogen="true" header="指定された初期化子が配列オブジェクトの初期化に使用されている場合、配列のサイズを明示的に指定する必要がある" id="186" impl="CODSTA-186" severity="3"/>
         <rule autogen="true" header="より大きな整数サイズに代入する前に文字を unsigned char にキャストする" id="187_a" impl="CODSTA-187_a" severity="3"/>
         <rule autogen="true" header="'signed char' 型の式を配列インデックスとして使用するべきではない" id="187_b" impl="CODSTA-187_b" severity="3"/>
         <rule autogen="true" header="より大きな整数サイズに変換する前に文字を unsigned char にキャストする" id="187_c" impl="CODSTA-187_c" severity="3"/>
         <rule autogen="true" header="ナロー文字列とワイド文字列を混同しない" id="188" impl="CODSTA-188" severity="3"/>
         <rule autogen="true" header="ポインターに対して、スケールされた整数値の加算または減算を行わない" id="189" impl="CODSTA-189" severity="3"/>
         <rule autogen="true" header="文字テストには ctype.h を使用する" id="19" impl="CODSTA-19" severity="3"/>
         <rule autogen="true" header="浮動小数点値の比較にオブジェクト表現を使用しない" id="190" impl="CODSTA-190" severity="3"/>
         <rule autogen="true" header="不正に再開される可能性がある関数をループに入れる" id="191" impl="CODSTA-191" severity="3"/>
         <rule autogen="true" header="サイズ 0 または 1 の配列を構造体の最後のメンバーにするべきではない" id="192" impl="CODSTA-192" severity="3"/>
         <rule autogen="true" header="可変長配列メンバーを含む構造体は動的に割り当てる" id="193" impl="CODSTA-193" severity="3"/>
         <rule autogen="true" header="誤って失敗する可能性がある関数をループに入れる" id="194" impl="CODSTA-194" severity="3"/>
         <rule autogen="true" header=" 1 つの式の中で 2 回アトミックな変数を参照しない" id="195" impl="CODSTA-195" severity="3"/>
         <rule autogen="true" header="関数呼び出しの結果内の配列にアクセスしない" id="196" impl="CODSTA-196" severity="3"/>
         <rule autogen="true" header="文字列リテラルで初期化される文字配列の上限を指定しない" id="197" impl="CODSTA-197" severity="2"/>
         <rule autogen="true" header="浮動小数点型の複合式の値をより広い浮動小数点型にキャストするべきではない" id="198" impl="CODSTA-198" severity="3"/>
         <rule autogen="true" header="浮動小数点型の複合式の値を整数型にキャストするべきではない" id="198_b" impl="CODSTA-198_b" severity="3"/>
         <rule autogen="true" header="アサーションを使用しない" id="199" impl="CODSTA-199" severity="3"/>
         <rule autogen="true" header="文字列を終了させるには、NULL ではなく EOS を 使うべきである" id="20" impl="CODSTA-20" severity="2"/>
         <rule autogen="true" header="初期化子内の配列宣言に明示的に配列の上限を指定する" id="200" impl="CODSTA-200" severity="3"/>
         <rule autogen="true" header="構造化テキストデータをネイティブに処理しない" id="201" impl="CODSTA-201" severity="3"/>
         <rule autogen="true" header="外部リンケージを持つ関数のインライン定義には、静的オブジェクトの定義や使用が含まれていてはならない" id="202" impl="CODSTA-202" severity="2"/>
         <rule autogen="true" header="文字列リテラルをハード コードしない" id="203" impl="CODSTA-203" severity="5"/>
         <rule autogen="true" header="'noreturn' として宣言された関数の戻り値の型は 'void' でなければならない" id="204" impl="CODSTA-204" severity="3"/>
         <rule autogen="true" header="配列のサイズよりも大きな構造体を指すポインターに配列をキャストしてはならない" id="205" impl="CODSTA-205" severity="3"/>
         <rule autogen="true" header="'_Noreturn' 関数指定子を使用するべきではない" id="206" impl="CODSTA-206" severity="3"/>
         <rule autogen="true" header="&lt;stdnoreturn.h&gt; ヘッダー ファイルを使用するべきではない" id="207" impl="CODSTA-207" severity="3"/>
         <rule autogen="true" header="&lt;stdalign.h&gt; ヘッダー ファイルを使用してはならない" id="208" impl="CODSTA-208" severity="3"/>
         <rule autogen="true" header="&lt;stdatomic.h&gt; によって提供される機能を使用するべきではない" id="209" impl="CODSTA-209" severity="3"/>
         <rule autogen="true" header="enum を使う場合、各メンバの値は明示的に宣言するべきである" id="21" impl="CODSTA-21" severity="5"/>
         <rule autogen="true" header="'_Thread_local' 記憶域クラス指定子を使用するべきではない" id="210" impl="CODSTA-210" severity="3"/>
         <rule autogen="true" header="&lt;threads.h&gt; によって提供される機能を使用するべきではない" id="211" impl="CODSTA-211" severity="3"/>
         <rule autogen="true" header="'rsize_t' 型を使用するべきではない" id="212" impl="CODSTA-212" severity="3"/>
         <rule autogen="true" header="'_Alignas' アライメント指定子および '_Alignof' 演算子を使用するべきではない" id="213" impl="CODSTA-213" severity="3"/>
         <rule autogen="true" header="'_Atomic' 型指定子および '_Atomic' 型修飾子を使用するべきではない" id="214" impl="CODSTA-214" severity="3"/>
         <rule autogen="true" header="'__STDC_WANT_LIB_EXT1__' マクロを '0' 以外の値に定義するべきではない" id="215" impl="CODSTA-215" severity="3"/>
         <rule autogen="true" header="'_Generic' 演算子を使用するべきではない" id="216" impl="CODSTA-216" severity="3"/>
         <rule autogen="true" header="'errno_t' 型を使用するべきではない" id="217" impl="CODSTA-217" severity="3"/>
         <rule autogen="true" header="次のマクロを使用しない: RSIZE_MAX、L_tmpnam_s、TMP_MAX_S" id="218" impl="CODSTA-218" severity="3"/>
         <rule autogen="true" header="Annex K of ISO/IEC 9899:2011 規格で定義された関数を使用してはならない" id="219" impl="CODSTA-219" severity="3"/>
         <rule autogen="true" header="ローカル変数またはパラメータの名前と、クラスのメンバ変数または親クラス/構造体のメンバ変数の名前は、2 文字以上違いがなければならない" id="22" impl="CODSTA-22" severity="1"/>
         <rule autogen="true" header="整数定数マクロの引数は、適切な値を持つ 10 進数、8 進数、16 進数定数であるべきである" id="220" impl="CODSTA-220" severity="3"/>
         <rule autogen="true" header="関数型の仕様に修飾子を含めてはならない" id="221" impl="CODSTA-221" severity="3"/>
         <rule autogen="true" header="より広い型からより狭い型への暗黙的な整数変換を避ける" id="222" impl="CODSTA-222" severity="3"/>
         <rule autogen="true" header="基本数値型の代わりにサイズと符合を指定した &lt;cstdint&gt; の固定幅整数型を使用する" id="223" impl="CODSTA-223" severity="3"/>
         <rule autogen="true" header="if ステートメントには必ず else 句を入れるべきである" id="23" impl="CODSTA-23" severity="3"/>
         <rule autogen="true" header="FALSE は 0 (ゼロ) として定義しなければならない" id="24" impl="CODSTA-24" severity="5"/>
         <rule autogen="true" header="FALSE は明示的に値 0 で初期化しなければならない" id="25" impl="CODSTA-25" severity="5"/>
         <rule autogen="true" header="マジック ナンバーを使用しない" id="26" impl="CODSTA-26" severity="3"/>
         <rule autogen="true" header="関数でグローバル変数を変更することは避ける" id="27" impl="CODSTA-27" severity="3"/>
         <rule autogen="true" header="共用体宣言に対してフィールドを定義する" id="28" impl="CODSTA-28" severity="5"/>
         <rule autogen="true" header="可能な限り、ハード コーディングされた値ではなく &#34;#define&#34; または enum 定数を使用するべきである" id="29" impl="CODSTA-29" severity="3"/>
         <rule autogen="true" header="関数パラメータのハンドルを返さない" id="30" impl="CODSTA-30" severity="3"/>
         <rule autogen="true" header="明示的型変換 (キャスト) を使用してはならない" id="31" impl="CODSTA-31" severity="3"/>
         <rule autogen="true" header="test がポインタの場合、if(test) または if(!test) タイプの論理式を作成しない" id="32" impl="CODSTA-32" severity="3"/>
         <rule autogen="true" header="if、while、switch の条件部で演算子 ++ または -- を使ってはいけない" id="33" impl="CODSTA-33" severity="3"/>
         <rule autogen="true" header="関数ポインタを宣言する場合は、typedef を使用してプログラムの構文を簡潔にする" id="34" impl="CODSTA-34" severity="3"/>
         <rule autogen="true" header="必ず switch 文にデフォルト ブランチを用意する" id="35" impl="CODSTA-35" severity="3"/>
         <rule autogen="true" header="基本データ型は、値を使用しない限り参照を使用しない" id="36" impl="CODSTA-36" severity="3"/>
         <rule autogen="true" header="単純な定数の場合は #define ではなく const オブジェクトまたは列挙型を使用する" id="37" impl="CODSTA-37" severity="3"/>
         <rule autogen="true" header="コンパイラが型チェックできない #define を使ってはいけない" id="38" impl="CODSTA-38" severity="3"/>
         <rule autogen="true" header="C++ 予約語との内部または外部の名前の競合を避ける" id="39" impl="CODSTA-39" severity="1"/>
         <rule autogen="true" header="関数の引数または戻り値がない場合、void を使用する" id="40" impl="CODSTA-40" severity="3"/>
         <rule autogen="true" header="1 つしか case のない switch 文の使用は避ける" id="41" impl="CODSTA-41" severity="4"/>
         <rule autogen="true" header="TRUE は 1 として定義しなければならない" id="42" impl="CODSTA-42" severity="5"/>
         <rule autogen="true" header="TRUE は明示的に値 1 で初期化しなければならない" id="43" impl="CODSTA-43" severity="5"/>
         <rule autogen="true" header="ローカル変数はメンバー変数と同じ名前を使用してはならない" id="44" impl="CODSTA-44" severity="1"/>
         <rule autogen="true" header="パラメーターはメンバー変数と同じ名前を使用してはならない" id="45" impl="CODSTA-45" severity="1"/>
         <rule autogen="true" header="実用的な場合は常に、負論理よりも正論理を使用する" id="46" impl="CODSTA-46" severity="5"/>
         <rule autogen="true" header="すべての構造体が typedef 宣言されなければならない" id="47" impl="CODSTA-47" severity="3"/>
         <rule autogen="true" header="次の 2 文字表記を使用しない &lt;%、%&gt;、&lt;:、:&gt;、%:、%:%:" id="48" impl="CODSTA-48" severity="3"/>
         <rule autogen="true" header="初期化式またはインクリメント式のない for ループ文を使用しない。代わりに while ループを使用する" id="49" impl="CODSTA-49" severity="3"/>
         <rule autogen="true" header="16 進定数はすべて大文字で表記する" id="50" impl="CODSTA-50" severity="3"/>
         <rule autogen="true" header="リテラル接尾辞は小文字ではなく大文字を使用する" id="51" impl="CODSTA-51" severity="2"/>
         <rule autogen="true" header="for ループの初期化式は、1 つのループ パラメータの値を初期化する以外の処理を行ってはならない" id="52" impl="CODSTA-52" severity="3"/>
         <rule autogen="true" header="for ループのインクリメント式は、1 つのループ パラメータを次の値に変更する以外の処理を行ってはならない" id="53" impl="CODSTA-53" severity="3"/>
         <rule autogen="true" header="switch 文には 2 つ以上の case と 1 つの default がなければならない" id="54" impl="CODSTA-54" severity="3"/>
         <rule autogen="true" header="整数型や定数ではなく列挙型をケース ラベルとして使用する" id="55" impl="CODSTA-55" severity="2"/>
         <rule autogen="true" header="switch 文のすべての case および default ラベルには、明示的な break または return 文、あるいは &#34;フォールスルー&#34; コメントがなければならない" id="56" impl="CODSTA-56" severity="3"/>
         <rule autogen="true" header="疑わしいセミコロンの使用" id="57" impl="CODSTA-57" severity="4"/>
         <rule autogen="true" header="void にキャストしてはならない" id="58" impl="CODSTA-58" severity="4"/>
         <rule autogen="true" header="ハードコーディングされた配列宣言および malloc の呼び出しを使用してはならない" id="59" impl="CODSTA-59" severity="4"/>
         <rule autogen="true" header="等価演算子 (==、!=) を使用してマクロ/列挙定数 TRUE と値を比較してはならない" id="60" impl="CODSTA-60" severity="3"/>
         <rule autogen="true" header="列挙型のすべての値をテストするのでない限り、switch 文の最後の節は default 節でなければならない" id="61" impl="CODSTA-61" severity="3"/>
         <rule autogen="true" header="関数へのポインタを他のポインタ型にキャストで変換してはならない" id="62" impl="CODSTA-62" severity="3"/>
         <rule autogen="true" header="ビット演算子は潜在型が符号なしのオペランドにだけ適用する" id="63" impl="CODSTA-63" severity="3"/>
         <rule autogen="true" header="空でない switch 節は無条件の throw 文または break 文で終了しなければならない" id="64" impl="CODSTA-64" severity="3"/>
         <rule autogen="true" header="整数型のオブジェクトまたは void 型へのポインタをポインタ型のオブジェクトに変換してはならない" id="65" impl="CODSTA-65" severity="3"/>
         <rule autogen="true" header="2 項ビット演算子の定数ではないオペランドは同じ潜在型でなければならない" id="66" impl="CODSTA-66" severity="3"/>
         <rule autogen="true" header="オブジェクト、関数の戻り値、関数のパラメータとして使用される型は、すべての宣言および再宣言ですべてのトークンが同じでなければならない" id="67" impl="CODSTA-67" severity="3"/>
         <rule autogen="true" header="すべての符号なし型の 8 進数および 16 進数整数リテラルには、接尾辞 U を適用する" id="68" impl="CODSTA-68" severity="3"/>
         <rule autogen="true" header="単純な char 型および wchar_t 型の式は、=、==、!=、および単項演算子 &amp; 以外の組み込み演算子のオペランドとして使用してはならない" id="69" impl="CODSTA-69" severity="3"/>
         <rule autogen="true" header="列挙型の式は、[ ]、=、==、!=、&lt;、&lt;=、&gt;、&gt;= および単項演算子 &amp; 以外の組み込み演算子のオペランドとして使用してはならない" id="70" impl="CODSTA-70" severity="3"/>
         <rule autogen="true" header="signed integer 型の名前付きのビットフィールドは 2 ビット以上の長さでなければならない" id="71" impl="CODSTA-71" severity="3"/>
         <rule autogen="true" header="アセンブラ命令は asm 宣言を使用して導入しなければならない" id="73" impl="CODSTA-73" severity="3"/>
         <rule autogen="true" header="ビットフィールドは列挙型であってはならない" id="74" impl="CODSTA-74" severity="3"/>
         <rule autogen="true" header="ビットフィールドはブール型、あるいは明示的な signed または unsigned の汎整数型でなければならない" id="75" impl="CODSTA-75" severity="3"/>
         <rule autogen="true" header="識別子 main をグローバルな main 関数以外の関数に使用してはならない" id="76" impl="CODSTA-76" severity="3"/>
         <rule autogen="true" header="goto 文は同じ関数ボディ内の後の部分に宣言されたラベルにジャンプしなければならない" id="77" impl="CODSTA-77" severity="3"/>
         <rule autogen="true" header="goto 文によって参照されるラベルは、同じブロックまたは goto 文を含む外側のブロックで宣言されなければならない" id="78" impl="CODSTA-78" severity="3"/>
         <rule autogen="true" header="反復文では、ループを終了するために複数の break 文または goto 文を使用してはならない" id="79" impl="CODSTA-79" severity="3"/>
         <rule autogen="true" header="continue 文は整形式の for ループ内でだけ使用する" id="80" impl="CODSTA-80" severity="3"/>
         <rule autogen="true" header="関数が内部リンケージを持つ場合、すべての再宣言に static 記憶域クラス指定子がなければならない" id="81" impl="CODSTA-81" severity="3"/>
         <rule autogen="true" header="無限ループを避ける" id="82" impl="CODSTA-82" severity="3"/>
         <rule autogen="true" header="空の無限ループを使用しない" id="82_b" impl="CODSTA-82_b" severity="3"/>
         <rule autogen="true" header="すべてのループには固定された上限または下限がなければならない" id="83" impl="CODSTA-83" severity="3"/>
         <rule autogen="true" header="無限ループ内の終了ポイントを避ける" id="85" impl="CODSTA-85" severity="3"/>
         <rule autogen="true" header="各関数内でパラメーターの妥当性を検証しなければならない" id="86" impl="CODSTA-86" severity="3"/>
         <rule autogen="true" header="2 階層以上の間接参照を使用してはならない" id="87" impl="CODSTA-87" severity="3"/>
         <rule autogen="true" header="関数ポインターを使用してはならない" id="88" impl="CODSTA-88" severity="3"/>
         <rule autogen="true" header="2 階層以上のポインター間接参照を宣言に含めてはならない" id="89" impl="CODSTA-89" severity="3"/>
         <rule autogen="true" header="論理演算子 '&amp;&amp;' または '||' の各オペランドは後置式でなければならない" id="90" impl="CODSTA-90" severity="3"/>
         <rule autogen="true" header="関数の出口は最大でも 1 つでなくてはならない" id="91" impl="CODSTA-91" severity="3"/>
         <rule autogen="true" header="標準ライブラリのマクロ、オブジェクトの名前を再利用してはならない" id="92" impl="CODSTA-92" severity="3"/>
         <rule autogen="true" header="予約済み識別子及び標準ライブラリのマクロや関数は、定義または再定義または定義の解消をしてはならない (C90 コード)" id="92_a" impl="CODSTA-92_a" severity="3"/>
         <rule autogen="true" header="予約済み識別子及び標準ライブラリのマクロや関数は、定義または再定義または定義の解消をしてはならない (C99 コード)" id="92_b" impl="CODSTA-92_b" severity="3"/>
         <rule autogen="true" header="標準ライブラリの関数の名前をオーバーライドしてはならない" id="93" impl="CODSTA-93" severity="5"/>
         <rule autogen="true" header="ポインターまたは配列型を宣言してはならない" id="94" impl="CODSTA-94" severity="3"/>
         <rule autogen="true" header="ポインター型を宣言してはならない" id="95" impl="CODSTA-95" severity="3"/>
         <rule autogen="true" header="ビット フィールドは明示的な unsigned 汎整数型または列挙型でなければならない" id="96" impl="CODSTA-96" severity="3"/>
         <rule autogen="true" header="算術演算より優先順位の低い演算子が使用されている場合、括弧を使用して式の順序を明確にする" id="97" impl="CODSTA-97" severity="3"/>
         <rule autogen="true" header="すべての if...else 構文は、最後に else 句または最後の else 句が必要ではない理由を表すコメントを必要とする" id="98" impl="CODSTA-98" severity="3"/>
         <rule autogen="true" header="比較演算で符号ありの値と符号なしの値を混在させてはならない" id="99" impl="CODSTA-99" severity="3"/>
      </category>
      <category description="コメント" name="COMMENT">
         <rule autogen="true" header="C++ スタイルのコメントを使用する" id="01" impl="COMMENT-01" severity="3"/>
         <rule autogen="true" header="著作権情報を提供する" id="02" impl="COMMENT-02" severity="3"/>
         <rule autogen="true" header="すべてのソース ファイルは、ファイルの先頭にファイル情報を記載して文書化する" id="03" impl="COMMENT-03" severity="3"/>
         <rule autogen="true" header="関数定義の前のコメントで関数を文書化する" id="04" impl="COMMENT-04" severity="3"/>
         <rule autogen="true" header="関数宣言の前のコメントで関数を文書化する" id="04_b" impl="COMMENT-04_b" severity="3"/>
         <rule autogen="true" header="変数宣言にコメントを付ける" id="05" impl="COMMENT-05" severity="3"/>
         <rule autogen="true" header="typedef にコメントを付ける" id="06" impl="COMMENT-06" severity="3"/>
         <rule autogen="true" header="列挙値にコメントを付ける" id="07" impl="COMMENT-07" severity="3"/>
         <rule autogen="true" header="構造体メンバ変数にコメントを付ける" id="08" impl="COMMENT-08" severity="3"/>
         <rule autogen="true" header="アセンブラの使用をすべて文書化する" id="09" impl="COMMENT-09" severity="3"/>
         <rule autogen="true" header="浮動小数点型の算術を文書化する" id="10" impl="COMMENT-10" severity="3"/>
         <rule autogen="true" header="文字シーケンス  // を C スタイル コメントの中で使用してはいけない" id="11" impl="COMMENT-11" severity="3"/>
         <rule autogen="true" header="文字シーケンス  /* を C++ スタイル コメントの中で使用してはいけない" id="12" impl="COMMENT-12" severity="3"/>
         <rule autogen="true" header="// コメントで行の結合を使用してはならない" id="13" impl="COMMENT-13" severity="2"/>
         <rule autogen="true" header="すべての型、データ メンバー、関数の宣言の前に '@brief' タグでアノテートされたコメントを付けるべきである" id="14" impl="COMMENT-14" severity="3"/>
         <rule autogen="true" header="関数宣言の前のコメントで関数のパラメーターおよび戻り値の型を文書化するべきである" id="14_b" impl="COMMENT-14_b" severity="3"/>
      </category>
      <category description="例外" name="EXCEPT">
         <rule autogen="true" header="デストラクタ、割り当て解除、スワップから例外をスローしてはならない" id="01" impl="EXCEPT-01" severity="1"/>
         <rule autogen="true" header="値でスローし、参照でキャッチする" id="02" impl="EXCEPT-02" severity="1"/>
         <rule autogen="true" header="デストラクタの中から throw を行ってはいけない" id="03" impl="EXCEPT-03" severity="1"/>
         <rule autogen="true" header="すべての例外は、再スローされるか標準ロガーでログに記録されるべきである" id="04" impl="EXCEPT-04" severity="2"/>
         <rule autogen="true" header="C++ の例外 (throw、catch、try) を使用してはならない" id="05" impl="EXCEPT-05" severity="2"/>
         <rule autogen="true" header="他では処理されていないすべての例外をキャッチする例外ハンドラを少なくとも 1 つ用意するべきである" id="06" impl="EXCEPT-06" severity="3"/>
         <rule autogen="true" header="空のスロー (throw;) は catch ハンドラの複合文でだけ使用する" id="07" impl="EXCEPT-07" severity="3"/>
         <rule autogen="true" header="プログラムの起動フェーズの後、終了フェーズの前にだけ例外をスローする" id="08" impl="EXCEPT-08" severity="3"/>
         <rule autogen="true" header="例外オブジェクトはポインタ型にするべきではない" id="09" impl="EXCEPT-09" severity="3"/>
         <rule autogen="true" header="goto または switch 文で try または catch ブロックに制御を移してはならない" id="10" impl="EXCEPT-10" severity="3"/>
         <rule autogen="true" header="throw 文の代入式は例外がスローされる原因になってはならない" id="11" impl="EXCEPT-11" severity="1"/>
         <rule autogen="true" header="NULL を明示的にスローしてはならない" id="12" impl="EXCEPT-12" severity="3"/>
         <rule autogen="true" header="明示的にスローされる例外はその場所に至るすべての呼び出しパスに互換性のある型のハンドラがなければならない" id="13" impl="EXCEPT-13" severity="3"/>
         <rule autogen="true" header="関数の宣言に例外指定がある場合、関数は指定された型の例外だけをスローできる" id="14" impl="EXCEPT-14" severity="3"/>
         <rule autogen="true" header="クラス型の例外は常に参照でキャッチする" id="15" impl="EXCEPT-15" severity="3"/>
         <rule autogen="true" header="コンストラクタまたはデストラクタの関数監視ブロックのハンドラは、そのクラスまたは基底クラスの静的でないメンバを参照してはならない" id="16" impl="EXCEPT-16" severity="3"/>
         <rule autogen="true" header="1 つの try-catch 文または関数監視ブロックに派生クラスおよびそのすべてまたは一部の基底クラスのハンドラがある場合、最後に派生されたクラスから基底クラスへの順でハンドラを記述する" id="17" impl="EXCEPT-17" severity="3"/>
         <rule autogen="true" header="グローバルまたは名前空間のスコープで呼び出される関数は、処理されない例外をスローしてはならない" id="18" impl="EXCEPT-18" severity="3"/>
         <rule autogen="true" header="例外オブジェクトは例外をスローせずにコピー作成可能でなければならない" id="19" impl="EXCEPT-19" severity="3"/>
         <rule autogen="true" header="'std::exception' を継承するクラスに明示的に宣言されたコピー コンストラクターは、例外をスローしない仕様を持たなければならない" id="20" impl="EXCEPT-20" severity="3"/>
         <rule autogen="true" header="すべてのユーザー定義のムーブ コンストラクターおよびムーブ代入演算子は、例外で終了してはならない" id="21" impl="EXCEPT-21" severity="3"/>
         <rule autogen="true" header="関数からスローされる可能性があるチェック例外は、関数宣言の直前のコメントで指定する必要がある" id="22" impl="EXCEPT-22" severity="3"/>
         <rule autogen="true" header="throw 例外仕様を使用しない" id="23" impl="EXCEPT-23" severity="3"/>
         <rule autogen="true" header="1 つの try-catch 文または function-try-block に複数のハンドラーがある場合、省略記法  (catch-all) ハンドラーは最後に置く" id="24" impl="EXCEPT-24" severity="3"/>
         <rule autogen="true" header="catch ブロックを空のままにしない" id="25" impl="EXCEPT-25" severity="3"/>
         <rule autogen="true" header="catch-all 例外ハンドラーを使用しない" id="26" impl="EXCEPT-26" severity="3"/>
      </category>
      <category description="書式" name="FORMAT">
         <rule autogen="true" header="ASCII スペースを使用しないタブを使ってはいけない" id="01" impl="FORMAT-01" severity="5"/>
         <rule autogen="true" header="開き中括弧 { を独立した行に置く" id="02" impl="FORMAT-02" severity="3"/>
         <rule autogen="true" header="閉じ中括弧 } を独立した行に置く" id="03" impl="FORMAT-03" severity="3"/>
         <rule autogen="true" header="物理的な 1 行の文字数は 80 字未満にすべきである" id="04" impl="FORMAT-04" severity="3"/>
         <rule autogen="true" header="マクロの長さは 10 行を超えてはいけない" id="05" impl="FORMAT-05" severity="3"/>
         <rule autogen="true" header="1 つの行には 1 つの命令だけを記述するべきである" id="06" impl="FORMAT-06" severity="3"/>
         <rule autogen="true" header="代入演算子の前には、ASCII スペースを 1 個入れなければならない" id="07" impl="FORMAT-07" severity="3"/>
         <rule autogen="true" header="代入演算子の後には、ASCII スペースを 1 個入れなければならない" id="08" impl="FORMAT-08" severity="3"/>
         <rule autogen="true" header="ビット演算子の前には、ASCII スペースを 1 個入れなければならない" id="09" impl="FORMAT-09" severity="3"/>
         <rule autogen="true" header="ビット演算子の後には、ASCII スペースを 1 個入れなければならない" id="10" impl="FORMAT-10" severity="3"/>
         <rule autogen="true" header="ビット演算子 &amp; の前後には、ASCII 空白文字を 1 個入れなければならない" id="11" impl="FORMAT-11" severity="3"/>
         <rule autogen="true" header="条件文キーワードと開始括弧の間には、ASCII スペースを 1 個入れなければならない" id="12" impl="FORMAT-12" severity="3"/>
         <rule autogen="true" header="条件文の開始括弧の後には、最大で 1 個の ASCII スペースを入れなければならない" id="13" impl="FORMAT-13" severity="3"/>
         <rule autogen="true" header="三項条件演算子の前には、ASCII スペースを 1 個入れなければならない" id="14" impl="FORMAT-14" severity="3"/>
         <rule autogen="true" header="三項条件演算子の後には、ASCII スペースを 1 個入れなければならない" id="15" impl="FORMAT-15" severity="3"/>
         <rule autogen="true" header="比較演算子および等価演算子の前後には、ASCII スペースを 1 個入れなければならない" id="16" impl="FORMAT-16" severity="3"/>
         <rule autogen="true" header="'.' または '-&gt;' 演算子の後にスペースを入れてはいけない" id="17" impl="FORMAT-17" severity="3"/>
         <rule autogen="true" header="'.' または '-&gt;' 演算子の前にスペースを入れてはいけない" id="18" impl="FORMAT-18" severity="3"/>
         <rule autogen="true" header="カンマの後には、ASCII スペースを 1 個入れなければならない" id="19" impl="FORMAT-19" severity="3"/>
         <rule autogen="true" header="セミコロンの後には、ASCII スペースを 1 個入れなければならない" id="20" impl="FORMAT-20" severity="3"/>
         <rule autogen="true" header="前置単項演算子 &#34;!&#34; または &#34;~&#34; とそのオペランドの間にスペースを入れてはいけない" id="21" impl="FORMAT-21" severity="3"/>
         <rule autogen="true" header="インクリメント/デクリメント演算子 (++/--) とそのオペランドの間にスペースを入れてはいけない" id="22" impl="FORMAT-22" severity="3"/>
         <rule autogen="true" header="return 文または sizeof 演算子と開始括弧の間にスペースを入れては いけない" id="23" impl="FORMAT-23" severity="3"/>
         <rule autogen="true" header="return 文または sizeof 演算子の引数または式の前後にスペースを入れてはいけない" id="24" impl="FORMAT-24" severity="3"/>
         <rule autogen="true" header="sizeof 文では、() を使わなければならない" id="25" impl="FORMAT-25" severity="3"/>
         <rule autogen="true" header="return 文では、() を使わなければならない" id="25_b" impl="FORMAT-25_b" severity="3"/>
         <rule autogen="true" header="論理演算子の前後には、ASCII スペースを 1 個入れなければならない" id="26" impl="FORMAT-26" severity="3"/>
         <rule autogen="true" header="4 の倍数のスペースで行をインデントする" id="27" impl="FORMAT-27" severity="3"/>
         <rule autogen="true" header="関数の定義では、関数の戻り型を関数名のすぐ上の行にインデントを合わせて置く" id="28" impl="FORMAT-28" severity="3"/>
         <rule autogen="true" header="複数の変数を同じ文で宣言してはならない" id="29" impl="FORMAT-29" severity="3"/>
         <rule autogen="true" header="関数名と括弧の間にスペースを入れない" id="30" impl="FORMAT-30" severity="3"/>
         <rule autogen="true" header="条件式では論理式を分ける" id="31" impl="FORMAT-31" severity="3"/>
         <rule autogen="true" header="間接参照演算子 * およびアドレス演算子 &amp; は、型に直接付ける" id="32" impl="FORMAT-32" severity="4"/>
         <rule autogen="true" header="各変数は、別個の宣言文で宣言しなければならない" id="33" impl="FORMAT-33" severity="3"/>
         <rule autogen="true" header="ブロックを囲む中括弧 {} は、カラムを合わせる" id="34" impl="FORMAT-34" severity="3"/>
         <rule autogen="true" header="関数を宣言する際、先頭の括弧と最初の引数は関数名と同じ行に記述する" id="35" impl="FORMAT-35" severity="3"/>
         <rule autogen="true" header="兄弟の関係にある文の行のインデントは同じでなければならない" id="36" impl="FORMAT-36" severity="3"/>
         <rule autogen="true" header="制御文の本体の最初の行は、制御文のキーワードよりインデントを下げなければならない" id="37" impl="FORMAT-37" severity="3"/>
         <rule autogen="true" header="3 つ以上のパラメータを持つ関数を宣言する場合、先頭の括弧と最初の引数を関数名と同じ行に置き、残りの各引数を個別の行に置く" id="38" impl="FORMAT-38" severity="3"/>
         <rule autogen="true" header="#include ディレクティブをアルファベット順にソートする " id="39" impl="FORMAT-39" severity="4"/>
         <rule autogen="true" header="開き角括弧 '[' の後と閉じ角括弧 ']' の前の空白の有無は一致していなければならない" id="40" impl="FORMAT-40" severity="5"/>
         <rule autogen="true" header="開き角括弧 '[' と直前のトークンの間に空白があってはいけない" id="41" impl="FORMAT-41" severity="5"/>
         <rule autogen="true" header="ブロックを囲む括弧 (&#34;{}&#34;) の行には、コメント以外があってはならない" id="42" impl="FORMAT-42" severity="3"/>
         <rule autogen="true" header="ブロックを囲む括弧 (&#34;{}&#34;) は同じカラムに置かれなければならない" id="43" impl="FORMAT-43" severity="3"/>
         <rule autogen="true" header="ブロックを囲む括弧 (&#34;{}&#34;) は、&#34;{&#34; の後ろにも &#34;}&#34; の前にも空白行があってはならない" id="44" impl="FORMAT-44" severity="3"/>
         <rule autogen="true" header="単項演算子 &#34;&amp;&#34;、&#34;*&#34;、&#34;+&#34;、&#34;-&#34; とそのオペランドの間にスペースがあってはならない" id="45" impl="FORMAT-45" severity="3"/>
         <rule autogen="true" header="マクロ定義で、インクリメント/デクリメント演算子 (++/--) とそのオペランドの間にスペースを入れてはいけない" id="46" impl="FORMAT-46" severity="3"/>
         <rule autogen="true" header="CV 修飾子は、修飾される型の右側に置く" id="47_a" impl="FORMAT-47_a" severity="3"/>
         <rule autogen="true" header="CV 修飾子は、typedef または using 名である型の右側に置く" id="47_b" impl="FORMAT-47_b" severity="3"/>
         <rule autogen="true" header="関数宣言中のパラメーター名は括弧で囲むべきではない" id="48" impl="FORMAT-48" severity="3"/>
         <rule autogen="true" header="変数宣言中のローカル変数名は括弧で囲むべきではない" id="49" impl="FORMAT-49" severity="3"/>
      </category>
      <category description="High Integrity C++" name="HICPP">
         <category description="12_4_3" name="12_4_3">
            <rule autogen="true" header="同じ非静的なメンバーのコンストラクターで NSDMI およびメンバー初期化子の両方を指定しない" id="a" impl="HICPP-12_4_3-a" severity="3"/>
         </category>
         <category description="12_5_1" name="12_5_1">
            <rule autogen="true" header="具象クラスでは、コンパイラによって暗黙的に提供される特別なメンバー関数を明示的に =default もしくは =delete で定義する" id="a" impl="HICPP-12_5_1-a" severity="3"/>
         </category>
         <category description="13_2_3" name="13_2_3">
            <rule autogen="true" header="二項算術演算子およびビット演算子を非メンバーとして宣言する" id="a" impl="HICPP-13_2_3-a" severity="3"/>
         </category>
         <category description="13_2_4" name="13_2_4">
            <rule autogen="true" header="添え字演算子 (operator[]) をオーバーロードする際は、const および非 const の両方のバージョンを実装する" id="a" impl="HICPP-13_2_4-a" severity="3"/>
         </category>
         <category description="15_1_1" name="15_1_1">
            <rule autogen="true" header="std::exception のインスタンスだけを例外として使用する" id="a" impl="HICPP-15_1_1-a" severity="3"/>
         </category>
         <category description="16_1_4" name="16_1_4">
            <rule autogen="true" header="システム ライブラリおよび標準ライブラリのヘッダーには &lt;&gt; 括弧を使用する。他のヘッダーには引用符を使用する" id="a" impl="HICPP-16_1_4-a" severity="3"/>
         </category>
         <category description="17_2_1" name="17_2_1">
            <rule autogen="true" header="C 標準ライブラリの使用をラップする" id="a" impl="HICPP-17_2_1-a" severity="4"/>
         </category>
         <category description="17_3_4" name="17_3_4">
            <rule autogen="true" header="配列型のスマート ポインターを作成しない" id="a" impl="HICPP-17_3_4-a" severity="3"/>
         </category>
         <category description="18_1_1" name="18_1_1">
            <rule autogen="true" header="プラットフォーム固有のマルチスレッド機能を使用しない" id="a" impl="HICPP-18_1_1-a" severity="3"/>
         </category>
         <category description="18_2_1" name="18_2_1">
            <rule autogen="true" header="std::thread の代わりに high_integrity::thread を使用する" id="a" impl="HICPP-18_2_1-a" severity="3"/>
         </category>
         <category description="18_2_3" name="18_2_3">
            <rule autogen="true" header="複数のスレッドで volatile データを共有しない" id="a" impl="HICPP-18_2_3-a" severity="3"/>
         </category>
         <category description="18_2_4" name="18_2_4">
            <rule autogen="true" header="Double-Checked Locking ではなく std::call_once を使用する" id="a" impl="HICPP-18_2_4-a" severity="3"/>
         </category>
         <category description="18_3_3" name="18_3_3">
            <rule autogen="true" header="std::recursive mutex を使用しない" id="a" impl="HICPP-18_3_3-a" severity="3"/>
         </category>
         <category description="18_3_4" name="18_3_4">
            <rule autogen="true" header="std::lock_guard が使用できない場合にだけ std::unique_lock を使用する" id="a" impl="HICPP-18_3_4-a" severity="3"/>
         </category>
         <category description="18_3_5" name="18_3_5">
            <rule autogen="true" header="std::mutex のメンバーを直接的に使用しない" id="a" impl="HICPP-18_3_5-a" severity="3"/>
         </category>
         <category description="18_3_6" name="18_3_6">
            <rule autogen="true" header="緩いアトミックを使用しない" id="a" impl="HICPP-18_3_6-a" severity="3"/>
         </category>
         <category description="18_4_1" name="18_4_1">
            <rule autogen="true" header="std::mutex で std::condition_variable_any を使用しない" id="a" impl="HICPP-18_4_1-a" severity="3"/>
         </category>
         <category description="1_3_4" name="1_3_4">
            <rule autogen="true" header="非推奨の STL ライブラリ機能を使用しない" id="a" impl="HICPP-1_3_4-a" severity="3"/>
         </category>
         <category description="2_3_2" name="2_3_2">
            <rule autogen="true" header="コメントを使用してコードの一部を削除しない" id="a" impl="HICPP-2_3_2-a" severity="4"/>
         </category>
         <category description="3_3_1" name="3_3_1">
            <rule autogen="true" header="静的記憶域期間を持つ変数を使用しない" id="a" impl="HICPP-3_3_1-a" severity="3"/>
         </category>
         <category description="4_2_1" name="4_2_1">
            <rule autogen="true" header="符号なしの汎整数式が要求されるコンテキストでリテラルを使用する場合、必ず接尾辞 U を適用する" id="a" impl="HICPP-4_2_1-a" severity="3"/>
         </category>
         <category description="5_1_4" name="5_1_4">
            <rule autogen="true" header="ラムダで変数を暗黙的にキャプチャしない" id="a" impl="HICPP-5_1_4-a" severity="3"/>
         </category>
         <category description="5_4_2" name="5_4_2">
            <rule autogen="true" header="式を列挙型にキャストしない" id="a" impl="HICPP-5_4_2-a" severity="3"/>
         </category>
         <category description="5_8_1" name="5_8_1">
            <rule autogen="true" header="条件演算子 (?:) を部分式として使用しない" id="a" impl="HICPP-5_8_1-a" severity="3"/>
         </category>
         <category description="7_1_10" name="7_1_10">
            <rule autogen="true" header="コンパイル時定数を含むアサーションには static_assert を使用する" id="a" impl="HICPP-7_1_10-a" severity="3"/>
         </category>
         <category description="7_1_3" name="7_1_3">
            <rule autogen="true" header="宣言では、型指定子をそれ以外の指定子の前に置かない" id="a" impl="HICPP-7_1_3-a" severity="3"/>
         </category>
         <category description="7_1_5" name="7_1_5">
            <rule autogen="true" header="大きい関数をインライン化しない" id="a" impl="HICPP-7_1_5-a" severity="3"/>
         </category>
         <category description="7_1_6" name="7_1_6">
            <rule autogen="true" header="抽象スカラ量および標準整数型にはクラス型または typedef を使用する" id="b" impl="HICPP-7_1_6-b" severity="3"/>
            <rule autogen="true" header="抽象スカラ量および標準整数型にはクラス型または typedef を使用する" id="c" impl="HICPP-7_1_6-c" severity="3"/>
         </category>
         <category description="7_1_8" name="7_1_8">
            <rule autogen="true" header="初期化関数の呼び出しと同じ型を持つ変数を宣言するには、auto id = expr を使用する" id="a" impl="HICPP-7_1_8-a" severity="3"/>
         </category>
         <category description="7_1_9" name="7_1_9">
            <rule autogen="true" header="ラムダの戻り値を明示的に指定しない" id="a" impl="HICPP-7_1_9-a" severity="3"/>
         </category>
         <category description="7_2_1" name="7_2_1">
            <rule autogen="true" header="明示的な列挙型のベースを使用し、それがすべての列挙子を格納するのに十分な大きさがあることを確認する" id="a" impl="HICPP-7_2_1-a" severity="3"/>
         </category>
         <category description="7_2_2" name="7_2_2">
            <rule autogen="true" header="列挙型の列挙子は、何も初期化しないか、最初の 1 つだけを初期化するか、すべてを初期化する" id="a" impl="HICPP-7_2_2-a" severity="3"/>
         </category>
         <category description="7_5_1" name="7_5_1">
            <rule autogen="true" header="asm 宣言を使用しない" id="a" impl="HICPP-7_5_1-a" severity="3"/>
         </category>
         <category description="8_2_3" name="8_2_3">
            <rule autogen="true" header="トリビアルなコピー コンストラクターを持つ小さいオブジェクトは値で渡す" id="a" impl="HICPP-8_2_3-a" severity="3"/>
            <rule autogen="true" header="トリビアルなコピー コンストラクターを持つ小さいオブジェクトは値で渡す" id="b" impl="HICPP-8_2_3-b" severity="3"/>
         </category>
         <category description="8_2_4" name="8_2_4">
            <rule autogen="true" header="std::unique_ptr を const 参照で渡さない" id="a" impl="HICPP-8_2_4-a" severity="3"/>
         </category>
         <category description="8_3_3" name="8_3_3">
            <rule autogen="true" header="デフォルト引数を使用しない" id="a" impl="HICPP-8_3_3-a" severity="3"/>
         </category>
         <category description="8_3_4" name="8_3_4">
            <rule autogen="true" header="const への rvalue 参照型のパラメーターを持つ関数を =delete として定義する" id="a" impl="HICPP-8_3_4-a" severity="3"/>
         </category>
      </category>
      <category description="初期化" name="INIT">
         <rule autogen="true" header="外部リンケージを持つオブジェクトをヘッダー ファイルで初期化するべきではない" id="01" impl="INIT-01" severity="3"/>
         <rule autogen="true" header="signed 定数を使って unsigned integer 変数を初期化してはいけない" id="02" impl="INIT-02" severity="3"/>
         <rule autogen="true" header="すべての変数を初期化する" id="03" impl="INIT-03" severity="3"/>
         <rule autogen="true" header="すべてのポインタ変数を初期化する" id="04" impl="INIT-04" severity="2"/>
         <rule autogen="true" header="アドレスが変わる可能性のあるオブジェクトを参照するように参照を初期化してはいけない" id="05" impl="INIT-05" severity="1"/>
         <rule autogen="true" header="すべてのメンバ変数をコンストラクタで初期化する" id="06" impl="INIT-06" severity="1"/>
         <rule autogen="true" header="ユーザ定義コンストラクタを提供することにより、クラス メンバの初期化を明示的にする" id="07" impl="INIT-07" severity="3"/>
         <rule autogen="true" header="動的に割り当てられるクラス オブジェクトを適切に初期化するため、ユーザ定義コンストラクタを提供する" id="08" impl="INIT-08" severity="3"/>
         <rule autogen="true" header="クラスの静的メンバを初期化する" id="09" impl="INIT-09" severity="1"/>
         <rule autogen="true" header="宣言された順にメンバを初期化リストに記述する" id="10" impl="INIT-10" severity="3"/>
         <rule autogen="true" header="代入演算子は、すべてのデータ メンバーに代入を行わなければならない" id="11" impl="INIT-11" severity="2"/>
         <rule autogen="true" header="ローカルでない静的オブジェクトをローカルな static オブジェクトに置き換えることで、異なる翻訳単位にあるオブジェクトの初期化の順序に関する問題を避ける" id="12" impl="INIT-12" severity="3"/>
         <rule autogen="true" header="コンストラクタでオブジェクトが特定の順序で初期化されると想定してはならない" id="13" impl="INIT-13" severity="3"/>
         <rule autogen="true" header="基底クラスのコンストラクターで、初期化されていない非静的メンバー変数を使用してはならない" id="13_a" impl="INIT-13_a" severity="1"/>
         <rule autogen="true" header="仮想基底クラスのコンストラクターで、非仮想基底クラスの初期化されていない非静的メンバー変数を使用してはならない" id="13_b" impl="INIT-13_b" severity="1"/>
         <rule autogen="true" header="基底クラスのコンストラクターで、初期化されていない可能性がある基底クラスの非静的メンバー変数を使用してはならない" id="13_c" impl="INIT-13_c" severity="3"/>
         <rule autogen="true" header="コンストラクタでは代入ではなく初期化を使用する" id="14" impl="INIT-14" severity="5"/>
         <rule autogen="true" header="コンストラクターを追加して構造体のメンバー変数を初期化することを検討する" id="15" impl="INIT-15" severity="4"/>
         <rule autogen="true" header="集成体または共用体の初期化は括弧に囲まれていなければならない" id="16" impl="INIT-16" severity="3"/>
         <rule autogen="true" header="すべてのユーザー定義のコンストラクターがデータ メンバーを同じ定数値で初期化している場合、NSDMI を使用して初期化すべきである" id="17" impl="INIT-17" severity="3"/>
      </category>
      <category description="メトリクス" name="METRICS">
         <rule autogen="true" header="関数が 50 行を超えないようにする" id="01" impl="METRICS-01" severity="5"/>
         <rule autogen="true" header="case の多い switch 文は避ける" id="02" impl="METRICS-02" severity="5"/>
         <rule autogen="true" header="1 関数中のコード ブロックの数が多い" id="03" impl="METRICS-03" severity="3"/>
         <rule autogen="true" header="1関数中の関数呼び出しの数が多い" id="04" impl="METRICS-04" severity="3"/>
         <rule autogen="true" header="クラスの継承レベルが多い" id="05" impl="METRICS-05" severity="3"/>
         <rule autogen="true" header="1 クラスあたりのデータ メンバの数が 15 を超えてはならない" id="06" impl="METRICS-06" severity="3"/>
         <rule autogen="true" header="1 クラスあたりのメソッドの数が多い" id="07" impl="METRICS-07" severity="3"/>
         <rule autogen="true" header="1 メソッドあたりのパラメータの数が 10 を超えてはならない" id="08" impl="METRICS-08" severity="3"/>
         <rule autogen="true" header="1 クラスあたりの private データ メンバの数が多い" id="09" impl="METRICS-09" severity="3"/>
         <rule autogen="true" header="1 クラスあたりの private メソッドの数が多い" id="10" impl="METRICS-10" severity="3"/>
         <rule autogen="true" header="1 クラスあたりの protected データ メンバの数が多い" id="11" impl="METRICS-11" severity="3"/>
         <rule autogen="true" header="1 クラスあたりの protected メソッドの数が多い" id="12" impl="METRICS-12" severity="3"/>
         <rule autogen="true" header="1 クラスあたりの public データ メンバの数が多い" id="13" impl="METRICS-13" severity="3"/>
         <rule autogen="true" header="1 クラスあたりの public メソッドの数が多い" id="14" impl="METRICS-14" severity="3"/>
         <rule autogen="true" header="6 個以上のパラメータを持つ関数は避ける" id="15" impl="METRICS-15" severity="3"/>
         <rule autogen="true" header="マクロでは 6 個以上のパラメータを使ってはいけない" id="16" impl="METRICS-16" severity="3"/>
         <rule autogen="true" header="構造体、共用体、およびクラスのフィールド数は、20 を超えないよう にする" id="17" impl="METRICS-17" severity="5"/>
         <rule autogen="true" header="Cyclomatic 複雑度の限度 10 に従う" id="18" impl="METRICS-18" severity="3"/>
         <rule autogen="true" header="モジュール総行数に対するコメント行の割合は、20 パーセントから 60 パーセントの間でなければならない" id="19" impl="METRICS-19" severity="3"/>
         <rule autogen="true" header="長すぎる関数は避ける (宣言および文の数)" id="20" impl="METRICS-20" severity="3"/>
         <rule autogen="true" header="長すぎる関数は避ける (ブロック数)" id="21" impl="METRICS-21" severity="3"/>
         <rule autogen="true" header="76 行以上の関数を避ける" id="22" impl="METRICS-22" severity="3"/>
         <rule autogen="true" header="ブロックのネストの深さが 5 を超えてはならない" id="23" impl="METRICS-23" severity="3"/>
         <rule autogen="true" header="ソース ファイルが 500 行を超えないようにする" id="24" impl="METRICS-24" severity="5"/>
         <rule autogen="true" header="関数またはメソッドの論理ソース行 (L-SLOCs) は 200 を超えてはならない" id="25" impl="METRICS-25" severity="3"/>
         <rule autogen="true" header="ソース行は 120 文字以下にする" id="26" impl="METRICS-26" severity="3"/>
         <rule autogen="true" header="パラメータ が 8 個以上の関数は使用しない" id="27" impl="METRICS-27" severity="3"/>
         <rule autogen="true" header="Cyclomatic 複雑度の限度 20 に従う" id="28" impl="METRICS-28" severity="3"/>
         <rule autogen="true" header="Cyclomatic 複雑度のレポート" id="29" impl="METRICS-29" severity="5"/>
         <rule autogen="true" header="関数は 60 行を超えてはならない" id="30" impl="METRICS-30" severity="3"/>
         <rule autogen="true" header="1 関数につき平均 2 つ以上のアサーションを記述する" id="31" impl="METRICS-31" severity="3"/>
         <rule autogen="true" header="20 行を超える関数には、少なくとも 2 つのアサーションが含まれるべきである" id="32" impl="METRICS-32" severity="3"/>
         <rule autogen="true" header="Essential Complexity のレポート" id="33" impl="METRICS-33" severity="5"/>
         <rule autogen="true" header="Essential Complexity の制限 4 を守る" id="34" impl="METRICS-34" severity="5"/>
         <rule autogen="true" header="Essential Complexity の制限 10 を守る" id="35" impl="METRICS-35" severity="5"/>
         <rule autogen="true" header="グローバル関数は 6 個以上の関数から呼び出されてはならない" id="36" impl="METRICS-36" severity="3"/>
         <rule autogen="true" header="関数は 8 個以上の関数を呼び出してはならない" id="37" impl="METRICS-37" severity="3"/>
         <rule autogen="true" header="関数内のステートメントの数は 1 から 50 の範囲でなければならない" id="38" impl="METRICS-38" severity="3"/>
         <rule autogen="true" header="関数の VOCF メトリクスの値は 4 以下でなければならない" id="39" impl="METRICS-39" severity="3"/>
         <rule autogen="true" header="関数内のステートメントを 4 レベルより深くネストしてはならない" id="40" impl="METRICS-40" severity="3"/>
         <rule autogen="true" header="関数内のステートメント数に対する関数内と関数の前のコメント ブロック数との割合は &gt; 0.2 でなければならない" id="41" impl="METRICS-41" severity="3"/>
         <rule autogen="true" header="Essential Complexity の制限 1 を守る" id="42" impl="METRICS-42" severity="5"/>
         <rule autogen="true" header="関数の Halstead's delivered bugs (B) メトリクスをレポート" id="43" impl="METRICS-43" severity="3"/>
      </category>
      <category description="MISRA C 1998" name="MISRA">
         <rule autogen="true" header="適切な実行時チェックのために条件を用意する" id="004_a" impl="MISRA-004_a" severity="5"/>
         <rule autogen="true" header="適切な実行時チェックのために条件を用意する" id="004_b" impl="MISRA-004_b" severity="5"/>
         <rule autogen="true" header="ISO の C 規格で定義されている文字だけを使用する" id="005" impl="MISRA-005" severity="3"/>
         <rule autogen="true" header="文字型の値は、定義・文書化された ISO 10646-1 のサブセットに制限されるべきである" id="006" impl="MISRA-006" severity="3"/>
         <rule autogen="true" header="拡張文字列リテラルを使用してはならない" id="008" impl="MISRA-008" severity="3"/>
         <rule autogen="true" header="基本型の char、int、short、long、float および double を使用しない。代わりに特定の長さの typedef を使用する" id="013" impl="MISRA-013" severity="3"/>
         <rule autogen="true" header="char 型は常にunsigned char または signed char として宣言しなけれ ばならない" id="014" impl="MISRA-014" severity="3"/>
         <rule autogen="true" header="隠蔽されている浮動小数点数のビット表現を使用してはならない" id="016" impl="MISRA-016" severity="3"/>
         <rule autogen="true" header="数値定数には型を示す接尾語を付ける" id="018_a" impl="MISRA-018_a" severity="5"/>
         <rule autogen="true" header="数値定数には型を示す接尾語を付ける" id="018_b" impl="MISRA-018_b" severity="5"/>
         <rule autogen="true" header="数値定数には型を示す接尾語を付ける" id="018_c" impl="MISRA-018_c" severity="5"/>
         <rule autogen="true" header="数値定数には型を示す接尾語を付ける" id="018_d" impl="MISRA-018_d" severity="5"/>
         <rule autogen="true" header="すべての関数は、使用する前に宣言しなければならない" id="020" impl="MISRA-020" severity="3"/>
         <rule autogen="true" header="オブジェクト宣言は関数のスコープにするべきである" id="022" impl="MISRA-022" severity="5"/>
         <rule autogen="true" header="外部リンケージを持つオブジェクトまたは関数は、ヘッダー ファイルで宣言しなければならない" id="023" impl="MISRA-023" severity="4"/>
         <rule autogen="true" header="識別子は同一の翻訳単位において内部リンケージと外部リンケージを同時に持ってはならない" id="024" impl="MISRA-024" severity="3"/>
         <rule autogen="true" header="外部オブジェクトを複数のファイルで宣言してはいけない" id="027" impl="MISRA-027" severity="3"/>
         <rule autogen="true" header="外部オブジェクトを実装ファイルで宣言してはいけない" id="027_b" impl="MISRA-027_b" severity="3"/>
         <rule autogen="true" header="register 記憶域クラス指定子を使用してはならない" id="028" impl="MISRA-028" severity="5"/>
         <rule autogen="true" header="タグの使用は宣言と一致しなければならない" id="029" impl="MISRA-029" severity="3"/>
         <rule autogen="true" header="すべての自動変数は使用前に値を代入しなければならない" id="030" impl="MISRA-030" severity="3"/>
         <rule autogen="true" header="整数の除算を文書化する" id="041" impl="MISRA-041" severity="5"/>
         <rule autogen="true" header="カンマ演算子は for ループの制御式でだけ使用する" id="042" impl="MISRA-042" severity="3"/>
         <rule autogen="true" header="情報の損失を引き起こす可能性があるより広い型からより狭い型への暗黙的な変換を使用してはならない" id="043" impl="MISRA-043" severity="3"/>
         <rule autogen="true" header="1 つの式の中で精度の異なる算術演算を混在させない" id="043_b" impl="MISRA-043_b" severity="3"/>
         <rule autogen="true" header="情報の損失を引き起こす可能性がある汎整数型から浮動小数点型への暗黙的な変換を使用してはならない" id="043_c" impl="MISRA-043_c" severity="3"/>
         <rule autogen="true" header="情報の損失につながる可能性があるため、汎整数型定数から浮動小数点型への暗黙的な変換を使用してはならない" id="043_d" impl="MISRA-043_d" severity="3"/>
         <rule autogen="true" header="volatile キーワードを使用してはいけない" id="046_a" impl="MISRA-046_a" severity="3"/>
         <rule autogen="true" header="代入文を他の代入文にネストしてはならない" id="046_b" impl="MISRA-046_b" severity="3"/>
         <rule autogen="true" header="結果をより広い整数型にキャストしている式での整数オーバーフローの可能性を避ける" id="048_a" impl="MISRA-048_a" severity="3"/>
         <rule autogen="true" header="2 つの整数の被除数を浮動小数点型にキャストしてはならない" id="048_b" impl="MISRA-048_b" severity="3"/>
         <rule autogen="true" header="空の文は、それ自体だけを一行に置かなければならない" id="054" impl="MISRA-054" severity="3"/>
         <rule autogen="true" header="switch 文中以外でラベルを使用してはいけない" id="055" impl="MISRA-055" severity="5"/>
         <rule autogen="true" header="break 文を使用してはならない" id="058" impl="MISRA-058" severity="3"/>
         <rule autogen="true" header="浮動小数点変数をループ カウンタとして使用してはならない" id="065" impl="MISRA-065" severity="3"/>
         <rule autogen="true" header="可変個数の引数を持つ関数を使用してはならない" id="069" impl="MISRA-069" severity="3"/>
         <rule autogen="true" header="関数にはプロトタイプ宣言がなければならず、プロトタイプは関数定義と関数呼び出しの両方から見えなければならない" id="071_a" impl="MISRA-071_a" severity="3"/>
         <rule autogen="true" header="関数は、関数呼び出しから見えるプロトタイプを持たなければならない" id="071_b" impl="MISRA-071_b" severity="3"/>
         <rule autogen="true" header="すべてのパラメータに対して識別子を与えるか、または全く与えないか のどちらかでなければならない" id="073" impl="MISRA-073" severity="3"/>
         <rule autogen="true" header="非 void の戻り値を持つ関数では、各 return は式を持たなければならない" id="083" impl="MISRA-083" severity="3"/>
         <rule autogen="true" header="void の戻り値を持つ関数では、return 文が式を持ってはならない" id="084" impl="MISRA-084" severity="3"/>
         <rule autogen="true" header="#include 指令の後には &lt;filename&gt; または &#34;filename&#34; が続かなければならない" id="089" impl="MISRA-089" severity="3"/>
         <rule autogen="true" header="関数マクロの定義全体に括弧を付けなければならない" id="096" impl="MISRA-096" severity="3"/>
         <rule autogen="true" header="前処理演算子 defined には標準書式だけを使用しなければならない" id="100" impl="MISRA-100" severity="3"/>
         <rule autogen="true" header="ポインタ算術は使用するべきではない" id="101" impl="MISRA-101" severity="3"/>
         <rule autogen="true" header="関数への非定数ポインタを使用してはいけない" id="104" impl="MISRA-104" severity="3"/>
         <rule autogen="true" header="1 つのポインタが指しているすべての関数において、引数の数と型、および戻り値の型は等しくなければならない" id="105" impl="MISRA-105" severity="3"/>
         <rule autogen="true" header="NULL ポインタを間接参照してはいけない" id="107_a" impl="MISRA-107_a" severity="3"/>
         <rule autogen="true" header="NULL ポインタを間接参照してはいけない" id="107_b" impl="MISRA-107_b" severity="3"/>
         <rule autogen="true" header="構造体または共用体ではすべてのメンバを指定するべきである" id="108" impl="MISRA-108" severity="3"/>
         <rule autogen="true" header="より大きなデータ型の一部分にアクセスするために共用体を使用してはいけない" id="110" impl="MISRA-110" severity="3"/>
         <rule autogen="true" header="構造体 ( またはクラス/共用体) のすべてのメンバには名前を付けなければならない" id="113" impl="MISRA-113" severity="3"/>
         <rule autogen="true" header="標準ライブラリ関数名を再使用してはならない" id="115" impl="MISRA-115" severity="3"/>
         <rule autogen="true" header="'setlocale' 関数を使用しない" id="121_a" impl="MISRA-121_a" severity="3"/>
         <rule autogen="true" header="&lt;locale.h&gt; ヘッダーをインクルードしない" id="121_b" impl="MISRA-121_b" severity="3"/>
      </category>
      <category description="MISRA C 2004" name="MISRA2004">
         <rule autogen="true" header="符号付き整数型と符号なし整数型の間の暗黙的変換を避ける" id="10_1_a" impl="MISRA2004-10_1_a" severity="3"/>
         <rule autogen="true" header="整数型と浮動小数点型の間の暗黙的変換を使用してはならない" id="10_1_b" impl="MISRA2004-10_1_b" severity="3"/>
         <rule autogen="true" header="複合式の暗黙的変換を避ける" id="10_1_c" impl="MISRA2004-10_1_c" severity="3"/>
         <rule autogen="true" header="広い型から狭い型への暗黙的変換を避ける" id="10_1_d" impl="MISRA2004-10_1_d" severity="3"/>
         <rule autogen="true" header="関数の return 式の暗黙的変換を避ける" id="10_1_e" impl="MISRA2004-10_1_e" severity="3"/>
         <rule autogen="true" header="複合式の暗黙的変換を避ける" id="10_1_f" impl="MISRA2004-10_1_f" severity="3"/>
         <rule autogen="true" header="関数引数の暗黙的変換を避ける" id="10_1_g" impl="MISRA2004-10_1_g" severity="3"/>
         <rule autogen="true" header="複合式の暗黙の変換を避ける" id="10_1_i" impl="MISRA2004-10_1_i" severity="3"/>
         <rule autogen="true" header="浮動小数点型から整数型への暗黙的変換を使用してはならない" id="10_2_a" impl="MISRA2004-10_2_a" severity="3"/>
         <rule autogen="true" header="浮動小数点型のより狭い型への暗黙の変換を避ける" id="10_2_b" impl="MISRA2004-10_2_b" severity="3"/>
         <rule autogen="true" header="浮動小数点型のより広い型への暗黙の変換を避ける" id="10_2_c" impl="MISRA2004-10_2_c" severity="3"/>
         <rule autogen="true" header="浮動小数点型のより狭い型への暗黙の変換を避ける" id="10_2_d" impl="MISRA2004-10_2_d" severity="3"/>
         <rule autogen="true" header="整数型の複合式の値は、式の潜在型と同じ符号属性をもつ、より小さな型へのキャストだけが許される" id="10_3" impl="MISRA2004-10_3" severity="3"/>
         <rule autogen="true" header="ビット単位の演算子 ~ 及び &lt;&lt; が、潜在型の unsigned char または unsigned short であるオペランドに適用される場合、その結果は、そのオペランドの潜在型へ直ちにキャストさせる" id="10_5" impl="MISRA2004-10_5" severity="3"/>
         <rule autogen="true" header="すべての符号なし型の定数には、接尾辞 U を付けなければならない" id="10_6" impl="MISRA2004-10_6" severity="5"/>
         <rule autogen="true" header="関数ポインタは、汎整数型以外の任意の型との間で変換してはならない" id="11_1" impl="MISRA2004-11_1" severity="3"/>
         <rule autogen="true" header="オブジェクト ポインタは、汎整数型、オブジェクト型を指す他のポインタ、void ポインタを除く任意の型との間で変換してはならない" id="11_2" impl="MISRA2004-11_2" severity="3"/>
         <rule autogen="true" header="オブジェクト ポインタは、汎整数型、オブジェクト型を指す他のポインタ、void ポインタを除く任意の型との間で変換してはならない" id="11_2_b" impl="MISRA2004-11_2_b" severity="3"/>
         <rule autogen="true" header="オブジェクト ポインタは、汎整数型、オブジェクト型を指す他のポインタ、void ポインタを除く任意の型との間で変換してはならない" id="11_2_c" impl="MISRA2004-11_2_c" severity="3"/>
         <rule autogen="true" header="キャストでポインター型を汎整数型に変換してはならない" id="11_3_a" impl="MISRA2004-11_3_a" severity="3"/>
         <rule autogen="true" header="キャストで汎整数型をポインター型に変換してはならない" id="11_3_b" impl="MISRA2004-11_3_b" severity="3"/>
         <rule autogen="true" header="オブジェクト型を指すポインタとオブジェクト型を指す異なるポインタの間でキャストすべきでない" id="11_4" impl="MISRA2004-11_4" severity="3"/>
         <rule autogen="true" header="キャストによってポインターまたは参照型から const または volatile 修飾子を取り除いてはならない" id="11_5" impl="MISRA2004-11_5" severity="3"/>
         <rule autogen="true" header="カンマ演算子は、用いてはならない" id="12_10" impl="MISRA2004-12_10" severity="3"/>
         <rule autogen="true" header="浮動小数点値の潜在的なビット表現は、用いてはならない" id="12_12" impl="MISRA2004-12_12" severity="3"/>
         <rule autogen="true" header="1つの式の中で、インクリメント (++) 演算子およびデクリメント (--) 演算子は、式中で他の演算子と混在させるべきではない" id="12_13" impl="MISRA2004-12_13" severity="3"/>
         <rule autogen="true" header="代入演算子の右辺のオペランドに代入式が含まれる場合、括弧を使用する" id="12_1_a" impl="MISRA2004-12_1_a" severity="3"/>
         <rule autogen="true" header="式中における C 言語の演算子優先順位規則への依存は、極力制限すべきである" id="12_1_b" impl="MISRA2004-12_1_b" severity="5"/>
         <rule autogen="true" header="単項演算子のオペランドには括弧は必要ない" id="12_1_c" impl="MISRA2004-12_1_c" severity="5"/>
         <rule autogen="true" header="式中における C 言語の演算子優先順位規則への依存は、極力制限すべきである" id="12_1_d" impl="MISRA2004-12_1_d" severity="3"/>
         <rule autogen="true" header="式中のすべての演算子の種類が同じでない限り、括弧を使用する" id="12_1_e" impl="MISRA2004-12_1_e" severity="3"/>
         <rule autogen="true" header="式中における C 言語の演算子優先順位規則への依存は、極力制限すべきである" id="12_1_f" impl="MISRA2004-12_1_f" severity="5"/>
         <rule autogen="true" header="式の値は、規格が認めるどのような順序で評価されようとも、同じでなければならない" id="12_2_a" impl="MISRA2004-12_2_a" severity="3"/>
         <rule autogen="true" header="関数の引数の評価順序に依存するコードを書いてはならない" id="12_2_b" impl="MISRA2004-12_2_b" severity="1"/>
         <rule autogen="true" header="関数呼び出しおよび関数引数の評価順序に依存するコードを記述してはならない" id="12_2_c" impl="MISRA2004-12_2_c" severity="3"/>
         <rule autogen="true" header="関数呼び出しを含む式の評価順序に依存するコードを書いてはならない" id="12_2_d" impl="MISRA2004-12_2_d" severity="3"/>
         <rule autogen="true" header="オブジェクトは、シーケンス ポイントの間で、格納された値が式の評価によって 2 回以上変更されてはならない" id="12_2_e" impl="MISRA2004-12_2_e" severity="3"/>
         <rule autogen="true" header="2 つの隣接するシーケンス ポイント間で複数の volatile を使用してはならない" id="12_2_f" impl="MISRA2004-12_2_f" severity="3"/>
         <rule autogen="true" header="関数呼び出しの評価順序に依存するコードを書いてはならない" id="12_2_g" impl="MISRA2004-12_2_g" severity="3"/>
         <rule autogen="true" header="sizeof 演算子のオペランドに副作用を持つ式が含まれていてはならない" id="12_3" impl="MISRA2004-12_3" severity="3"/>
         <rule autogen="true" header="sizeof 演算子のオペランドで volatile 左辺値として指定されたオブジェクトにアクセスするべきではない" id="12_3_b" impl="MISRA2004-12_3_b" severity="3"/>
         <rule autogen="true" header="副作用を持つ関数の呼び出しを sizeof 演算子のオペランドとして使用してはならない" id="12_3_c" impl="MISRA2004-12_3_c" severity="3"/>
         <rule autogen="true" header="論理演算子 &amp;&amp; または || の右側のオペランドには、副作用があってはならない" id="12_4_a" impl="MISRA2004-12_4_a" severity="3"/>
         <rule autogen="true" header="論理演算子 &amp;&amp; または|| のオペランドは一次式でなければならない" id="12_5" impl="MISRA2004-12_5" severity="3"/>
         <rule autogen="true" header="論理演算子 (&amp;&amp;, ||, !) のオペランドは、実質的なブール型になるべきである" id="12_6_a" impl="MISRA2004-12_6_a" severity="3"/>
         <rule autogen="true" header="実質的なブール型である式は、(&amp;&amp;、||、!、=、==、!= および ?:) 以外の演算子のオペランドとして用いるべきではない" id="12_6_b" impl="MISRA2004-12_6_b" severity="3"/>
         <rule autogen="true" header="ビット単位の演算子は、潜在型が符号付きのオペランドに対して適用してはならない" id="12_7" impl="MISRA2004-12_7" severity="3"/>
         <rule autogen="true" header="シフト演算子の右側のオペランドの値は、0 以上かつ左辺のオペランドの潜在型のビット幅未満でなければならない" id="12_8" impl="MISRA2004-12_8" severity="3"/>
         <rule autogen="true" header="単項マイナス (-) 演算子を、潜在型が符号なしの式に用いてはならない" id="12_9" impl="MISRA2004-12_9" severity="3"/>
         <rule autogen="true" header="ブール値が生成される式の中で代入演算子を用いてはならない" id="13_1" impl="MISRA2004-13_1" severity="3"/>
         <rule autogen="true" header="オペランドが実質的にブール型である場合を除き、 0 との比較テストは明示的に行うべきである" id="13_2" impl="MISRA2004-13_2" severity="3"/>
         <rule autogen="true" header="浮動小数点式は、等価または非等価のテストをしてはならない" id="13_3" impl="MISRA2004-13_3" severity="3"/>
         <rule autogen="true" header="for 文の制御式は、浮動小数点型のオブジェクトを含んではならない" id="13_4" impl="MISRA2004-13_4" severity="3"/>
         <rule autogen="true" header="for 文の 3 つの式には、ループ制御に関わるものだけを記述しなければならない" id="13_5" impl="MISRA2004-13_5" severity="3"/>
         <rule autogen="true" header="for ループの中で繰り返しカウンタとして用いる数値変数は、ループの本体内で変更してはならない" id="13_6" impl="MISRA2004-13_6" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_a" impl="MISRA2004-13_7_a" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_aa" impl="MISRA2004-13_7_aa" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ab" impl="MISRA2004-13_7_ab" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ac" impl="MISRA2004-13_7_ac" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ad" impl="MISRA2004-13_7_ad" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ae" impl="MISRA2004-13_7_ae" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_af" impl="MISRA2004-13_7_af" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ag" impl="MISRA2004-13_7_ag" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ah" impl="MISRA2004-13_7_ah" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ai" impl="MISRA2004-13_7_ai" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_aj" impl="MISRA2004-13_7_aj" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_ak" impl="MISRA2004-13_7_ak" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_b" impl="MISRA2004-13_7_b" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_c" impl="MISRA2004-13_7_c" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_d" impl="MISRA2004-13_7_d" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_j" impl="MISRA2004-13_7_j" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_k" impl="MISRA2004-13_7_k" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_l" impl="MISRA2004-13_7_l" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_m" impl="MISRA2004-13_7_m" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_n" impl="MISRA2004-13_7_n" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_s" impl="MISRA2004-13_7_s" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_t" impl="MISRA2004-13_7_t" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_u" impl="MISRA2004-13_7_u" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_v" impl="MISRA2004-13_7_v" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_w" impl="MISRA2004-13_7_w" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_x" impl="MISRA2004-13_7_x" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_y" impl="MISRA2004-13_7_y" severity="3"/>
         <rule autogen="true" header="結果が不変になるブール演算は許されない" id="13_7_z" impl="MISRA2004-13_7_z" severity="3"/>
         <rule autogen="true" header="すべてのif...else if 構文は、else 節で終了しなければならない" id="14_10" impl="MISRA2004-14_10" severity="3"/>
         <rule autogen="true" header="else ブロックに到達しないコードがあってはならない" id="14_1_a" impl="MISRA2004-14_1_a" severity="3"/>
         <rule autogen="true" header="return、break、continue および goto 文の後に到達しないコードがあってはならない" id="14_1_b" impl="MISRA2004-14_1_b" severity="3"/>
         <rule autogen="true" header="if、do while、while、for ブロックに到達しないコードがあってはならない" id="14_1_c" impl="MISRA2004-14_1_c" severity="3"/>
         <rule autogen="true" header="switch 文に到達しないコードがあってはならない" id="14_1_d" impl="MISRA2004-14_1_d" severity="3"/>
         <rule autogen="true" header="for ループに到達しないコードがあってはならない" id="14_1_e" impl="MISRA2004-14_1_e" severity="3"/>
         <rule autogen="true" header="if または switch の後に到達しないコードがあってはならない" id="14_1_f" impl="MISRA2004-14_1_f" severity="3"/>
         <rule autogen="true" header="while、for、do...while ループの中の if または switch の後に到達できないコードがあってはならない" id="14_1_g" impl="MISRA2004-14_1_g" severity="3"/>
         <rule autogen="true" header="すべての空でない文は、どのように実行されても1つ以上の副作用を持つか、制御フローを変えなければならない" id="14_2" impl="MISRA2004-14_2" severity="3"/>
         <rule autogen="true" header="空の文は、それ自体だけを一行に置くか、後にコメントを続けなければならない" id="14_3" impl="MISRA2004-14_3" severity="3"/>
         <rule autogen="true" header="goto 文を用いてはならない" id="14_4" impl="MISRA2004-14_4" severity="3"/>
         <rule autogen="true" header="continue 文を用いてはならない" id="14_5" impl="MISRA2004-14_5" severity="3"/>
         <rule autogen="true" header="繰り返し文にはループを終了させるために 1つだけ break 文を置くことができる" id="14_6" impl="MISRA2004-14_6" severity="3"/>
         <rule autogen="true" header="関数では、関数の最後に唯一の出口がなければならない" id="14_7" impl="MISRA2004-14_7" severity="3"/>
         <rule autogen="true" header="switch、while、do...while 、for 文の本体を構成する文は、複合文でなければならない" id="14_8" impl="MISRA2004-14_8" severity="3"/>
         <rule autogen="true" header="if および else の後には複合文を続けなければならない" id="14_9" impl="MISRA2004-14_9" severity="3"/>
         <rule autogen="true" header="break 文は switch 句の最後にだけ置くべきである" id="15_0_a" impl="MISRA2004-15_0_a" severity="3"/>
         <rule autogen="true" header="switch 文には switch ラベルと switch 節のみ使用し、他のコードを入れるべきではない" id="15_0_b" impl="MISRA2004-15_0_b" severity="3"/>
         <rule autogen="true" header="switch ラベルは、それを直接内包している複合文が switch 文の本文である場合にだけ用いなければならない" id="15_1" impl="MISRA2004-15_1" severity="3"/>
         <rule autogen="true" header="空でない case 節は、無条件 break 文で終了しなければならない" id="15_2" impl="MISRA2004-15_2" severity="3"/>
         <rule autogen="true" header="空でない default 節は、無条件 break 文で終了しなければならない" id="15_2_b" impl="MISRA2004-15_2_b" severity="3"/>
         <rule autogen="true" header="switch の最後の節は、default 節でなければならない" id="15_3" impl="MISRA2004-15_3" severity="3"/>
         <rule autogen="true" header="switch 式では、実質的なブール型になる値を用いてはならない" id="15_4" impl="MISRA2004-15_4" severity="3"/>
         <rule autogen="true" header="switch 文では、実質的なブール型になる値を用いてはならない" id="15_4_b" impl="MISRA2004-15_4_b" severity="3"/>
         <rule autogen="true" header="すべての switch 文には、最低でも 1 つの case 節を記述しなければならない" id="15_5" impl="MISRA2004-15_5" severity="3"/>
         <rule autogen="true" header="可変個引数を持つ関数を定義してはならない" id="16_1" impl="MISRA2004-16_1" severity="3"/>
         <rule autogen="true" header="関数がエラー情報を戻す場合、エラー情報をテストしなければならない" id="16_10" impl="MISRA2004-16_10" severity="3"/>
         <rule autogen="true" header="関数は、直接的か間接的かにかかわらず、その関数自身を呼び出してはならない" id="16_2" impl="MISRA2004-16_2" severity="3"/>
         <rule autogen="true" header="関数プロトタイプ宣言では、すべての仮引数に対して識別子を指定しなければならない" id="16_3" impl="MISRA2004-16_3" severity="3"/>
         <rule autogen="true" header="関数の宣言とその定義で用いられる識別子とは一致しなければならない" id="16_4" impl="MISRA2004-16_4" severity="3"/>
         <rule autogen="true" header="引数を持たない関数は、仮引数を void 型で宣言しなければならない" id="16_5" impl="MISRA2004-16_5" severity="3"/>
         <rule autogen="true" header="関数に渡される実引数の数は、仮引数の数と一致しなければならない" id="16_6" impl="MISRA2004-16_6" severity="3"/>
         <rule autogen="true" header="関数プロトタイプのポインタ仮引数は、指し示しているオブジェクトを変更する目的でポインタが用いられていない場合、 const へのポインタとして宣言すべきである" id="16_7" impl="MISRA2004-16_7" severity="3"/>
         <rule autogen="true" header="仮引数の型は、指し示しているオブジェクトを変更する目的でポインタが用いられていない場合、 const へのポインタの typedef として宣言すべきである" id="16_7_b" impl="MISRA2004-16_7_b" severity="3"/>
         <rule autogen="true" header="戻り値の型が非 void の関数の場合、すべての出口で、式を持つ明示的な return 文を記述しなければならない" id="16_8" impl="MISRA2004-16_8" severity="3"/>
         <rule autogen="true" header="関数識別子を使用する場合、必ず前に &amp; を付けるか、括弧で囲んだパラメーター リスト (空でも構わない) を付ける" id="16_9" impl="MISRA2004-16_9" severity="3"/>
         <rule autogen="true" header="ポインタ算術は、配列または配列要素を扱うポインタだけに適用しなければならない" id="17_1" impl="MISRA2004-17_1" severity="3"/>
         <rule autogen="true" header="ポインタ算術で許される形式は、配列添え字付けだけでなければならない" id="17_4" impl="MISRA2004-17_4" severity="3"/>
         <rule autogen="true" header="オブジェクトの宣言には、3 階層以上のポインター間接参照があってはならない" id="17_5" impl="MISRA2004-17_5" severity="3"/>
         <rule autogen="true" header="自動記憶域のオブジェクトのアドレスを関数から返してはいけない" id="17_6_a" impl="MISRA2004-17_6_a" severity="3"/>
         <rule autogen="true" header="自動記憶域のオブジェクトのアドレスを、オブジェクトが存在しなくなった後にも存在し続ける可能性がある別のオブジェクトに代入してはならない" id="17_6_b" impl="MISRA2004-17_6_b" severity="3"/>
         <rule autogen="true" header="すべての構造体及び共用体の型は、コンパイル単位の最後には完全でなければならない" id="18_1" impl="MISRA2004-18_1" severity="3"/>
         <rule autogen="true" header="オブジェクトを重複するオブジェクトに代入してはならない" id="18_2" impl="MISRA2004-18_2" severity="3"/>
         <rule autogen="true" header="オブジェクトを重複するオブジェクトに代入してはならない" id="18_2_b" impl="MISRA2004-18_2_b" severity="3"/>
         <rule autogen="true" header="共用体は、用いてはならない" id="18_4" impl="MISRA2004-18_4" severity="3"/>
         <rule autogen="true" header="ファイルの中で、#include 文の前には、他の前処理指令またはコメントだけを記述すべきである" id="19_1" impl="MISRA2004-19_1" severity="3"/>
         <rule autogen="true" header="# または ## のオペランドとして用いられる場合を除き、関数形式マクロの定義では、仮引数のそれぞれのインスタンスを括弧で囲まなければならない" id="19_10" impl="MISRA2004-19_10" severity="3"/>
         <rule autogen="true" header="翻訳単位内に定義されていないマクロを前処理指令 #if および #elif で使用してはならない" id="19_11_b" impl="MISRA2004-19_11_b" severity="3"/>
         <rule autogen="true" header="1 つのマクロ定義内で、# または ## 前処理演算子を複数回用いてはならない" id="19_12" impl="MISRA2004-19_12" severity="3"/>
         <rule autogen="true" header="前処理演算子 # 及び ## を用いてはならない" id="19_13" impl="MISRA2004-19_13" severity="3"/>
         <rule autogen="true" header="defined 前処理演算子は、2 つの標準形式のうち、いずれかの形式を用いなければならない" id="19_14" impl="MISRA2004-19_14" severity="3"/>
         <rule autogen="true" header="同じヘッダー ファイルの内容が 2 回取り込まれないように、予防措置を採らなければならない" id="19_15" impl="MISRA2004-19_15" severity="3"/>
         <rule autogen="true" header="前処理指令は、前処理で除外されたとしても、構文的に意味を持つようにしなければならない" id="19_16" impl="MISRA2004-19_16" severity="3"/>
         <rule autogen="true" header="すべての #else、#elif、#endif 前処理指令は、それに関連する #if 指令または #ifdef 指令と同じファイル内に存在しなければならない" id="19_17" impl="MISRA2004-19_17" severity="3"/>
         <rule autogen="true" header="#include 指令のヘッダー ファイル名には、非標準文字を記述すべきではない" id="19_2" impl="MISRA2004-19_2" severity="3"/>
         <rule autogen="true" header="マクロでキーワードや基本型を使用しない" id="19_4" impl="MISRA2004-19_4" severity="3"/>
         <rule autogen="true" header="マクロは、ブロック内で #define または #undef してはならない" id="19_5" impl="MISRA2004-19_5" severity="3"/>
         <rule autogen="true" header="関数形式マクロよりも関数を用いるべきである" id="19_7" impl="MISRA2004-19_7" severity="3"/>
         <rule autogen="true" header="実引数のすべてを指定せずに、関数形式マクロを呼び出してはならない" id="19_8" impl="MISRA2004-19_8" severity="3"/>
         <rule autogen="true" header="関数形式マクロの引数には、前処理指令のような字句を記述してはならない" id="19_9" impl="MISRA2004-19_9" severity="3"/>
         <rule autogen="true" header="&lt;stdlib.h&gt;ライブラリのライブラリ関数 atof、atoi、atol は、用いてはならない" id="20_10" impl="MISRA2004-20_10" severity="3"/>
         <rule autogen="true" header="&lt;time.h&gt; ライブラリの時間操作関数は、用いてはならない" id="20_12" impl="MISRA2004-20_12" severity="3"/>
         <rule autogen="true" header="名前がアンダースコアで始まる識別子を #define または #undef してはならない" id="20_1_a" impl="MISRA2004-20_1_a" severity="3"/>
         <rule autogen="true" header="予約済み識別子を再定義してはならない" id="20_1_b" impl="MISRA2004-20_1_b" severity="3"/>
         <rule autogen="true" header="defined 識別子を #define または #undef してはならない" id="20_1_e" impl="MISRA2004-20_1_e" severity="3"/>
         <rule autogen="true" header="標準ライブラリのマクロ、オブジェクト、関数の名前を再利用してはならない" id="20_2" impl="MISRA2004-20_2" severity="3"/>
         <rule autogen="true" header="標準ライブラリのマクロ、オブジェクト、関数の名前を再利用してはならない (C90)" id="20_2_a" impl="MISRA2004-20_2_a" severity="3"/>
         <rule autogen="true" header="標準ライブラリのマクロ、オブジェクト、関数の名前を再利用してはならない (C99)" id="20_2_b" impl="MISRA2004-20_2_b" severity="3"/>
         <rule autogen="true" header="ライブラリ関数に渡される値については、その妥当性をチェックしなければならない" id="20_3" impl="MISRA2004-20_3" severity="3"/>
         <rule autogen="true" header="動的なヒープ メモリの割り当ては、用いてはならない" id="20_4" impl="MISRA2004-20_4" severity="3"/>
         <rule autogen="true" header="エラー指示子 errno は、用いてはならない" id="20_5" impl="MISRA2004-20_5" severity="3"/>
         <rule autogen="true" header="&lt;stddef.h&gt; ライブラリのoffsetof マクロは、用いてはならない" id="20_6" impl="MISRA2004-20_6" severity="3"/>
         <rule autogen="true" header="setjmp マクロと longjmp 関数は、用いてはならない" id="20_7" impl="MISRA2004-20_7" severity="3"/>
         <rule autogen="true" header="&lt;setjmp.h&gt; ヘッダーをインクルードしてはいけない" id="20_7_b" impl="MISRA2004-20_7_b" severity="3"/>
         <rule autogen="true" header="ヘッダー ファイル &lt;signal.h&gt; をインクルードしてはいけない" id="20_8" impl="MISRA2004-20_8" severity="3"/>
         <rule autogen="true" header="&lt;signal.h&gt; のシグナル処理を用いてはならない" id="20_8_b" impl="MISRA2004-20_8_b" severity="3"/>
         <rule autogen="true" header="入出力ライブラリ &lt;stdio.h&gt; を使用してはならない" id="20_9" impl="MISRA2004-20_9" severity="3"/>
         <rule autogen="true" header="アセンブリ言語は、カプセル化して分離しなければならない" id="2_1" impl="MISRA2004-2_1" severity="3"/>
         <rule autogen="true" header="ソース コードでは、 /* ... */ スタイルのコメントだけを用いなければならない" id="2_2" impl="MISRA2004-2_2" severity="3"/>
         <rule autogen="true" header="文字列 /* を C スタイルコメント内で用いてはならない" id="2_3" impl="MISRA2004-2_3" severity="3"/>
         <rule autogen="true" header="コード セクションを &#34;コメント アウト&#34; してはならない" id="2_4" impl="MISRA2004-2_4" severity="4"/>
         <rule autogen="true" header="用いる #pragma 指令は、すべて文書化し、説明しなければならない" id="3_4" impl="MISRA2004-3_4" severity="3"/>
         <rule autogen="true" header="ビットフィールドと他のデータを同じ構造体に混在させない" id="3_5" impl="MISRA2004-3_5" severity="3"/>
         <rule autogen="true" header="ISO C 規格で定義されているエスケープ シーケンスのみ使用する" id="4_1" impl="MISRA2004-4_1" severity="3"/>
         <rule autogen="true" header="3 文字表記は、用いてはならない" id="4_2" impl="MISRA2004-4_2" severity="3"/>
         <rule autogen="true" header="ローカルまたは関数プロトタイプ スコープで宣言された識別子は、グローバルまたは名前空間のスコープで宣言された識別子を隠蔽してはならない" id="5_2_a" impl="MISRA2004-5_2_a" severity="3"/>
         <rule autogen="true" header="内側のローカル スコープで宣言された識別子は、外側のローカル スコープで宣言された識別子を隠蔽してはならない" id="5_2_b" impl="MISRA2004-5_2_b" severity="3"/>
         <rule autogen="true" header="typedef名を再利用してはならない" id="5_3_a" impl="MISRA2004-5_3_a" severity="3"/>
         <rule autogen="true" header="typedef 名を typedef 名として再利用してはならない" id="5_3_b" impl="MISRA2004-5_3_b" severity="3"/>
         <rule autogen="true" header="タグ名を他の目的で再利用してはならない" id="5_4_a" impl="MISRA2004-5_4_a" severity="3"/>
         <rule autogen="true" header="タグ名は、固有の識別子でなければならない" id="5_4_b" impl="MISRA2004-5_4_b" severity="3"/>
         <rule autogen="true" header="typedef 名はそれが指す型と同じ名前にするべきではない" id="5_4_c" impl="MISRA2004-5_4_c" severity="3"/>
         <rule autogen="true" header="静的記憶域期間を持つオブジェクトや関数識別子は、再使用すべきでない" id="5_5_a" impl="MISRA2004-5_5_a" severity="4"/>
         <rule autogen="true" header="静的記憶域期間を持つオブジェクトや関数識別子は、再使用すべきでない" id="5_5_b" impl="MISRA2004-5_5_b" severity="4"/>
         <rule autogen="true" header="構造体及び共用体のメンバ名を除いて、あるネームスペースの識別子を別のネームスペースの識別子と同じ綴りにしてはいけない" id="5_6" impl="MISRA2004-5_6" severity="4"/>
         <rule autogen="true" header="識別子名は、再使用すべきではない" id="5_7" impl="MISRA2004-5_7" severity="4"/>
         <rule autogen="true" header="単なる char 型は、文字データの格納及び使用に限って用いなければならない" id="6_1" impl="MISRA2004-6_1" severity="3"/>
         <rule autogen="true" header="signed char 型及び unsigned char 型は、数値データの格納及び使用に限って用いなければならない" id="6_2" impl="MISRA2004-6_2" severity="3"/>
         <rule autogen="true" header="基本型を指す typedef の名前は数字を含むべきである" id="6_3" impl="MISRA2004-6_3" severity="3"/>
         <rule autogen="true" header="基本型の代わりに typedef を使用するべきである" id="6_3_b" impl="MISRA2004-6_3_b" severity="3"/>
         <rule autogen="true" header="ビットフィールドは、unsigned int 型または signed int 型だけで定義しなければならない" id="6_4" impl="MISRA2004-6_4" severity="3"/>
         <rule autogen="true" header="signed int 型の名前なしビット フィールドの長さは 2 ビット以上でなければならない" id="6_5_a" impl="MISRA2004-6_5_a" severity="3"/>
         <rule autogen="true" header="ゼロ以外の 8 進定数を使用してはいけない" id="7_1_a" impl="MISRA2004-7_1_a" severity="3"/>
         <rule autogen="true" header="8 進拡張表記を使用してはいけない" id="7_1_b" impl="MISRA2004-7_1_b" severity="3"/>
         <rule autogen="true" header="static 記憶域クラス指定子は、内部結合を持つオブジェクト並びに関数の定義および宣言に対して用いなければならない" id="8_11" impl="MISRA2004-8_11" severity="3"/>
         <rule autogen="true" header="外部結合を持つ配列を宣言するときは、明示的にサイズを記述するか、初期化によって暗黙的にサイズを定義しなければならない" id="8_12" impl="MISRA2004-8_12" severity="3"/>
         <rule autogen="true" header="オブジェクトまたは関数を宣言または定義するときは、常にその型を明記しなければならない" id="8_2_a" impl="MISRA2004-8_2_a" severity="3"/>
         <rule autogen="true" header="オブジェクトまたは関数を宣言または定義するときは、常にその型を明記しなければならない" id="8_2_b" impl="MISRA2004-8_2_b" severity="3"/>
         <rule autogen="true" header="宣言と定義で同一の型を使用する" id="8_3_a" impl="MISRA2004-8_3_a" severity="3"/>
         <rule autogen="true" header="宣言と定義で同一の型を使用する" id="8_3_b" impl="MISRA2004-8_3_b" severity="3"/>
         <rule autogen="true" header="オブジェクトまたは関数が 2 回以上宣言される場合、型は互換性がなければならない" id="8_4" impl="MISRA2004-8_4" severity="3"/>
         <rule autogen="true" header="ヘッダー ファイル内で、オブジェクトまたは関数の定義を記述してはならない" id="8_5" impl="MISRA2004-8_5" severity="3"/>
         <rule autogen="true" header="常にファイル スコープで関数を宣言する" id="8_6" impl="MISRA2004-8_6" severity="3"/>
         <rule autogen="true" header="オブジェクトが単一の関数内だけでアクセスされている場合は、そのオブジェクトをブロック スコープで定義しなければならない" id="8_7" impl="MISRA2004-8_7" severity="3"/>
         <rule autogen="true" header="配列を部分的に初期化してはならない" id="9_2_b" impl="MISRA2004-9_2_b" severity="3"/>
         <rule autogen="true" header="ゼロ以外で構造体を初期化する場合、各要素に対して明示的な初期化子が必要である" id="9_2_c" impl="MISRA2004-9_2_c" severity="3"/>
         <rule autogen="true" header="すべての要素を明示的に初期化する場合を除き、列挙子リストでは、先頭以外のメンバを明示的に初期化するために　=　構文を用いてはならない" id="9_3" impl="MISRA2004-9_3" severity="3"/>
      </category>
      <category description="メモリおよびリソース管理" name="MRM">
         <rule autogen="true" header="関数のパラメータの評価順は未定義であるため、関数の引数リストでリソースを割り当てない" id="01" impl="MRM-01" severity="1"/>
         <rule autogen="true" header="1 つの文で 2 つ以上のリソースを割り当てない" id="02" impl="MRM-02" severity="3"/>
         <rule autogen="true" header="すべてのクラスに代入演算子または適切なコメントがなければならない" id="04" impl="MRM-04" severity="3"/>
         <rule autogen="true" header="すべてのクラスにコピー コンストラクタまたは適切なコメントがなければならない" id="05" impl="MRM-05" severity="3"/>
         <rule autogen="true" header="対応する new/malloc および delete/free の呼び出しでは、同じ形式を使用する" id="06" impl="MRM-06" severity="1"/>
         <rule autogen="true" header="POD 型以外では memcpy や memcmp を使用しない" id="07" impl="MRM-07" severity="3"/>
         <rule autogen="true" header="コンストラクタのあるオブジェクトに対し malloc/realloc を呼び出さない" id="08" impl="MRM-08" severity="1"/>
         <rule autogen="true" header="解放したメモリを指す式には、必ず新しい値を割り当てる" id="09" impl="MRM-09" severity="3"/>
         <rule autogen="true" header="解放したメモリを指すグローバル変数またはメンバー変数には、必ず新しい値を割り当てる" id="10" impl="MRM-10" severity="3"/>
         <rule autogen="true" header="解放したメモリを指すパラメーターまたはローカル変数には、必ず新しい値を割り当てる" id="11" impl="MRM-11" severity="3"/>
         <rule autogen="true" header="new と delete の定義を自分で書く場合は慣例に従う" id="12" impl="MRM-12" severity="3"/>
         <rule autogen="true" header="new の使用では、慣例に従う" id="13" impl="MRM-13" severity="3"/>
         <rule autogen="true" header="クラスで operator new のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="14" impl="MRM-14" severity="3"/>
         <rule autogen="true" header="クラスで operator new[] のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="15" impl="MRM-15" severity="3"/>
         <rule autogen="true" header="クラスで operator delete のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="16" impl="MRM-16" severity="3"/>
         <rule autogen="true" header="クラスで operator delete[] のオーバーロードを定義する場合、プレーン、配置構文、および nothrow のすべてを提供しなければならない" id="17" impl="MRM-17" severity="3"/>
         <rule autogen="true" header="割り当てたメモリが後に他の場所で解放されることを期待してはならない" id="18" impl="MRM-18" severity="3"/>
         <rule autogen="true" header="割り当てたメモリが後に他の場所で解放されることを期待してはならない" id="19" impl="MRM-19" severity="3"/>
         <rule autogen="true" header="割り当てたメモリが後に他の場所で解放されることを期待してはならない" id="20" impl="MRM-20" severity="3"/>
         <rule autogen="true" header="リソース管理にオブジェクトを使用する" id="21" impl="MRM-21" severity="3"/>
         <rule autogen="true" header="リソース管理にオブジェクトを使用する" id="22" impl="MRM-22" severity="3"/>
         <rule autogen="true" header="関数内の new によって初期化された間接参照 ローカル ポインタを返さない" id="23" impl="MRM-23" severity="2"/>
         <rule autogen="true" header="new で生成したオブジェクトをスマートポインタに渡すのは、独立したステートメントで行う" id="25" impl="MRM-25" severity="3"/>
         <rule autogen="true" header="演算子 new を記述した場合は演算子 delete を記述する" id="26" impl="MRM-26" severity="3"/>
         <rule autogen="true" header="演算子 new[] を記述した場合は演算子 delete[] を記述する" id="27" impl="MRM-27" severity="3"/>
         <rule autogen="true" header="new と delete はいつも一緒に提供する" id="28" impl="MRM-28" severity="3"/>
         <rule autogen="true" header="new[] と delete[] は常に一緒に提供する" id="29" impl="MRM-29" severity="3"/>
         <rule autogen="true" header="new または malloc ではなく、宣言によって割り当てる" id="30" impl="MRM-30" severity="3"/>
         <rule autogen="true" header="解放されたメモリはいかなる場合でもその後にアクセスしてはならない" id="31" impl="MRM-31" severity="3"/>
         <rule autogen="true" header="デストラクターを手動で呼び出してはならない" id="31_b" impl="MRM-31_b" severity="3"/>
         <rule autogen="true" header="グローバルな new を隠さないようにする" id="32" impl="MRM-32" severity="1"/>
         <rule autogen="true" header="デストラクタ中でポインタ メンバに対して delete を呼び出す" id="33" impl="MRM-33" severity="2"/>
         <rule autogen="true" header="new の戻り値をチェックする" id="34" impl="MRM-34" severity="3"/>
         <rule autogen="true" header="配列でないものを解放する場合、delete に空の括弧 ([]) を付けてはならない" id="35" impl="MRM-35" severity="3"/>
         <rule autogen="true" header="配列を解放する場合、必ず delete に空の括弧 ([]) を付ける" id="36" impl="MRM-36" severity="3"/>
         <rule autogen="true" header="動的にメモリを割り当てるクラスにはコピー代入演算子を宣言する" id="37" impl="MRM-37" severity="1"/>
         <rule autogen="true" header="メモリを動的に割り当てるクラスには、コピー コンストラクタを定義する" id="38" impl="MRM-38" severity="1"/>
         <rule autogen="true" header="fopen の呼び出しの直後にファイル オープン エラーの処理を置く" id="39" impl="MRM-39" severity="2"/>
         <rule autogen="true" header="copy と destroy は一貫して行う" id="40" impl="MRM-40" severity="3"/>
         <rule autogen="true" header="コピー コンストラクターを宣言する場合は、コピー代入演算子を宣言するべきである (逆の場合も同様に)" id="40_a" impl="MRM-40_a" severity="3"/>
         <rule autogen="true" header="コピー コンストラクターとコピー代入演算子は同じ public/protected/private パーミッションを持つべきである" id="40_b" impl="MRM-40_b" severity="3"/>
         <rule autogen="true" header="非自明なコピー コンストラクターまたはコピー代入演算子がある場合、デストラクターも宣言するべきである" id="40_c" impl="MRM-40_c" severity="3"/>
         <rule autogen="true" header="非自明なデストラクターがあるクラスには、コピー コンストラクターおよびコピー代入演算子も宣言するべきである" id="40_d" impl="MRM-40_d" severity="3"/>
         <rule autogen="true" header="コピー コンストラクタは、すべてのデータ メンバと基底クラスのメンバをコピーしなければならない" id="41" impl="MRM-41" severity="2"/>
         <rule autogen="true" header="ポインタを使用してファイルを開いた場合は、デストラクタでポインタ メンバに対し fclose() を呼び出す" id="42" impl="MRM-42" severity="2"/>
         <rule autogen="true" header="代入演算子は、すべての基底データに代入しなければならない" id="43" impl="MRM-43" severity="2"/>
         <rule autogen="true" header="sizeof 演算子をポインタ型に使用して、malloc、calloc、realloc 関数で割り当てるメモリのサイズを指定してはならない" id="45" impl="MRM-45" severity="3"/>
         <rule autogen="true" header="calloc、malloc、realloc および free 関数を使用してはならない" id="46" impl="MRM-46" severity="3"/>
         <rule autogen="true" header="1 つ以上の非 static メンバー変数を持つクラスは、代入演算子を宣言するか、適切なコメントを記述するべきである" id="47" impl="MRM-47" severity="3"/>
         <rule autogen="true" header="1 つ以上の非 static メンバー変数を持つクラスは、コピー コンストラクターを宣言するか、適切なコメントを記述するべきである" id="48" impl="MRM-48" severity="3"/>
         <rule autogen="true" header="データ アイテムへのポインターまたはある程度の処理を行うデストラクターのあるクラスには、コピー コンストラクターおよびコピー代入演算子を宣言しなければならない" id="49" impl="MRM-49" severity="3"/>
         <rule autogen="true" header="コピー コンストラクターとコピー代入演算子は、両方同時に private 宣言する" id="50" impl="MRM-50" severity="4"/>
         <rule autogen="true" header="void 型を指すポインターに対して delete を使用してはならない" id="51" impl="MRM-51" severity="3"/>
         <rule autogen="true" header="RAII を使用してリソース リークを防止する" id="52" impl="MRM-52" severity="4"/>
         <rule autogen="true" header="ユーザー定義の new 演算子は、割り当てが失敗した場合、std::bad_alloc 例外をスローするべきである" id="53" impl="MRM-53" severity="3"/>
         <rule autogen="true" header="オーバーアラインされた型ではデフォルトの new 演算子の使用を避ける" id="54" impl="MRM-54" severity="3"/>
         <rule autogen="true" header="不適切なストレージ容量を持つポインターまたは作成されるオブジェクトに対して適切にアラインされていないポインターを配置 new に渡さない" id="55" impl="MRM-55" severity="2"/>
         <rule autogen="true" header="配置 new アロケーション関数にオブジェクトの配列を渡す場合、オーバーヘッドを使用するべきである" id="55_b" impl="MRM-55_b" severity="3"/>
         <rule autogen="true" header="コピー代入演算子は、オブジェクトのコピーに影響を与える可能性がある副作用を持つべきではない" id="56" impl="MRM-56" severity="3"/>
         <rule autogen="true" header="ムーブ代入演算子は、オブジェクトのムーブに影響を与える可能性がある副作用を持つべきではない" id="57" impl="MRM-57" severity="3"/>
      </category>
      <category description="名前付け規則" name="NAMING">
         <category description="ハンガリー記法" name="HN">
            <rule autogen="true" header="配列変数およびパラメータのハンガリー記法" id="01" impl="NAMING-HN-01" severity="3"/>
            <rule autogen="true" header="ブール型のハンガリー記法" id="02" impl="NAMING-HN-02" severity="3"/>
            <rule autogen="true" header="ブール型のポインタ、配列、または参照型のハンガリー記法" id="03" impl="NAMING-HN-03" severity="3"/>
            <rule autogen="true" header="バイト型のハンガリー記法" id="04" impl="NAMING-HN-04" severity="3"/>
            <rule autogen="true" header="バイト型のポインタ、配列、参照型のハンガリー記法" id="05" impl="NAMING-HN-05" severity="3"/>
            <rule autogen="true" header="char 型のハンガリー記法" id="06" impl="NAMING-HN-06" severity="3"/>
            <rule autogen="true" header="char 型の配列のハンガリー記法" id="07" impl="NAMING-HN-07" severity="3"/>
            <rule autogen="true" header="char 型のポインタ、配列、配列への参照のハンガリー記法" id="08" impl="NAMING-HN-08" severity="3"/>
            <rule autogen="true" header="char 型のポインタ、配列、参照型のハンガリー記法" id="09" impl="NAMING-HN-09" severity="3"/>
            <rule autogen="true" header="char 型のポインタ、参照型のハンガリー記法" id="10" impl="NAMING-HN-10" severity="3"/>
            <rule autogen="true" header="const パラメータのハンガリー記法" id="11" impl="NAMING-HN-11" severity="3"/>
            <rule autogen="true" header="倍精度浮動小数点型のハンガリー記法" id="12" impl="NAMING-HN-12" severity="3"/>
            <rule autogen="true" header="倍精度浮動小数点型のポインタ、配列、参照型のハンガリー記法" id="13" impl="NAMING-HN-13" severity="3"/>
            <rule autogen="true" header="dword 型のハンガリー記法" id="14" impl="NAMING-HN-14" severity="3"/>
            <rule autogen="true" header="dwar 型のポインタ、配列、参照型のハンガリー記法" id="15" impl="NAMING-HN-15" severity="3"/>
            <rule autogen="true" header="動的に割り当てられた配列のハンガリー記法" id="16" impl="NAMING-HN-16" severity="3"/>
            <rule autogen="true" header="浮動小数点型のハンガリー記法" id="17" impl="NAMING-HN-17" severity="3"/>
            <rule autogen="true" header="浮動小数点型のポインタ、配列、参照型のハンガリー記法" id="18" impl="NAMING-HN-18" severity="3"/>
            <rule autogen="true" header="クラス宣言のハンガリー記法" id="19" impl="NAMING-HN-19" severity="3"/>
            <rule autogen="true" header="構造体宣言のハンガリー記法" id="20" impl="NAMING-HN-20" severity="3"/>
            <rule autogen="true" header="ifstream 型の変数およびパラメータのハンガリー記法" id="21" impl="NAMING-HN-21" severity="3"/>
            <rule autogen="true" header="int 型のハンガリー記法" id="22" impl="NAMING-HN-22" severity="3"/>
            <rule autogen="true" header="int 型のポインタ、配列、参照型のハンガリー記法" id="23" impl="NAMING-HN-23" severity="3"/>
            <rule autogen="true" header="istream 型の変数およびパラメータのハンガリー記法" id="24" impl="NAMING-HN-24" severity="3"/>
            <rule autogen="true" header="long int 型のハンガリー記法" id="25" impl="NAMING-HN-25" severity="3"/>
            <rule autogen="true" header="長倍精度浮動小数点型のハンガリー記法" id="26" impl="NAMING-HN-26" severity="3"/>
            <rule autogen="true" header="長倍精度浮動小数点型のポインタ、配列、参照型のハンガリー記法" id="27" impl="NAMING-HN-27" severity="3"/>
            <rule autogen="true" header="long int 型のポインタ、配列、参照型のハンガリー記法" id="28" impl="NAMING-HN-28" severity="3"/>
            <rule autogen="true" header="メンバ変数のハンガリー記法" id="29" impl="NAMING-HN-29" severity="3"/>
            <rule autogen="true" header="int 型のハンガリー記法" id="30" impl="NAMING-HN-30" severity="3"/>
            <rule autogen="true" header="int 型のポインタ、配列、参照型のハンガリー記法" id="31" impl="NAMING-HN-31" severity="3"/>
            <rule autogen="true" header="ofstream 型の変数およびパラメータのハンガリー記法" id="32" impl="NAMING-HN-32" severity="3"/>
            <rule autogen="true" header="ostream 型の変数およびパラメータのハンガリー記法" id="33" impl="NAMING-HN-33" severity="3"/>
            <rule autogen="true" header="ポインタのハンガリー記法" id="34" impl="NAMING-HN-34" severity="3"/>
            <rule autogen="true" header="参照ポインタのハンガリー記法" id="35" impl="NAMING-HN-35" severity="3"/>
            <rule autogen="true" header="shor int 型のハンガリー記法" id="36" impl="NAMING-HN-36" severity="3"/>
            <rule autogen="true" header="shor int 型のポインタ、配列、参照型のハンガリー記法" id="37" impl="NAMING-HN-37" severity="3"/>
            <rule autogen="true" header="静的変数のハンガリー記法" id="38" impl="NAMING-HN-38" severity="3"/>
            <rule autogen="true" header="string 型のハンガリー記法" id="39" impl="NAMING-HN-39" severity="3"/>
            <rule autogen="true" header="string 型のポインタ、配列、参照型のハンガリー記法" id="40" impl="NAMING-HN-40" severity="3"/>
            <rule autogen="true" header="unsigned 型のハンガリー記法" id="41" impl="NAMING-HN-41" severity="3"/>
            <rule autogen="true" header="void ポインタ型のハンガリー記法" id="42" impl="NAMING-HN-42" severity="3"/>
            <rule autogen="true" header="word 型のハンガリー記法" id="43" impl="NAMING-HN-43" severity="3"/>
            <rule autogen="true" header="word 型のポインタ、配列、参照型のハンガリー記法" id="44" impl="NAMING-HN-44" severity="3"/>
         </category>
         <rule autogen="true" header="#define 定数は必ず大文字にしなければならない" id="01" impl="NAMING-01" severity="3"/>
         <rule autogen="true" header="列挙リストでは、リスト メンバ (要素) は大文字、リストの名前は小文字でなければならない。またリストのタグまたは名前は小文字でなければならない" id="02" impl="NAMING-02" severity="3"/>
         <rule autogen="true" header="ファイル名には小文字を使用する" id="03" impl="NAMING-03" severity="3"/>
         <rule autogen="true" header="グローバル接頭辞は、グローバル変数にだけ使うべきである" id="04" impl="NAMING-04" severity="3"/>
         <rule autogen="true" header="ローカル変数名は小文字で開始しなければならない" id="05" impl="NAMING-05" severity="3"/>
         <rule autogen="true" header="グローバル変数名は小文字で開始しなければならない" id="06" impl="NAMING-06" severity="3"/>
         <rule autogen="true" header="メンバ変数名は小文字で開始しなければならない" id="07" impl="NAMING-07" severity="3"/>
         <rule autogen="true" header="boolean 型の変数名の先頭は b にする" id="08" impl="NAMING-08" severity="3"/>
         <rule autogen="true" header="クラス、構造体、共用体、列挙、typedef の先頭文字は大文字にする" id="09" impl="NAMING-09" severity="3"/>
         <rule autogen="true" header="抽象データー型、構造体、typedef、列挙名は大文字で開始しなければならない" id="10" impl="NAMING-10" severity="3"/>
         <rule autogen="true" header="列挙型の名前は、大文字で開始し、接尾辞 _t で終了させなければならない" id="11" impl="NAMING-11" severity="3"/>
         <rule autogen="true" header="構造体の名前は、大文字で開始し、接尾辞 '_t' で終了させなければならない" id="12" impl="NAMING-12" severity="3"/>
         <rule autogen="true" header="const 変数名の先頭は c にする" id="13" impl="NAMING-13" severity="3"/>
         <rule autogen="true" header="クラス データ メンバ名の先頭は its にする" id="14" impl="NAMING-14" severity="3"/>
         <rule autogen="true" header="double 型の変数名の先頭は d にする" id="15" impl="NAMING-15" severity="3"/>
         <rule autogen="true" header="float 型の変数名の先頭は f にする" id="16" impl="NAMING-16" severity="3"/>
         <rule autogen="true" header="関数名の先頭は大文字にする" id="17" impl="NAMING-17" severity="3"/>
         <rule autogen="true" header="グローバル変数名の先頭は the にする" id="18" impl="NAMING-18" severity="3"/>
         <rule autogen="true" header="int 型の変数名の先頭は i にする" id="19" impl="NAMING-19" severity="3"/>
         <rule autogen="true" header="is 関数は bool 値を返さなくてはならない" id="20" impl="NAMING-20" severity="3"/>
         <rule autogen="true" header="long int 型の変数名の先頭は li にする" id="21" impl="NAMING-21" severity="3"/>
         <rule autogen="true" header="ポインタ変数の変数名の先頭には p を付ける" id="22" impl="NAMING-22" severity="3"/>
         <rule autogen="true" header="short int 型の変数名の先頭は si にする" id="23" impl="NAMING-23" severity="3"/>
         <rule autogen="true" header="signed char 型の変数名の先頭は c にする" id="24" impl="NAMING-24" severity="3"/>
         <rule autogen="true" header="終端文字の変数の先頭は sz にする" id="25" impl="NAMING-25" severity="3"/>
         <rule autogen="true" header="unsigned char 型の変数名の先頭は uc にする" id="26" impl="NAMING-26" severity="3"/>
         <rule autogen="true" header="unsigned int 型の変数の先頭は ui にする" id="27" impl="NAMING-27" severity="3"/>
         <rule autogen="true" header="構造体と共用体のメンバ名には小文字を使用する" id="28" impl="NAMING-28" severity="3"/>
         <rule autogen="true" header="scalar ではない typedef には、必ず最後に _t を付ける" id="29" impl="NAMING-29" severity="3"/>
         <rule autogen="true" header="C 言語の実装ファイル名には拡張子 .c を使用する" id="30" impl="NAMING-30" severity="3"/>
         <rule autogen="true" header="大文字小文字の違いしかない型定義名を使用してはいけない" id="31" impl="NAMING-31" severity="3"/>
         <rule autogen="true" header="クラスのインクルード ファイル名の形式は“クラス名+ 拡張子”にするべきである" id="32" impl="NAMING-32" severity="3"/>
         <rule autogen="true" header="1 つまたは 2 つのアンダースコア (_ または __) で始まる識別子を使用しない" id="33" impl="NAMING-33" severity="3"/>
         <rule autogen="true" header="グローバル関数名は小文字で開始しなければならない" id="34" impl="NAMING-34" severity="3"/>
         <rule autogen="true" header="メンバ関数名は小文字で開始しなければならない" id="35" impl="NAMING-35" severity="3"/>
         <rule autogen="true" header="パラメータ名は宣言と定義で一致させる" id="36" impl="NAMING-36" severity="3"/>
         <rule autogen="true" header="C++ のインクルード ファイルの拡張子は .hh にする" id="37" impl="NAMING-37" severity="3"/>
         <rule autogen="true" header="C++ の実装ファイルの拡張子は .cc にする" id="38" impl="NAMING-38" severity="3"/>
         <rule autogen="true" header="インライン定義ファイルの拡張子は .icc にする" id="39" impl="NAMING-39" severity="3"/>
         <rule autogen="true" header="クラス、構造体、名前空間、列挙型、typedef の最初の 1 文字を大文字にする" id="40" impl="NAMING-40" severity="3"/>
         <rule autogen="true" header="ヘッダー ファイルの拡張子は常に .h にする" id="41" impl="NAMING-41" severity="3"/>
         <rule autogen="true" header="定数および列挙値の識別子は小文字でなければならない" id="42" impl="NAMING-42" severity="2"/>
         <rule autogen="true" header="ファイル拡張子がある場合は、&#34;*.cpp&#34; または &#34;*.h&#34;でなければならない" id="43" impl="NAMING-43" severity="3"/>
         <rule autogen="true" header="関数および変数名はすべて小文字でなければならない" id="44" impl="NAMING-44" severity="3"/>
         <rule autogen="true" header="大文字/小文字の違い、アンダースコア、見た目の似た文字や数字の違いで識別子を区別してはならない" id="45" impl="NAMING-45" severity="3"/>
         <rule autogen="true" header="文字 '、&#34;、/* または // をヘッダー ファイル名で使用してはならない" id="46" impl="NAMING-46" severity="3"/>
         <rule autogen="true" header="異なる識別子は見た目にも明確に区別できなければならない" id="47" impl="NAMING-47" severity="3"/>
         <rule autogen="true" header="ヘッダー ファイル名に \ 文字を使用するべきではない" id="48" impl="NAMING-48" severity="3"/>
         <rule autogen="true" header="C++ 言語の実装ファイルには、常に拡張子 &#34;.cpp&#34; がなければならない " id="49" impl="NAMING-49" severity="4"/>
         <rule autogen="true" header="同じ名前空間にあり可視性が重なる識別子は見た目で明確に区別できなければならない" id="50" impl="NAMING-50" severity="4"/>
         <rule autogen="true" header="ユーザー定義リテラル演算子のユーザー定義の接尾辞は、アンダースコアで始まり 1 文字以上の文字が続く必要がある" id="51" impl="NAMING-51" severity="3"/>
         <rule autogen="true" header="ユニバーサル文字名は、文字または文字列リテラルの内部でだけ使用する" id="52" impl="NAMING-52" severity="3"/>
         <rule autogen="true" header="ヘッダー ファイルにはファイル拡張子  &#34;.h&#34;、&#34;.hpp&#34; または &#34;.hxx&#34; を付けるべきである" id="53" impl="NAMING-53" severity="3"/>
         <rule autogen="true" header="視覚的に区別しやすい識別子を使用する" id="54" impl="NAMING-54" severity="3"/>
      </category>
      <category description="オブジェクト指向" name="OOP">
         <rule autogen="true" header="基底クラスでは、public コピー コンストラクターおよび代入演算子を避ける" id="01" impl="OOP-01" severity="3"/>
         <rule autogen="true" header="スライシングを避ける。基底クラスでのコピーの代わりにクローンを使用する" id="02" impl="OOP-02" severity="3"/>
         <rule autogen="true" header="仮想継承を除いて、クラスは他のクラスを 2 回以上継承してはならない" id="03" impl="OOP-03" severity="1"/>
         <rule autogen="true" header="2 つ以上の基底クラスから同じ名前の関数を継承しない" id="04" impl="OOP-04" severity="3"/>
         <rule autogen="true" header="多重継承を使ってはいけない" id="05" impl="OOP-05" severity="2"/>
         <rule autogen="true" header="多重継承では仮想共通基底クラスを使用する" id="06" impl="OOP-06" severity="3"/>
         <rule autogen="true" header="抽象インターフェイスでないクラスの多重継承に注意する" id="07" impl="OOP-07" severity="1"/>
         <rule autogen="true" header="多重継承は最大でも 1 つの protected 実装に制限する" id="07_a" impl="OOP-07_a" severity="2"/>
         <rule autogen="true" header="多重継承では、public 実装を使用しない" id="07_b" impl="OOP-07_b" severity="2"/>
         <rule autogen="true" header="コンストラクタから直接グローバル データにアクセスしてはいけない" id="08" impl="OOP-08" severity="1"/>
         <rule autogen="true" header="デストラクタでのグローバルオブジェクトの使用を避ける" id="09" impl="OOP-09" severity="3"/>
         <rule autogen="true" header="メンバ関数でグローバル データを使用しない" id="10" impl="OOP-10" severity="2"/>
         <rule autogen="true" header="フレンド メカニズムを使用してはいけない" id="11" impl="OOP-11" severity="3"/>
         <rule autogen="true" header="protected メンバー関数は private クラス データへの const ではないハンドルを返してはならない" id="12" impl="OOP-12" severity="3"/>
         <rule autogen="true" header="継承された仮想関数を別のデフォルト パラメーター値で再定義してはならない" id="13" impl="OOP-13" severity="3"/>
         <rule autogen="true" header="private 継承ではなくコンポジションを使用する" id="14" impl="OOP-14" severity="5"/>
         <rule autogen="true" header="コンストラクターから仮想関数を呼び出してはいけない" id="16" impl="OOP-16" severity="1"/>
         <rule autogen="true" header="デストラクターから仮想関数を呼び出してはいけない" id="16_b" impl="OOP-16_b" severity="1"/>
         <rule autogen="true" header="オーバーロードされた関数を再宣言する場合、using 宣言を使用する " id="17" impl="OOP-17" severity="4"/>
         <rule autogen="true" header="public データ メンバを使用しない" id="18" impl="OOP-18" severity="2"/>
         <rule autogen="true" header="protected データ メンバは使用しない" id="19" impl="OOP-19" severity="2"/>
         <rule autogen="true" header="派生クラスから基底クラスへの明示的キャストを避ける" id="20" impl="OOP-20" severity="3"/>
         <rule autogen="true" header="サブクラスで仮想関数を実装する場合は virtual キーワードを使用する" id="21" impl="OOP-21" severity="3"/>
         <rule autogen="true" header="基底クラスとして使用され仮想関数を持つクラスに仮想デストラクタを定義する" id="22" impl="OOP-22" severity="1"/>
         <rule autogen="true" header="クラスに仮想関数がある場合、仮想デストラクタがなければならない" id="23" impl="OOP-23" severity="2"/>
         <rule autogen="true" header="基底クラスではデストラクタを仮想にする" id="24" impl="OOP-24" severity="1"/>
         <rule autogen="true" header="仮想関数をインライン化しない" id="25" impl="OOP-25" severity="3"/>
         <rule autogen="true" header="派生クラスのオブジェクトへのポインタを、仮想基底クラスのオブジェクトへのポインタに変換してはならない" id="26" impl="OOP-26" severity="3"/>
         <rule autogen="true" header="参照または const メンバを持つクラスのコピー代入演算子を宣言する" id="27" impl="OOP-27" severity="3"/>
         <rule autogen="true" header="継承階層をダウンキャストしてはいけない" id="28" impl="OOP-28" severity="2"/>
         <rule autogen="true" header="抽象クラスへのポインタを、そのクラスを継承しているクラスへのポインタに変換してはいけない" id="29" impl="OOP-29" severity="1"/>
         <rule autogen="true" header="コピーコンストラクタとコピー代入演算子を private に宣言した基底クラスをつくる" id="30" impl="OOP-30" severity="3"/>
         <rule autogen="true" header="基底クラスのデストラクタを public かつ仮想、または protected かつ非仮想にする" id="31" impl="OOP-31" severity="1"/>
         <rule autogen="true" header="継承された非仮想関数を再定義してはいけない" id="32" impl="OOP-32" severity="3"/>
         <rule autogen="true" header="テンプレート パラメーターを持つ継承された非仮想関数を再定義してはいけない" id="33" impl="OOP-33" severity="3"/>
         <rule autogen="true" header="operator= での自分自身への代入をチェックする" id="34" impl="OOP-34" severity="4"/>
         <rule autogen="true" header="ダウンキャスト (基底クラスから派生クラスへのキャスト) を許可してはいけない" id="35" impl="OOP-35" severity="2"/>
         <rule autogen="true" header="public メンバー関数は private/protected クラス データへの const ではないハンドルを返してはならない" id="36" impl="OOP-36" severity="3"/>
         <rule autogen="true" header="継承が必要ない場合、合成を使用する" id="37" impl="OOP-37" severity="5"/>
         <rule autogen="true" header="仮想関数があるクラスのデストラクタが呼び出される場合、クラスは仮想デストラクタを持つべきである" id="38" impl="OOP-38" severity="1"/>
         <rule autogen="true" header="仮想基底クラスは、派生クラスで明示的に宣言する" id="39" impl="OOP-39" severity="4"/>
         <rule autogen="true" header="状態を持つ仮想基底クラスは、クラスにアクセスする派生クラスで明示的に宣言する" id="39_b" impl="OOP-39_b" severity="2"/>
         <rule autogen="true" header="抽象クラスから階層を開始する" id="40" impl="OOP-40" severity="4"/>
         <rule autogen="true" header="同じ階層の中で、基底クラスを仮想と非仮想の両方にすることはできない" id="41" impl="OOP-41" severity="2"/>
         <rule autogen="true" header="抽象クラスではコピー代入演算子を protected または private として宣言する" id="42" impl="OOP-42" severity="3"/>
         <rule autogen="true" header="純粋仮想関数として宣言された仮想関数だけを純粋仮想関数によってオーバーライドできる" id="43" impl="OOP-43" severity="4"/>
         <rule autogen="true" header="継承階層のすべてのパスで各仮想関数に複数の定義があってはならない" id="44" impl="OOP-44" severity="3"/>
         <rule autogen="true" header="基本型の 1 つの引数で呼び出せるすべてのコンストラクタを explicit として宣言する" id="45" impl="OOP-45" severity="3"/>
         <rule autogen="true" header="コピー コンストラクタは基底クラスと自身がメンバであるクラスの静的でないメンバの初期化だけを行う" id="46" impl="OOP-46" severity="3"/>
         <rule autogen="true" header="仮想基底クラスからクラスを派生するべきではない" id="47" impl="OOP-47" severity="3"/>
         <rule autogen="true" header="非 POD 型のメンバー データは private でなければならない" id="48" impl="OOP-48" severity="3"/>
         <rule autogen="true" header="ポリモーフィックな型で基底クラスから派生クラスへのキャストを行うべきではない" id="49" impl="OOP-49" severity="1"/>
         <rule autogen="true" header="仮想基底クラスへのポインタは dynamic_cast によってだけ派生クラスへのポインタにキャストできる" id="50" impl="OOP-50" severity="3"/>
         <rule autogen="true" header="static 関数だけを含むクラスまたは構造体の代わりに名前空間を使用する" id="51" impl="OOP-51" severity="5"/>
         <rule autogen="true" header="クラスへのポインターを派生クラス以外の別のクラスへのポインターに変換してはならない" id="52" impl="OOP-52" severity="4"/>
         <rule autogen="true" header="派生クラスで宣言されたメンバー関数は、基底クラスで宣言された関数を隠してはならない" id="53" impl="OOP-53" severity="3"/>
         <rule autogen="true" header="オーバーライドされたメソッドまたは隠されたメソッドのアクセシビリティを引き上げてはならない" id="54" impl="OOP-54" severity="3"/>
         <rule autogen="true" header="非 POD 型はクラスとして定義するべきである" id="55" impl="OOP-55" severity="4"/>
         <rule autogen="true" header="ユーザー定義の代入演算子は virtual であってはならない" id="56" impl="OOP-56" severity="3"/>
         <rule autogen="true" header="構造体には、public データ メンバーだけを含めるべきであり、基底であったり継承を行ったりするべきではない" id="57" impl="OOP-57" severity="3"/>
      </category>
      <category description="最適化" name="OPT">
         <rule autogen="true" header="変数をできるかぎり局所的に宣言する" id="01" impl="OPT-01" severity="3"/>
         <rule autogen="true" header="使用されないローカル変数は避ける" id="02" impl="OPT-02" severity="4"/>
         <rule autogen="true" header="使用されないパラメータは削除する" id="03" impl="OPT-03" severity="2"/>
         <rule autogen="true" header="++ および -- の標準形式の推奨。前置形式の呼び出しを使用する" id="04" impl="OPT-04" severity="3"/>
         <rule autogen="true" header="未使用の private メンバー変数を避ける" id="05" impl="OPT-05" severity="3"/>
         <rule autogen="true" header="不要なローカル変数を避ける" id="06" impl="OPT-06" severity="4"/>
         <rule autogen="true" header="@が +、-、*、/、% である場合、a = a @ b ではなく a @= b を使用する" id="07" impl="OPT-07" severity="3"/>
         <rule autogen="true" header="@が &amp;、|、^、&lt;&lt;、&gt;&gt; である場合、a = a @ b ではなく a @= b を使用する" id="08" impl="OPT-08" severity="3"/>
         <rule autogen="true" header="不要な == true を削除する" id="09" impl="OPT-09" severity="5"/>
         <rule autogen="true" header="if、for、while、do while 文の中で変数を宣言しない" id="10" impl="OPT-10" severity="3"/>
         <rule autogen="true" header="ファイル レベルの静的変数が 1 つの関数でだけ使用または参照される場合、変数を関数の一部とする" id="11" impl="OPT-11" severity="3"/>
         <rule autogen="true" header="ファイル レベルの静的変数が、1 つのクラスでだけ使用または参照される場合、変数をクラスの一部とする" id="12" impl="OPT-12" severity="3"/>
         <rule autogen="true" header="メンバ変数を大きさの降順に宣言する" id="13" impl="OPT-13" severity="3"/>
         <rule autogen="true" header="値ではなく参照でオブジェクトを渡す" id="14" impl="OPT-14" severity="3"/>
         <rule autogen="true" header="暗黙的な型変換を避けるため、オーバーロードを使用する" id="15" impl="OPT-15" severity="3"/>
         <rule autogen="true" header="再帰、ループ、仮想関数の呼び出しを含むグローバル関数をインライン化してはならない" id="16" impl="OPT-16" severity="3"/>
         <rule autogen="true" header="コンストラクタおよびデストラクタをインライン化してはならない" id="17" impl="OPT-17" severity="3"/>
         <rule autogen="true" header="再帰またはループを含むメンバー関数をインライン化してはならない" id="18" impl="OPT-18" severity="3"/>
         <rule autogen="true" header="単独の op ではなく op= の使用を推奨する" id="19" impl="OPT-19" severity="3"/>
         <rule autogen="true" header="変数の定義は可能な限り先延ばしする" id="20" impl="OPT-20" severity="3"/>
         <rule autogen="true" header="すべての switch 文に空ではない case 句が 1 つ以上なければならない" id="21" impl="OPT-21" severity="3"/>
         <rule autogen="true" header="意味のない case 文は許されない" id="22" impl="OPT-22" severity="3"/>
         <rule autogen="true" header="小さいアクセサ関数やミューテータ関数はインラインにする" id="23" impl="OPT-23" severity="4"/>
         <rule autogen="true" header="小さいフォワード関数はインラインにする" id="24" impl="OPT-24" severity="4"/>
         <rule autogen="true" header="文の数が 1 つか 2 つの関数だけをインライン関数にする" id="25" impl="OPT-25" severity="4"/>
         <rule autogen="true" header="意味のある値で初期化できる時まで、変数を宣言しない" id="26" impl="OPT-26" severity="2"/>
         <rule autogen="true" header="アクセサおよびミューテータの数を最小にする" id="27" impl="OPT-27" severity="4"/>
         <rule autogen="true" header="strlen 関数を使用して文字列が NULL か NULL 以外かをチェックしてはならない" id="28" impl="OPT-28" severity="3"/>
         <rule autogen="true" header="同じ型への冗長なキャストを行わない" id="29" impl="OPT-29" severity="4"/>
         <rule autogen="true" header="内部リンケージを持つ定義されたすべての関数は少なくとも 1 度は使用されなければならない" id="30" impl="OPT-30" severity="3"/>
         <rule autogen="true" header="virtual でない関数には使用されない名前付きまたは無名のパラメータがあってはならない" id="31" impl="OPT-31" severity="3"/>
         <rule autogen="true" header="void 型の戻り値を持つ空ではないすべての関数には外部的な副作用がなければならない" id="32" impl="OPT-32" severity="3"/>
         <rule autogen="true" header="void 型の戻り値を持つ関数は空であってはならない" id="32_b" impl="OPT-32_b" severity="4"/>
         <rule autogen="true" header="オブジェクトを値ではなく参照で返すことを検討する" id="33" impl="OPT-33" severity="5"/>
         <rule autogen="true" header="変数を自分自身に代入してはならない" id="35" impl="OPT-35" severity="3"/>
         <rule autogen="true" header="変数の初期化子の中で自分自身を使用してはならない" id="36" impl="OPT-36" severity="3"/>
         <rule autogen="true" header="関数は未使用のラベル宣言を持つべきではない" id="37" impl="OPT-37" severity="4"/>
         <rule autogen="true" header="関数に未使用のパラメーターがあってはならない" id="38" impl="OPT-38" severity="4"/>
         <rule autogen="true" header="switch 文には少なくとも 2 個の switch 句がなければならない" id="39" impl="OPT-39" severity="3"/>
         <rule autogen="true" header="if-else-if 連鎖の 2 つのブランチに (プリプロセス後の状態で) 同一のコードがある" id="40_a" impl="OPT-40_a" severity="4"/>
         <rule autogen="true" header="switch 文の複数の句に (プリプロセス後の状態で) 同一のコードがある" id="40_b" impl="OPT-40_b" severity="4"/>
         <rule autogen="true" header="ファイルは、そのファイルをコンパイルするのに必要な宣言および定義を含むヘッダーだけを直接的にインクルードするべきである" id="41" impl="OPT-41" severity="4"/>
         <rule autogen="true" header="仮想関数に未使用の名前付きパラメーターがあってはならない" id="42" impl="OPT-42" severity="3"/>
      </category>
      <category description="バグの可能性" name="PB">
         <rule autogen="true" header="ポインタ型の式の間接参照を行ってはならない" id="01" impl="PB-01" severity="3"/>
         <rule autogen="true" header="a(b)、a[b]、キャストの中で代入を使用しない" id="02" impl="PB-02" severity="3"/>
         <rule autogen="true" header="3 項演算子で型を混合させてはならない" id="03" impl="PB-03" severity="3"/>
         <rule autogen="true" header="関数の戻り値は宣言された型と一致しなければならない" id="05" impl="PB-05" severity="3"/>
         <rule autogen="true" header="代入演算子のオペランドの型には互換性がなければならない" id="06" impl="PB-06" severity="3"/>
         <rule autogen="true" header="関数の戻り値を互換性のない型の変数に代入してはならない" id="07" impl="PB-07" severity="3"/>
         <rule autogen="true" header="符号付き定数を符号なし整数変数に代入してはならない" id="08" impl="PB-08" severity="3"/>
         <rule autogen="true" header="演算子は値を参照で返してはならない" id="09" impl="PB-09" severity="2"/>
         <rule autogen="true" header="配列をポリモーフィックに処理しない" id="10" impl="PB-10" severity="3"/>
         <rule autogen="true" header="関数の仮引数と実引数の宣言型は一致しなければならない" id="11" impl="PB-11" severity="3"/>
         <rule autogen="true" header="signed char を unsigned int にキャストしてはいけない" id="12" impl="PB-12" severity="3"/>
         <rule autogen="true" header="非ポインタに対して delete を呼び出してはいけない" id="13" impl="PB-13" severity="1"/>
         <rule autogen="true" header="不正な End-Of-String (EOS) 定義" id="14" impl="PB-14" severity="3"/>
         <rule autogen="true" header="2 つの整数型の除算の結果を浮動小数点型に代入してはいけない" id="15" impl="PB-15" severity="3"/>
         <rule autogen="true" header="整数の除算の剰余が意図せず破棄されるのを防ぐ" id="15_b" impl="PB-15_b" severity="3"/>
         <rule autogen="true" header="char 型の範囲を超えた定数は避ける" id="16" impl="PB-16" severity="3"/>
         <rule autogen="true" header="unsigned char 型の範囲を超えた定数は避ける" id="17" impl="PB-17" severity="3"/>
         <rule autogen="true" header="ポインタおよび数値型でクラス メソッドをオーバーロードすることを避ける" id="18" impl="PB-18" severity="3"/>
         <rule autogen="true" header="ローカルな静的データを含むインライン非メンバ関数を作成しない" id="19" impl="PB-19" severity="3"/>
         <rule autogen="true" header="関数引数および戻り値のスライシングを避ける" id="20" impl="PB-20" severity="3"/>
         <rule autogen="true" header="適切に文字列を終了させる" id="21" impl="PB-21" severity="1"/>
         <rule autogen="true" header="a(b)、a[b]、キャストの中でインクリメント式およびデクリメント式を使用しない" id="22" impl="PB-22" severity="3"/>
         <rule autogen="true" header="クラスに静的でないポインタがあり、コピー コンストラクタが宣言されていない場合、クラスのオブジェクトを参照で渡さなければならない" id="23" impl="PB-23" severity="1"/>
         <rule autogen="true" header="コンストラクターは、暗黙に定義されたコピー コンストラクターと同じシグネチャになるデフォルト引数を定義してはならない" id="24" impl="PB-24" severity="2"/>
         <rule autogen="true" header="符号なしの算術を使用してはならない" id="25" impl="PB-25" severity="2"/>
         <rule autogen="true" header="クラスのコンストラクタから public および protected メソッドを呼び出してはならない" id="26" impl="PB-26" severity="2"/>
         <rule autogen="true" header="文字列リテラルを変更してはならない" id="27" impl="PB-27" severity="2"/>
         <rule autogen="true" header="次の文字群はヘッダー ファイル名に出現してはならない: '、\、/*、//、&#34;" id="28" impl="PB-28" severity="2"/>
         <rule autogen="true" header="右シフト演算の左辺のオペランドは負数であってはならない" id="29" impl="PB-29" severity="2"/>
         <rule autogen="true" header="複数の列挙型を switch 条件または case 文のラベルとして使用してはならない" id="30" impl="PB-30" severity="3"/>
         <rule autogen="true" header="定数で sizeof を呼び出してはならない" id="31" impl="PB-31" severity="3"/>
         <rule autogen="true" header="ポインタ型で sizeof を呼び出してはならない" id="32" impl="PB-32" severity="3"/>
         <rule autogen="true" header="列挙型を含む代入での暗黙の型変換を避ける" id="33" impl="PB-33" severity="3"/>
         <rule autogen="true" header="列挙型を含む比較での暗黙の型変換を避ける" id="33_b" impl="PB-33_b" severity="3"/>
         <rule autogen="true" header="memcpy/strncpy/memmove の 3 番目のパラメータは 2 番目のパラメータに依存してはならない" id="34" impl="PB-34" severity="3"/>
         <rule autogen="true" header="条件文で括弧なしに代入演算子を使用してはならない" id="35" impl="PB-35" severity="3"/>
         <rule autogen="true" header="コンストラクタまたはデストラクタの本体からオブジェクトの動的な型を使用してはならない" id="36" impl="PB-36" severity="3"/>
         <rule autogen="true" header="&lt;cstring&gt; ライブラリの無制限の関数を使用してはならない" id="37" impl="PB-37" severity="3"/>
         <rule autogen="true" header="ナロー文字列リテラルとワイド文字列リテラルを連結してはならない" id="38" impl="PB-38" severity="3"/>
         <rule autogen="true" header="エンコーディング接頭辞が異なる文字列リテラルを結合してはならない" id="38_b" impl="PB-38_b" severity="3"/>
         <rule autogen="true" header="関数は参照または const 参照によって渡されたパラメータへの参照またはポインタを返してはならない" id="39" impl="PB-39" severity="3"/>
         <rule autogen="true" header="関数は const 参照によって渡されたパラメータへの参照またはポインタを返してはならない" id="39_b" impl="PB-39_b" severity="3"/>
         <rule autogen="true" header="関数への引数として渡される配列型の識別子をポインタに変化させてはならない" id="41" impl="PB-41" severity="3"/>
         <rule autogen="true" header="ポインター型または配列型のパラメーターを持つ関数に配列型の式を渡してはならない" id="41_b" impl="PB-41_b" severity="3"/>
         <rule autogen="true" header="オブジェクトを重複するオブジェクトに代入してはならない" id="42" impl="PB-42" severity="3"/>
         <rule autogen="true" header="クラスのすべてのコンストラクタは明示的に直接の基底クラスおよびすべての仮想基底クラスのコンストラクタを呼び出すべきである" id="43" impl="PB-43" severity="3"/>
         <rule autogen="true" header="'std::atexit()' または 'std::at_quick_exit()' で登録された関数の実行は、例外によって終了すべきではない" id="44" impl="PB-44" severity="3"/>
         <rule autogen="true" header="文字列書式関数の呼び出しで、書式文字列の '%s' または '%c' 書式指定子と対応する引数の間に不整合があってはならない" id="45" impl="PB-45" severity="3"/>
         <rule autogen="true" header="文字列書式関数の呼び出しで、書式文字列の '%f' 書式指定子と対応する引数の間に不整合があってはならない" id="46" impl="PB-46" severity="3"/>
         <rule autogen="true" header="文字列書式関数の呼び出しで、書式文字列の '%i' および '%d' 書式指定子と対応する引数の間に不整合があってはならない" id="47" impl="PB-47" severity="3"/>
         <rule autogen="true" header="文字列書式関数の呼び出しで、書式文字列の '%u' 書式指定子と対応する引数の間に不整合があってはならない" id="48" impl="PB-48" severity="3"/>
         <rule autogen="true" header="文字列書式関数の呼び出しで、書式文字列の '%p' 書式指定子と対応する引数の間に不整合があってはならない" id="49" impl="PB-49" severity="3"/>
         <rule autogen="true" header="文字列書式関数の呼び出しで、書式文字列中の書式指定子の数と対応する引数の数は同じでなければならない" id="50" impl="PB-50" severity="3"/>
         <rule autogen="true" header="非配列型を扱うポインタにポインタ算術を適用してはならない" id="51" impl="PB-51" severity="3"/>
         <rule autogen="true" header="ポインタおよび数値型でグローバル関数をオーバーロードすることを避ける" id="52" impl="PB-52" severity="3"/>
         <rule autogen="true" header="ポインタおよび数値型で名前空間の関数をオーバーロードすることを避ける" id="53" impl="PB-53" severity="3"/>
         <rule autogen="true" header="キャストの時点で不完全なクラスから、またはそのようなクラスへ、キャストしてはならない" id="54" impl="PB-54" severity="2"/>
         <rule autogen="true" header="削除の時点で不完全なオブジェクトを削除してはならない" id="55" impl="PB-55" severity="2"/>
         <rule autogen="true" header="signed 型から unsigned 型への暗黙の変換を避ける" id="56" impl="PB-56" severity="3"/>
         <rule autogen="true" header="派生クラス オブジェクトの配列を指すポインターを、基底クラスのポインターに変換してはいけない" id="57" impl="PB-57" severity="3"/>
         <rule autogen="true" header="列挙子リストで、非明示的に指定された列挙定数の値は一意でなければならない" id="58" impl="PB-58" severity="3"/>
         <rule autogen="true" header="文字列配列の初期化にカンマがない" id="59" impl="PB-59" severity="3"/>
         <rule autogen="true" header="malloc への疑わしい引数" id="60" impl="PB-60" severity="3"/>
         <rule autogen="true" header="割り当てられたばかりのメモリに対してポインター算術演算が行われている" id="61" impl="PB-61" severity="3"/>
         <rule autogen="true" header="誤った引数の順序で関数を呼び出さない" id="62" impl="PB-62" severity="3"/>
         <rule autogen="true" header="関数のアドレスとゼロを比較するべきではない" id="63" impl="PB-63" severity="3"/>
         <rule autogen="true" header="文字列比較関数から返された値はゼロとだけ比較するべきである" id="64" impl="PB-64" severity="3"/>
         <rule autogen="true" header="結果がより広い整数型に代入されている式での整数オーバーフローの可能性を避ける" id="65" impl="PB-65" severity="3"/>
         <rule autogen="true" header="結果がより広い整数型の式と比較されている式での整数オーバーフローの可能性を避ける" id="65_b" impl="PB-65_b" severity="3"/>
         <rule autogen="true" header=" '+', '-', '*' 演算子の定数式における整数オーバーフローまたはアンダーフロー" id="66_a" impl="PB-66_a" severity="3"/>
         <rule autogen="true" header="'&lt;&lt;' 演算子の定数式における整数オーバーフローまたはアンダーフロー" id="66_b" impl="PB-66_b" severity="4"/>
         <rule autogen="true" header="if-else 文の 2 つのブランチに (プリプロセス後の状態で) 同一のコードがある" id="67" impl="PB-67" severity="3"/>
         <rule autogen="true" header="列挙型にゼロ定数だけ、またはゼロ以外の定数だけしかないために、常に同じ値に評価されるブール条件" id="68" impl="PB-68" severity="2"/>
         <rule autogen="true" header="オブジェクトの要素を複数回初期化してはならない" id="69" impl="PB-69" severity="3"/>
         <rule autogen="true" header="列挙型を潜在型とする式は、列挙型の列挙子に対応する値だけを持つことができる" id="70" impl="PB-70" severity="3"/>
         <rule autogen="true" header="フレキシブルな配列メンバーを含む構造体のインスタンスをコピーしない" id="71" impl="PB-71" severity="3"/>
         <rule autogen="true" header="誤った型の引数を指定して va_arg を呼び出さない" id="72" impl="PB-72" severity="3"/>
         <rule autogen="true" header="符号なし整数定数式の評価はラップアラウンドするべきではない" id="73" impl="PB-73" severity="5"/>
         <rule autogen="true" header="1 より大きい値の定数をイテレーターに加算またはイテレーターから減算してはならない" id="74" impl="PB-74" severity="4"/>
         <rule autogen="true" header="stdlib.h または cstdlib ライブラリの abort() 関数を使用しない" id="75" impl="PB-75" severity="3"/>
         <rule autogen="true" header="stdlib.h または cstdlib ライブラリの exit() 関数を使用しない" id="75_b" impl="PB-75_b" severity="3"/>
         <rule autogen="true" header="stdlib.h または cstdlib ライブラリの関数 quick_exit() および _Exit() は使用してはならない" id="75_c" impl="PB-75_c" severity="3"/>
         <rule autogen="true" header="C スタイルの文字列を使用してはならない" id="76" impl="PB-76" severity="3"/>
         <rule autogen="true" header="式文は、一時オブジェクトのコンストラクターの明示的な呼び出しだけを含むべきではない" id="77" impl="PB-77" severity="3"/>
         <rule autogen="true" header="プログラマー定義の整数型での書式付き IO には intmax_t または uintmax_t を使用する" id="78" impl="PB-78" severity="3"/>
         <rule autogen="true" header="文法的に曖昧な関数宣言を避ける" id="79" impl="PB-79" severity="3"/>
      </category>
      <category description="物理ファイル編成" name="PFO">
         <rule autogen="true" header="リンケージを持つ実体をヘッダー ファイルに定義しない" id="01" impl="PFO-01" severity="3"/>
         <rule autogen="true" header="多重インクルード ガードを使用する" id="02" impl="PFO-02" severity="3"/>
         <rule autogen="true" header="インクルード ファイルには 2 つ以上クラス定義があってはならない" id="03" impl="PFO-03" severity="3"/>
         <rule autogen="true" header="各実装ファイルは、ファイルを説明するローカル定数文字列を宣言しなければならない" id="04" impl="PFO-04" severity="5"/>
         <rule autogen="true" header=".c ファイルに他の .c ファイルをインクルードしてはならない" id="05" impl="PFO-05" severity="3"/>
         <rule autogen="true" header=".icc ファイルに別のファイルをインクルードしてはいけない" id="06" impl="PFO-06" severity="3"/>
         <rule autogen="true" header="ヘッダー ファイル名に基づいたパターンの多重インクルード ガードを使用する" id="07" impl="PFO-07" severity="3"/>
         <rule autogen="true" header="多重インクルードを防ぐメカニズムとしてインクルード ガードまたは #pragma once プリプロセッサ命令を使用する" id="08" impl="PFO-08" severity="3"/>
         <rule autogen="true" header="&#34;#pragma once&#34; プリプロセッサ命令をソース ファイルで使用してはならない" id="09" impl="PFO-09" severity="3"/>
         <rule autogen="true" header="ヘッダー ファイルに複数のクラスを定義しない" id="10" impl="PFO-10" severity="3"/>
      </category>
      <category description="移植性" name="PORT">
         <rule autogen="true" header="long 型を指示するには、小文字の l ではなく大文字の L を使用する" id="01" impl="PORT-01" severity="5"/>
         <rule autogen="true" header="int 型の演算の結果を long 型に代入する場合、演算の前に少なくとも 1 つの int をlong にキャストするべきである" id="02" impl="PORT-02" severity="3"/>
         <rule autogen="true" header="構造体で、オフセットのハード コーディング値を使用してはいけない" id="03" impl="PORT-03" severity="2"/>
         <rule autogen="true" header="16 進定数 '0xffffffff' をエラーのマーカーとして使用してはならない" id="04" impl="PORT-04" severity="2"/>
         <rule autogen="true" header="long へのポインタはint へのポインタにキャストするべきでない" id="05" impl="PORT-05" severity="2"/>
         <rule autogen="true" header="long int を int に代入してはならない" id="06" impl="PORT-06" severity="3"/>
         <rule autogen="true" header="関数呼び出しで int にキャストした long を渡してはならない" id="07" impl="PORT-07" severity="3"/>
         <rule autogen="true" header="long への定数の代入は、整数リテラルを含むべきではない" id="08" impl="PORT-08" severity="3"/>
         <rule autogen="true" header="long int 型を int 型リテラルで初期化してはならない" id="10" impl="PORT-10" severity="3"/>
         <rule autogen="true" header="int のポインタを long のポインタにキャストしてはならない" id="11" impl="PORT-11" severity="2"/>
         <rule autogen="true" header="32-bit の乗算の結果を long の値に代入してはならない" id="12" impl="PORT-12" severity="3"/>
         <rule autogen="true" header="int 型を常に unsigned int または signed int として宣言する" id="13" impl="PORT-13" severity="3"/>
         <rule autogen="true" header="より短い型からより長い型に型変換しないよう注意する" id="14" impl="PORT-14" severity="3"/>
         <rule autogen="true" header="より短い型からより長い型に型変換しないよう注意する" id="15" impl="PORT-15" severity="3"/>
         <rule autogen="true" header="より短い型からより長い型に型変換しないよう注意する" id="16" impl="PORT-16" severity="3"/>
         <rule autogen="true" header="i64 または L サフィックスを直接使用してはいけない" id="17" impl="PORT-17" severity="3"/>
         <rule autogen="true" header="式の long 型のオペランドをキャストするのではなく、式の結果をキャストする" id="19" impl="PORT-19" severity="3"/>
         <rule autogen="true" header="long 型の変数を直接宣言してはならない" id="20" impl="PORT-20" severity="3"/>
         <rule autogen="true" header="long の値を double に代入してはならない" id="21" impl="PORT-21" severity="3"/>
         <rule autogen="true" header="long 型の大きな配列の代わりに int 型の配列を使用する" id="22" impl="PORT-22" severity="5"/>
         <rule autogen="true" header="long 型の大きな動的配列の代わりに int 型の配列を使用する" id="23" impl="PORT-23" severity="5"/>
         <rule autogen="true" header="bool、char、short、int および float 型へのポインタの大きな配列を使用しない" id="24" impl="PORT-24" severity="5"/>
         <rule autogen="true" header="識別子の名前は 64 文字を超えるべきではない" id="25" impl="PORT-25" severity="3"/>
         <rule autogen="true" header="アクセス指定子によって分けられた非静的データ メンバの割り当ての順序について、アルゴリズムは仮定を設けてはならない" id="26" impl="PORT-26" severity="2"/>
         <rule autogen="true" header="より狭い型への暗黙の変換を避ける" id="27" impl="PORT-27" severity="3"/>
         <rule autogen="true" header="定数値のより狭い型への変換を避ける" id="28" impl="PORT-28" severity="3"/>
         <rule autogen="true" header="データをファイルに書き込む関数に構造体へのポインターを渡すべきではない" id="29" impl="PORT-29" severity="3"/>
         <rule autogen="true" header="実行境界を越えて例外をスローしてはならない" id="30" impl="PORT-30" severity="4"/>
         <rule autogen="true" header="実行境界を越えて非標準レイアウト型のオブジェクトを渡してはならない" id="31" impl="PORT-31" severity="4"/>
         <rule autogen="true" header="long double 型を使用してはならない" id="32" impl="PORT-32" severity="3"/>
         <rule autogen="true" header="wchar_t 型を使用してはならない" id="33" impl="PORT-33" severity="3"/>
         <rule autogen="true" header="ユーザー定義の C++ 外部識別子は、 先頭から 64 文字目までに違いがあるべきである" id="34_a" impl="PORT-34_a" severity="3"/>
         <rule autogen="true" header="ユーザー定義の C++ 内部識別子は、外部識別子と先頭から 64 文字目までに違いがあるべきである" id="34_b" impl="PORT-34_b" severity="3"/>
         <rule autogen="true" header="同一スコープで宣言されたユーザー定義の C++ 内部識別子は、先頭から 64 文字目までに違いがあるべきである" id="34_c" impl="PORT-34_c" severity="3"/>
         <rule autogen="true" header="ユーザー定義の C 外部識別子は、 先頭から 31 文字目までに違いがあるべきである" id="35_a" impl="PORT-35_a" severity="3"/>
         <rule autogen="true" header="ユーザー定義の C 内部識別子は、外部識別子と先頭から 31 文字目までに違いがあるべきである" id="35_b" impl="PORT-35_b" severity="3"/>
         <rule autogen="true" header="同一スコープで宣言されたユーザー定義の C 内部識別子は、先頭から 31 文字目までに違いがあるべきである" id="35_c" impl="PORT-35_c" severity="3"/>
         <rule autogen="true" header="識別子の名前は 31 文字を超えるべきではない" id="36_a" impl="PORT-36_a" severity="3"/>
         <rule autogen="true" header="マクロ識別子の名前は 31 文字を超えるべきではない" id="36_b" impl="PORT-36_b" severity="3"/>
      </category>
      <category description="プリプロセッサ" name="PREPROC">
         <rule autogen="true" header="マクロ定義の使用を避ける" id="01" impl="PREPROC-01" severity="3"/>
         <rule autogen="true" header="include 文の中でマクロを使ってはいけない" id="02" impl="PREPROC-02" severity="2"/>
         <rule autogen="true" header="プリミティブ型を再定義してはならない" id="03" impl="PREPROC-03" severity="4"/>
         <rule autogen="true" header="命令の一部を定義してはいけない。" id="04" impl="PREPROC-04" severity="4"/>
         <rule autogen="true" header="マクロ関数では、乗算または除算の前後に括弧を使用する" id="05" impl="PREPROC-05" severity="2"/>
         <rule autogen="true" header="#include 文で絶対または相対パス名を許可しない" id="06" impl="PREPROC-06" severity="2"/>
         <rule autogen="true" header="不正な NULL 定義である" id="07" impl="PREPROC-07" severity="5"/>
         <rule autogen="true" header="#include プリプロセッサ命令はヘッダー ファイル (*.h) をインクルードするためにだけ使用する" id="08" impl="PREPROC-08" severity="3"/>
         <rule autogen="true" header="#include 命令は &lt;filename.h&gt; という表記を使用してヘッダー ファイルをインクルードしなければならない" id="09" impl="PREPROC-09" severity="2"/>
         <rule autogen="true" header="#ifndef プリプロセッサ命令は、同じファイルの多重インクルードを防ぐためだけに使用する" id="10" impl="PREPROC-10" severity="3"/>
         <rule autogen="true" header="#endif プリプロセッサ命令は、同じファイルの多重インクルードを防ぐためだけに使用する" id="10_b" impl="PREPROC-10_b" severity="3"/>
         <rule autogen="true" header="#if プリプロセッサ命令は、同じファイルの多重インクルードを防ぐためだけに使用する" id="10_c" impl="PREPROC-10_c" severity="3"/>
         <rule autogen="true" header="#ifdef、#else、#elif プリプロセッサ命令を使用するべきではない" id="11" impl="PREPROC-11" severity="3"/>
         <rule autogen="true" header="#if プリプロセッサ命令を使用するべきではない" id="11_b" impl="PREPROC-11_b" severity="3"/>
         <rule autogen="true" header="C++ マクロはインクルード ガード、型修飾子、記憶域クラス指定子のためにだけ使用する" id="12" impl="PREPROC-12" severity="3"/>
         <rule autogen="true" header="マクロにはトークン ペースト、可変引数リスト、マクロの再帰呼び出しが含まれていてはならない" id="13" impl="PREPROC-13" severity="3"/>
         <rule autogen="true" header="すべてのマクロは完全な構文単位に展開されなければならない" id="14" impl="PREPROC-14" severity="3"/>
         <rule autogen="true" header="ポインターの間接参照演算がマクロ定義に隠されていてはいけない" id="15" impl="PREPROC-15" severity="3"/>
         <rule autogen="true" header="# 演算子があるマクロ パラメーターは、直前、直後に ## 演算子があってはいけない" id="16" impl="PREPROC-16" severity="3"/>
         <rule autogen="true" header="# または ## 演算子のオペランドとして使用されており、それ自体がマクロ置換の対象であるマクロ パラメーターは、それらの演算子のオペランドとしてだけ使用されなければならない" id="17" impl="PREPROC-17" severity="4"/>
         <rule autogen="true" header="入出力ライブラリ stdio.h をインクルードしてはならない" id="18" impl="PREPROC-18" severity="3"/>
         <rule autogen="true" header="#if または #elif プリプロセッサ ディレクティブの制御式は 0 または 1 に評価されなければならない" id="19" impl="PREPROC-19" severity="3"/>
         <rule autogen="true" header="#include ディレクティブのファイル名をファイルシステムのファイルに合わせる" id="20" impl="PREPROC-20" severity="3"/>
         <rule autogen="true" header="結果がユニバーサル文字名になる可能性があるトークンの連結を行わない" id="21" impl="PREPROC-21" severity="5"/>
         <rule autogen="true" header="#error ディレクティブを使用してはならない" id="22" impl="PREPROC-22" severity="3"/>
         <rule autogen="true" header="#pragma ディレクティブを使用してはならない" id="23" impl="PREPROC-23" severity="3"/>
         <rule autogen="true" header="#ifdef および #ifndef プリプロセッサ ディレクティブと defined() 演算子を除いて、プリプロセッサ ディレクティブ内のすべてのマクロ識別子は、使用する前に定義される必要がある" id="24" impl="PREPROC-24" severity="3"/>
         <rule autogen="true" header="#undef を使用するべきではない" id="25" impl="PREPROC-25" severity="3"/>
         <rule autogen="true" header="#ifndef、#ifdef、#if、#elif、#else、#endif プリプロセッサ命令は条件付きのファイル インクルードおよびインクルード ガードにだけ使用する" id="26" impl="PREPROC-26" severity="3"/>
      </category>
      <category description="Qt ベスト プラクティス" name="QT">
         <rule autogen="true" header="すべての QObject のサブクラスに、Q_OBJECT マクロがなければならない" id="01" impl="QT-01" severity="3"/>
         <rule autogen="true" header="QObject を 2 回以上継承してはならない" id="02" impl="QT-02" severity="3"/>
         <rule autogen="true" header="シグナルをスロットに、またはシグナルを他のシグナルに接続することだけができる" id="03" impl="QT-03" severity="3"/>
         <rule autogen="true" header="SIGNAL および SLOT マクロ内のメソッドが存在しなければならない" id="04" impl="QT-04" severity="1"/>
         <rule autogen="true" header="シグナルの発信をキーワード emit でマークし、シグナルの発信と他のメソッド呼び出しを区別する" id="05" impl="QT-05" severity="3"/>
         <rule autogen="true" header="QThread に Idle または Critical 優先度を設定しない。High/Low/Med だけを使用する" id="06" impl="QT-06" severity="3"/>
         <rule autogen="true" header="QThread::terminate() を呼び出してスレッドを強制終了しない" id="07" impl="QT-07" severity="1"/>
         <rule autogen="true" header="関数で mutex のロックを使用している場合、同じ関数内でロックを解除する" id="08" impl="QT-08" severity="3"/>
         <rule autogen="true" header="QMutexLocker で new を呼び出さない" id="09" impl="QT-09" severity="1"/>
         <rule autogen="true" header="ポインタを持ち Qt - を継承するすべてのクラスに対し、コピー コンストラクタおよび = 演算子を宣言する" id="10" impl="QT-10" severity="3"/>
         <rule autogen="true" header="Widget で setWindowFlags 関数を使用しない" id="11" impl="QT-11" severity="4"/>
         <rule autogen="true" header="Qt カーネルによって設定される特定の Widget 属性を直接設定しない" id="12" impl="QT-12" severity="1"/>
         <rule autogen="true" header="代入の中で定数反復子と非定数反復子を混用しない" id="13" impl="QT-13" severity="3"/>
         <rule autogen="true" header="Q_DECLARE_FLAGS を使用する場合、Q_DECLARE_OPERATORS_FOR_FLAGS も使用する" id="14" impl="QT-14" severity="3"/>
         <rule autogen="true" header="Q_DECLARE_OPERATORS_FOR_FLAGS はグローバルな名前空間に、 Q_DECLARE_FLAGS は列挙型の名前空間になければならない" id="15" impl="QT-15" severity="3"/>
         <rule autogen="true" header="Q_PROPERTY のゲッターおよびセッターが存在し、型が一致しなければならない" id="16" impl="QT-16" severity="3"/>
         <rule autogen="true" header="列挙型のプロパティは Q_ENUMS を使用する" id="17" impl="QT-17" severity="3"/>
         <rule autogen="true" header="Qt オブジェクトに対し非定数関数を呼び出さない" id="18" impl="QT-18" severity="3"/>
      </category>
      <category description="セキュリティ" name="SECURITY">
         <rule autogen="true" header="時刻を使用する標準 C ライブラリ関数を使用しないようにする" id="01" impl="SECURITY-01" severity="2"/>
         <rule autogen="true" header="C ライブラリの乱数を使用する関数は使用しないようにする" id="02" impl="SECURITY-02" severity="2"/>
         <rule autogen="true" header="疑似乱数の生成に rand() 関数を使用しない" id="02_b" impl="SECURITY-02_b" severity="3"/>
         <rule autogen="true" header="システム プロパティ (環境変数) の使用は制限されるべきである" id="03" impl="SECURITY-03" severity="4"/>
         <rule autogen="true" header="LoadLibrary() が正しいライブラリをロードするよう注意する" id="04" impl="SECURITY-04" severity="2"/>
         <rule autogen="true" header="printf/wprintf 関数を文字列定数以外の引数 1 個だけで使用しないようにする" id="05" impl="SECURITY-05" severity="2"/>
         <rule autogen="true" header="時刻を使用する MFC ライブラリ関数を使用しないようにする" id="06" impl="SECURITY-06" severity="3"/>
         <rule autogen="true" header="範囲チェックされていないバッファに書き込む安全でない C 関数を使用しない" id="07" impl="SECURITY-07" severity="3"/>
         <rule autogen="true" header="2 番目のパラメータが変数である場合に、fprintf/fwprintf 関数をパラメータ 2 個だけで使用してはいけない" id="08" impl="SECURITY-08" severity="2"/>
         <rule autogen="true" header="string 標準ライブラリ クラスの data() 関数は使用しないようにする" id="09" impl="SECURITY-09" severity="2"/>
         <rule autogen="true" header="'vfork()' 関数を使用しない" id="10" impl="SECURITY-10" severity="2"/>
         <rule autogen="true" header="shell メタ文字に影響される可能性があるため安全でない shell 関数は使用しない" id="11" impl="SECURITY-11" severity="2"/>
         <rule autogen="true" header="バッファ オーバーフローの原因になる可能性があるため、安全ではない文字列関数を使用しないようにする" id="12" impl="SECURITY-12" severity="2"/>
         <rule autogen="true" header="範囲をチェックしないため安全ではない文字列関数を使用しないようにする" id="13" impl="SECURITY-13" severity="2"/>
         <rule autogen="true" header="書式文字列で変数サイズを指定せずに scanf または fscanf 関数を使用しない" id="14" impl="SECURITY-14" severity="2"/>
         <rule autogen="true" header="アプリケーション　エラーを例外メッセージに含めることによって、機密の可能性がある情報を出力してはならない" id="15" impl="SECURITY-15" severity="2"/>
         <rule autogen="true" header="gets() を使用しない" id="16" impl="SECURITY-16" severity="1"/>
         <rule autogen="true" header="非定数パラメータや変数を exec に渡さないようにする" id="17" impl="SECURITY-17" severity="2"/>
         <rule autogen="true" header="動的に作成された文字列を exec に渡さないようにする" id="18" impl="SECURITY-18" severity="2"/>
         <rule autogen="true" header="競合の原因となる関数を使用してはいけない" id="19" impl="SECURITY-19" severity="2"/>
         <rule autogen="true" header="パラメータとしてユーザ入力をメソッドに渡してはいけない" id="20" impl="SECURITY-20" severity="2"/>
         <rule autogen="true" header="ロギングのために syslog 関数を使用しない" id="21" impl="SECURITY-21" severity="2"/>
         <rule autogen="true" header="mbstowcs() 関数を使用しない" id="22" impl="SECURITY-22" severity="2"/>
         <rule autogen="true" header="カレント ディレクトリまたは windows ディレクトリを返す可能性のある関数に注意する" id="23" impl="SECURITY-23" severity="2"/>
         <rule autogen="true" header="InitializeCriticalSection を使用しない" id="24" impl="SECURITY-24" severity="2"/>
         <rule autogen="true" header="スレッド セーフでない関数を使用してはならない" id="25" impl="SECURITY-25" severity="2"/>
         <rule autogen="true" header="setuid を使用しない" id="26" impl="SECURITY-26" severity="2"/>
         <rule autogen="true" header="chmod()、chown()、chgrp() を使用しない" id="27" impl="SECURITY-27" severity="2"/>
         <rule autogen="true" header="セキュリティ上の理由で乱数が必要な場合に、標準の乱数ジェネレータを使用してはならない" id="28" impl="SECURITY-28" severity="2"/>
         <rule autogen="true" header="非推奨の C ルーティン ulimit() を使用しない" id="29" impl="SECURITY-29" severity="2"/>
         <rule autogen="true" header="プログラム コードで getpw 関数を使用しないようにする" id="30" impl="SECURITY-30" severity="2"/>
         <rule autogen="true" header="cuserid 関数を使用しない" id="31" impl="SECURITY-31" severity="2"/>
         <rule autogen="true" header="非推奨の C ルーティン usleep を使用しない" id="32" impl="SECURITY-32" severity="2"/>
         <rule autogen="true" header="NULL 終端子のない文字列を適切に処理していない関数を使用してはならない" id="33" impl="SECURITY-33" severity="2"/>
         <rule autogen="true" header="環境変数を使用しない" id="34" impl="SECURITY-34" severity="2"/>
         <rule autogen="true" header="攻撃者から設定可能なコマンド ラインの値を信頼しない" id="35" impl="SECURITY-35" severity="2"/>
         <rule autogen="true" header="信頼されないユーザからの入力をフィルタせずに書式パラメータに使用してはならない" id="36" impl="SECURITY-36" severity="2"/>
         <rule autogen="true" header="弱い暗号化関数を使用してはならない" id="37" impl="SECURITY-37" severity="2"/>
         <rule autogen="true" header="信頼性のないデータをループの境界として使用してはならない" id="38" impl="SECURITY-38" severity="2"/>
         <rule autogen="true" header="安全な一時ファイル名関数を使用する" id="39" impl="SECURITY-39" severity="3"/>
         <rule autogen="true" header="mkstemp を呼び出す前に umask を呼び出す" id="40" impl="SECURITY-40" severity="4"/>
         <rule autogen="true" header="chroot を呼び出す場合、chdir を呼び出す" id="41" impl="SECURITY-41" severity="4"/>
         <rule autogen="true" header="open または openat システム コールを使用してファイルを作成する場合、アクセス パーミッション ビットを指定する" id="42" impl="SECURITY-42" severity="3"/>
         <rule autogen="true" header="'PTHREAD_CANCEL_ASYNCHRONOUS' 引数を指定して 'pthread_setcanceltype()' 関数を呼び出すべきではない" id="43" impl="SECURITY-43" severity="3"/>
         <rule autogen="true" header="権限を正しい順序で破棄する" id="44" impl="SECURITY-44" severity="3"/>
         <rule autogen="true" header="権限が正常に破棄されたことを確認する" id="45" impl="SECURITY-45" severity="3"/>
         <rule autogen="true" header="データをユーザー領域にコピーできる関数に構造体へのポインターを渡すべきではない" id="46" impl="SECURITY-46" severity="3"/>
         <rule autogen="true" header="シフト演算子の右辺のオペランドをチェックする際、適切な整数精度を使用する" id="47" impl="SECURITY-47" severity="3"/>
         <rule autogen="true" header="stdlib.h または cstdlib ライブラリの system() 関数を '0' (null ポインター) 以外の引数で呼び出さない" id="48" impl="SECURITY-48" severity="3"/>
         <rule autogen="true" header="stdlib.h または cstdlib ライブラリの system() 関数を使用しない" id="48_b" impl="SECURITY-48_b" severity="3"/>
         <rule autogen="true" header="固有の条件変数とともに 'cnd_signal()' 関数を使用する" id="49" impl="SECURITY-49" severity="4"/>
         <rule autogen="true" header="複数のスレッドが同じ条件変数を待機している場合、'notify_one()' 関数を使用しない" id="50" impl="SECURITY-50" severity="4"/>
         <rule autogen="true" header="char バッファーを使用して std::cin の入力を格納しない" id="51" impl="SECURITY-51" severity="3"/>
         <rule autogen="true" header="stdlib.h または cstdlib ライブラリの 'getenv() 関数を使用しない" id="52" impl="SECURITY-52" severity="3"/>
      </category>
      <category description="STL ベスト プラクティス" name="STL">
         <rule autogen="true" header="コンテナに依存しないコードを書こうとするより、クラスのカプセル化を使用する" id="01" impl="STL-01" severity="5"/>
         <rule autogen="true" header="コピーを効率的かつ正確に行い、スライシングの問題を避けるため、オブジェクトのコンテナではなくポインタのコンテナを作成する" id="02" impl="STL-02" severity="3"/>
         <rule autogen="true" header="size() で 0 を調べる代わりに empty を呼び出す" id="03" impl="STL-03" severity="3"/>
         <rule autogen="true" header="明示的なループで insert を繰り返し呼び出してはならない" id="04" impl="STL-04" severity="3"/>
         <rule autogen="true" header="挿入反復子によりコピー先範囲を指定するほとんどの場合を、範囲メンバ関数の呼び出しに置き換えるべきである" id="05" impl="STL-05" severity="3"/>
         <rule autogen="true" header="関数パラメータとして使用する場合、無名の istream_iterator オブジェクトではなく、istream_iterator の名前を使用する" id="06" impl="STL-06" severity="3"/>
         <rule autogen="true" header="new したポインタのコンテナを使うときは、必ずポインタを delete した後にコンテナを破棄する" id="07" impl="STL-07" severity="3"/>
         <rule autogen="true" header="auto_ptr 型のコンテナを作成しない" id="08" impl="STL-08" severity="3"/>
         <rule autogen="true" header="list および標準連想コンテナで remove アルゴリズムを使用しない" id="09" impl="STL-09" severity="3"/>
         <rule autogen="true" header="動的に割り当てられる配列より vector と string を優先して使う" id="10" impl="STL-10" severity="3"/>
         <rule autogen="true" header="string ではなく vector&lt;char&gt; を使用する" id="11" impl="STL-11" severity="4"/>
         <rule autogen="true" header="reserve を使って不必要な割り当てを避ける" id="12" impl="STL-12" severity="3"/>
         <rule autogen="true" header="vector または string を C 関数に渡す前に、空でないかチェックしなければならない" id="13" impl="STL-13" severity="3"/>
         <rule autogen="true" header="vector&lt;bool&gt; を使用しない" id="14" impl="STL-14" severity="3"/>
         <rule autogen="true" header="ポインタの連想コンテナに対する比較の種類を指定する" id="15" impl="STL-15" severity="3"/>
         <rule autogen="true" header="等しい値に対して true を返す比較関数を連想コンテナに使用しない" id="16" impl="STL-16" severity="3"/>
         <rule autogen="true" header="等しい値に対して true を返す比較関数を連想コンテナに使用しない" id="17" impl="STL-17" severity="3"/>
         <rule autogen="true" header="const_iterator、reverse_iterator、const_reverse_iterator より iterator を優先的に使う" id="18" impl="STL-18" severity="3"/>
         <rule autogen="true" header="コンテナの const_iterator を iterator に変換するには、distance と advance を使用する" id="19" impl="STL-19" severity="3"/>
         <rule autogen="true" header="消去目的で reverse_iterator の基底 iterator を使用する場合は注意が必要である" id="20" impl="STL-20" severity="4"/>
         <rule autogen="true" header="1 文字ごとの入力には istreambuf_iterator の使用を考える" id="21" impl="STL-21" severity="4"/>
         <rule autogen="true" header="出力範囲の大きさを確認する" id="22" impl="STL-22" severity="3"/>
         <rule autogen="true" header="本当に削除したい場合は、remove 風アルゴリズムの後に erase を使う" id="23" impl="STL-23" severity="3"/>
         <rule autogen="true" header="動的に割り当てられるポインタのコンテナに対して remove や同様のアルゴリズム (remove_if と unique) の使用を避ける" id="24" impl="STL-24" severity="3"/>
         <rule autogen="true" header="アルゴリズムにソート済み範囲と共に比較関数も渡す場合、範囲のソートに使った関数と同じように動作する比較関数を渡す必要がある" id="25" impl="STL-25" severity="4"/>
         <rule autogen="true" header="copy_if の正しい実装は、述語の前に not1 がある remove_copy_if の戻り値に基づくものであってはならない" id="26" impl="STL-26" severity="3"/>
         <rule autogen="true" header="accumulate() を浮動小数点型の値のコンテナに使用する場合、浮動小数点型の初期値を使用する" id="27" impl="STL-27" severity="3"/>
         <rule autogen="true" header="値渡し用のファンクタ クラスを設計する" id="28" impl="STL-28" severity="3"/>
         <rule autogen="true" header="述語を純粋関数にする" id="29" impl="STL-29" severity="3"/>
         <rule autogen="true" header="ファンクタクラスは 1 つの operator() 関数だけを持つべきであり、またパラメータと戻り値の型を unary_function または binary_function に渡さなければならない" id="30" impl="STL-30" severity="3"/>
         <rule autogen="true" header="STL のコンポーネントに関数を渡す場合、ptr_fun、mem_fun、または mem_fun_ref を使用しなければならない" id="31" impl="STL-31" severity="3"/>
         <rule autogen="true" header="less&lt;T&gt; が operator&lt; を意味することを理解する" id="32" impl="STL-32" severity="3"/>
         <rule autogen="true" header="独自に作成したループよりアルゴリズムの呼び出しを優先して使用する" id="33" impl="STL-33" severity="3"/>
         <rule autogen="true" header="アルゴリズムより同名のメンバ関数を優先して使用する" id="34" impl="STL-34" severity="3"/>
         <rule autogen="true" header="count() の非ゼロ値から true 、または ゼロから false への変換に頼らない" id="35" impl="STL-35" severity="3"/>
         <rule autogen="true" header="実際には範囲ではないイテレータ範囲を使用してはならない" id="36" impl="STL-36" severity="3"/>
         <rule autogen="true" header="C スタイルの配列を使用してはならない" id="37" impl="STL-37" severity="3"/>
         <rule autogen="true" header="イテレータの比較には  &lt; ではなく != を使用する" id="38" impl="STL-38" severity="3"/>
         <rule autogen="true" header="オーバーロードと traits クラスを組み合わせて使用する" id="39" impl="STL-39" severity="3"/>
         <rule autogen="true" header="swap を呼び出す場合、std::swap を using 宣言し、swap を名前空間修飾なしで呼び出す" id="40" impl="STL-40" severity="3"/>
         <rule autogen="true" header="非メンバの swap を std::swap のオーバーロードとして宣言しない" id="41" impl="STL-41" severity="3"/>
         <rule autogen="true" header="メンバ関数の swap は決して例外を投げてはならない" id="42" impl="STL-42" severity="3"/>
      </category>
      <category description="テンプレート" name="TEMPL">
         <rule autogen="true" header="パラメータに依存しないコードはテンプレートから外に出す" id="01" impl="TEMPL-01" severity="3"/>
         <rule autogen="true" header="型変換をさせたいなら、メンバでない関数をクラステンプレートの中で定義する" id="02" impl="TEMPL-02" severity="3"/>
         <rule autogen="true" header="テンプレート クラス中の関数をオーバーロードしてはいけない" id="03" impl="TEMPL-03" severity="3"/>
         <rule autogen="true" header="テンプレート グローバル関数では、ネストされた依存名指定に typename を使用する" id="04" impl="TEMPL-04" severity="3"/>
         <rule autogen="true" header="テンプレート グローバル関数で、ネストされた依存名を指定するには typename を使用する" id="05" impl="TEMPL-05" severity="3"/>
         <rule autogen="true" header="テンプレート クラスでは、仮想関数のデフォルト引数を変更してはならない" id="06" impl="TEMPL-06" severity="3"/>
         <rule autogen="true" header="1 つのジェネリック パラメータを持つテンプレート  コンストラクタがある場合、コピー コンストラクタを宣言する" id="07" impl="TEMPL-07" severity="3"/>
         <rule autogen="true" header="関数呼び出しの実行可能な関数セットには関数の特殊化が含まれていないか、関数の特殊化だけが含まれるべきである" id="08" impl="TEMPL-08" severity="3"/>
         <rule autogen="true" header="オーバーロードされた関数テンプレートを明示的に特殊化してはならない" id="09" impl="TEMPL-09" severity="3"/>
         <rule autogen="true" header="テンプレートの部分特殊化および明示的な特殊化は、一次テンプレートと同じファイルに宣言する" id="10" impl="TEMPL-10" severity="3"/>
         <rule autogen="true" header="1 つのジェネリック パラメータを持つテンプレート代入演算子がある場合、コピー代入演算子を宣言する" id="11" impl="TEMPL-11" severity="3"/>
         <rule autogen="true" header="依存基底クラスを持つクラス テンプレートでは、依存基底クラスで見つかるすべての名前を修飾識別子または this-&gt; を使用して参照する" id="12" impl="TEMPL-12" severity="3"/>
         <rule autogen="true" header="関連する名前空間に非メンバー ジェネリック関数を宣言しない" id="13" impl="TEMPL-13" severity="3"/>
         <rule autogen="true" header="関数は、翻訳単位で事前に宣言されている関数に解決されなければならない" id="14" impl="TEMPL-14" severity="3"/>
         <rule autogen="true" header="明示的にインスタンス化されるテンプレートを extern 宣言する" id="15" impl="TEMPL-15" severity="3"/>
         <rule autogen="true" header="テンプレートの特殊化は、一次テンプレートまたは特殊化が宣言されたユーザー定義型と同じファイルに宣言する" id="16" impl="TEMPL-16" severity="3"/>
         <rule autogen="true" header="typename キーワードが戻り値型の前にある場合、後置戻り値型構文を使用する" id="17" impl="TEMPL-17" severity="3"/>
         <rule autogen="true" header="非 メンバー ジェネリック演算子は、クラス (構造体) 型、列挙型、共用体型の宣言を含まない名前空間にだけ宣言できる" id="18" impl="TEMPL-18" severity="3"/>
      </category>
   </builtin>
</rules>